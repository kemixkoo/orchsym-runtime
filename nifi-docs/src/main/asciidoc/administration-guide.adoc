// 
// Licensed to the Apache Software Foundation (ASF) under one or more 
// contributor license agreements.  See the NOTICE file distributed with 
// this work for additional information regarding copyright ownership. 
// The ASF licenses this file to You under the Apache License, Version 2.0 
// (the "License"); you may not use this file except in compliance with 
// the License.  You may obtain a copy of the License at 
// 
//     http://www.apache.org/licenses/LICENSE-2.0 
// 
// Unless required by applicable law or agreed to in writing, software 
// distributed under the License is distributed on an "AS IS" BASIS, 
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
// See the License for the specific language governing permissions and 
// limitations under the License. 
// 
= Orchsym Studio系统管理员指南
Orchsym Studio团队<orchsym@baishancloud.com> 
:homepage: https://www.baishancloud.com/ 
:linkattrs: 

== 系统要求 
Orchsym Studio可以像笔记本电脑一样简单地运行，但也可以跨多个企业级服务器进行集群. 因此，所需的硬件和内存量将取决于所涉及的数据流的大小和性质. 在Orchsym Studio处理数据时，数据存储在磁盘上. 所以Orchsym Studio需要为其各种存储库分配足够的磁盘空间，特别是内容存储库，流文件存储库和源文件库(有关这些存储库的更多信息，请参阅<<system_properties>>部分). Orchsym Studio具有以下最低系统要求: 

* 需要Java 8或更高版本 
* 支持的操作系统: 
** Linux的 
** Unix的 
** 视窗 
** Mac OS X. 
* 支持的Web浏览器: 
** Microsoft Edge:Current＆(Current - 1) 
** Mozilla FireFox:Current＆(Current - 1) 
** 谷歌浏览器:当前和(当前 - 1) 
** Safari:Current＆(Current - 1) 

**注意** 在持续且极高的吞吐量下，可能需要调整CodeCache设置以避免突然的性能损失.  有关更多信息，请参阅<<bootstrap_properties>>部分. 

== 如何安装和启动Orchsym Studio 

* Linux / Unix / OS X. 
** 解压缩并解压缩到所需的安装目录 
** 在<installdir> / conf下找到的文件中进行任何所需的编辑 
*** 至少，我们建议您编辑 _Orchsym Studio.properties_ 文件并输入Orchsym Studio的密码.敏感.道具.key(见下面的<<system_properties>>) 
** 从<installdir> / bin目录中，键入以执行以下命令 ./ Orchsym Studio.sh <command>: 
*** 开始:在后台启动Orchsym Studio 
*** 停止:停止在后台运行的Orchsym Studio 
*** status:提供Orchsym Studio的当前状态 
*** run:在前台运行Orchsym Studio并等待Ctrl-C启动Orchsym Studio的关闭 
*** 安装:安装Orchsym Studio作为服务，然后可以通过控制 
**** 服务Orchsym Studio开始 
**** 服务Orchsym Studio停止 
**** 服务Orchsym Studio状态 

* 视窗 
** 解压缩到所需的安装目录 
** 在<installdir> / conf下找到的文件中进行任何所需的编辑 
*** 至少，我们建议您编辑 _Orchsym Studio.properties_ 文件并输入Orchsym Studio的密码.敏感.道具.key(见下面的<<system_properties>>) 
** 导航到<installdir> / bin目录 
** 双击run-Orchsym Studio.蝙蝠. 这会在前台运行Orchsym Studio并等待Ctrl-C启动Orchsym Studio的关闭 
** 要查看Orchsym Studio的当前状态，请双击status-Orchsym Studio.bat 


Orchsym Studio首次启动时，会创建以下文件和目录: 

* content_repository 
* database_repository 
* flowfile_repository 
* provenance_repository 
* 工作目录 
* 日志目录 
* 在conf目录中， _flow.xml.gz_ 文件和模板目录已创建 

有关配置Orchsym Studio存储库和配置文件的详细信息，请参阅本指南的<<system_properties>>部分。. 


== 配置最佳实践 
NOTE: 如果您在Linux上运行，请考虑这些最佳实践. 典型的Linux默认设置不一定能够满足像Orchsym Studio这样的IO密集型应用程序的需求.  对于所有这些领域，您的发行版的要求可能会有所不同.  使用这些部分作为建议，但 
请参阅特定于发行版的文档，以了解如何最好地实现这些建议. 

最大文件句柄:: 
Orchsym Studio在任何时候都可能打开非常大量的文件句柄.  通过 
编辑'/ etc / security / limits来增加限制.CONF' 添加 
类似的东西 

---- 
*  hard  nofile  50000 
*  soft  nofile  50000 
---- 

最大分叉进程:: 
Orchsym Studio可以配置为生成大量线程.  要增加允许的编号，请编辑'/ etc / security / limits.CONF” 

---- 
*  hard  nproc  10000 
*  soft  nproc  10000 
---- 

您的发行版可能需要编辑/ etc / security / limits.d / 90-NPROC.通过添加conf 

---- 
*  soft  nproc  10000 
---- 


增加可用的TCP套接字端口数量:: 
如果您的流程将
在很短的时间内设置并拆除大量套接字，这一点尤其重要 . 

---- 
sudo sysctl -w net.ipv4.ip_local_port_range="10000 65000" 
---- 


设置套接字在关闭时保持TIMED_WAIT状态的时间长度:: 
您不希望自己的套接字停留太长时间，因为您希望 
能够快速设置和拆除新套接字.  这是一个好主意，阅读更多关于 
它，但调整做类似的事情 

---- 
sudo sysctl -w net.ipv4.netfilter.ip_conntrack_tcp_timeout_time_wait="1" 
---- 


告诉Linux你永远不希望Orchsym Studio交换:: 
交换非常适合某些应用程序.  像
Orchsym Studio这样的东西总是想要跑步并不好 .  要告诉Linux你想换掉你 
可以编辑'/ etc / sysctl.CONF' 添加以下行 

---- 
vm.swappiness = 0 
---- 

对于处理各种Orchsym Studio repos的分区，请关闭"atime”之类的内容. 
这样做会导致吞吐量出人意料地大幅增加.  编辑'/ etc / fstab' 文件 
和感兴趣的分区添加'noatime' 选项. 


== 安全配置 

Orchsym Studio提供多种不同的配置选项以用于安全目的.最重要的属性是在
"安全属性”标题下的那些 属性 _Orchsym Studio.properties_ 文件. 为了安全运行，必须设置以下属性: 

[options="header,footer"] 
|================================================================================================================================================== 
| Property Name | 描述 
|`Orchsym Studio.security.keystore` | 包含服务器私钥的密钥库的文件名. 
|`Orchsym Studio.security.keystoreType` | 密钥库的类型. 必须是 `PKCS12` 要么 `JKS`.  JKS是首选类型，PKCS12文件将加载BouncyCastle提供程序. 
|`Orchsym Studio.security.keystorePasswd` | 密钥库的密码. 
|`Orchsym Studio.security.keyPasswd` | 密钥库中证书的密码. 如果没有设置，则为 `Orchsym Studio.security.keystorePasswd` 将会被使用. 
|`Orchsym Studio.security.truststore` | 将用于授权连接到Orchsym Studio的Truststore的文件名.  没有Truststore的安全实例将拒绝所有传入连接. 
|`Orchsym Studio.security.truststoreType` | Truststore的类型. 必须是 `PKCS12` 要么 `JKS`.  JKS是首选类型，PKCS12文件将加载BouncyCastle提供程序. 
|`Orchsym Studio.security.truststorePasswd` | Truststore的密码. 
|`Orchsym Studio.security.needClientAuth` | 设置 `true` 指定连接客户端必须验证自己. Orchsym Studio群集协议使用此属性来指示群集中的节点将进行身份验证，并且必须具有Truststores信任的证书. 
|================================================================================================================================================== 

一旦配置了上述属性，我们就可以通过HTTPS而不是HTTP来访问用户界面.这是 
通过设置 `Orchsym Studio.web.https.host` 和 `Orchsym Studio.web.https.port` 性能. 该 `Orchsym Studio.web.https.host` property指示服务器
应在哪个主机名上 运行. 如果希望可以从所有网络接口访问HTTPS接口，则值为 `0.0.0.0` 应该使用.  要允许 
管理员将应用程序配置为仅在特定网络接口上运行， `Orchsym Studio.web.http.network.interface*` 要么 `Orchsym Studio.web.https.network.interface*` 
属性可以指定. 

NOTE: 启用HTTPS时，重要的是 `Orchsym Studio.web.http.port` 财产没有设置. Orchsym Studio仅支持在HTTP上运行 *要么* HTTPS，不是同时进行的. 

如同 `Orchsym Studio.security.needClientAuth`，Web服务器可以配置为要求访问
用户界面的用户使用基于证书的客户端身份验证 . 为此，必须将其配置为不支持使用<<ldap进行用户名/密码验证_login_identity_provider>>或<<kerberos_login_IDENTITY_PROVIDER>>.这些选项中的任何一个都 
将Web服务器配置为WANT基于证书的客户端身份验证.这将允许它支持具有证书的用户，而没有证书的用户 
可以使用他们的凭据或匿名访问来登录.如果未配置用户名/密码身份验证和匿名访问， 
则Web服务器将请求基于证书的客户端身份验证. 有关更多详细信息，请参见<<user_authentication>>. 

既然用户界面已经受到保护，我们也可以轻松保护站点到站点的连接和内部群集通信.这是 
通过设置 `Orchsym Studio.remote.input.secure` 和 `Orchsym Studio.cluster.protocol.is.secure` 属性，分别为 `true`. 


=== TLS生成工具包 

为了便于安全设置Orchsym Studio，您可以使用 `tls-toolkit` 命令行实用程序，用于自动生成所需的密钥库，信任库和相关配置文件. 这对于保护多个Orchsym Studio节点特别有用，这可能是一个单调乏味且容易出错的过程. 

NOTE: 建议将NiK用于JKS密钥商店和信任商店.  此工具允许在命令行上指定其他密钥库类型，但将忽略一种类型的PKCS12以用作信任库，因为该格式在BouncyCastle和Oracle实现之间存在一些兼容性问题. 

该 `tls-toolkit` 命令行工具有两种主要的操作模式: 

1. 独立 -- 生成证书颁发机构，密钥库，信任库和Orchsym Studio.一个命令中的属性文件. 
2. 客户端/服务器模式 -- 使用证书颁发机构服务器，该服务器接受来自客户端的证书签名请求，对其进行签名，然后将结果证书发回.  客户端和服务器都通过共享密钥验证对方的身份. 

==== Standalone 
通过运行调用独立模式 `./bin/tls-toolkit.sh standalone -h` 它会打印使用信息以及可以指定的选项说明. 

您可以使用以下命令行选项 `tls-toolkit` 在独立模式下: 

* `-a`，`--keyAlgorithm <arg>`                   用于生成密钥的算法(默认值: `RSA`) 
* `-B`，`--clientCertPassword <arg>`             客户端证书的密码. 每个客户端DN必须是一个值或一个值(如果未指定则自动生成) 
* `-c`，`--certificateAuthorityHostname <arg>`   Orchsym Studio证书颁发机构的主机名(默认值: `localhost`) 
* `-C`，`--clientCertDn <arg>`                   生成适合在具有指定DN的浏览器中使用的客户端证书(可以多次指定) 
* `-d`，`--days <arg>`                           颁发证书的天数应该有效(默认值: `1095`) 
* `-f`，`--Orchsym StudioPropertiesFile <arg>`             基础 `Orchsym Studio.properties` 要更新的文件(如果未指定，将使用与默认Orchsym Studio安装中的嵌入式文件相同的嵌入式文件) 
* `-g`，`--differentKeyAndKeystorePasswords`     为密钥和密钥库使用不同的生成密码 
* `-G`，`--globalPortSequence <arg>`             根据提供的主机名表达式使用为所有主机计算的顺序端口(可以多次指定，必须从运行到运行) 
* `-h`，`--help`                                 打印帮助并退出 
* `-k`，`--keySize <arg>`                        生成密钥的位数(默认值: `2048`) 
* `-K`，`--keyPassword <arg>`                    要使用的密钥密码. 每个主机必须是一个值或一个值(如果未指定则自动生成) 
* `-n`，`--hostnames <arg>`                      逗号分隔的主机名列表 
* `--Orchsym StudioDnPrefix <arg>`                        确定DN时要添加到主机名的字符串(默认值: `CN=`) 
* `--Orchsym StudioDnSuffix <arg>`                        确定DN时要附加到主机名的字符串(默认值: `, OU=Orchsym Studio`) 
* `-o`，`--outputDirectory <arg>`                输出密钥库，信任库，配置文件的目录(默认值: `../bin`) 
* `-O`，`--isOverwrite`                          覆盖现有主机输出 
* `-P`，`--trustStorePassword <arg>`             要使用的密钥库密码. 每个主机必须是一个值或一个值(如果未指定则自动生成) 
* `-s`，`--signingAlgorithm <arg>`               用于签名证书的算法(默认值: `SHA256WITHRSA`) 
* `-S`，`--keyStorePassword <arg>`               要使用的密钥库密码. 每个主机必须是一个值或一个值(如果未指定则自动生成) 
* `--subjectAlternativeNames <arg>`             以逗号分隔的域列表，用作证书中的主题备用名称 
* `-T`，`--keyStoreType <arg>`                   要生成的密钥库的类型(默认值: `jks`) 


主机名模式: 

* 可以使用方括号以便轻松指定一系列主机名. 例: `[01-20]` 
* 可以使用括号来指定在给定主机上运行多个Orchsym Studio实例. 例: `(5)` 

示例: 

创建4组密钥库，信任库，Orchsym Studio.localhost的属性以及具有给定DN的客户端证书: 

---- 
bin/tls-toolkit.sh standalone -n 'localhost(4)' -C 'CN=username,OU=Orchsym Studio' 
---- 


创建密钥库，信任库，Orchsym Studio.4个子域中每个子域的10个Orchsym Studio主机名的属性: 

---- 
bin/tls-toolkit.sh standalone -n 'Orchsym Studio[01-10].subdomain[1-4].domain' 
---- 


创建2套密钥库，信任库，Orchsym Studio.4个子域中每个子域的10个Orchsym Studio主机名的属性以及具有给定DN的客户端证书: 

---- 
bin/tls-toolkit.sh standalone -n 'Orchsym Studio[01-10].subdomain[1-4].domain(2)' -C 'CN=username,OU=Orchsym Studio' 
---- 



==== 客户端/服务器 
客户端/服务器模式依赖于长时间运行的证书颁发机构(CA)来颁发证书. 当您没有将节点联机时，可以停止CA.. 


===== 服务器 

通过运行调用CA服务器 `./bin/tls-toolkit.sh server -h` 它会打印使用信息以及可以指定的选项说明. 

您可以使用以下命令行选项 `tls-toolkit` 在服务器模式下: 

* `-a`，`--keyAlgorithm <arg>`                   用于生成密钥的算法(默认值: `RSA`) 
* `--configJsonIn <arg>`                        从(默认为configJson的值)读取配置信息的地方暗示如果设置了useConfigJson(默认值: `configJson` 值) 
* `-d`，`--days <arg>`                           颁发证书的天数应该有效(默认值: `1095`) 
* `-D`，`--dn <arg>`                             用于CA证书的dn(默认值: `CN=YOUR_CA_HOSTNAME,OU=Orchsym Studio`) 
* `-f`，`--configJson <arg>`                     写配置信息的地方(默认: `config.json`) 
* `-F`，`--useConfigJson`                        指定从中读取所有配置的标志 `configJson` 便于自动使用(否则 `configJson` 只会被写入) 
* `-g`，`--differentKeyAndKeystorePasswords`     为密钥和密钥库使用不同的生成密码 
* `-h`，`--help`                                 打印帮助并退出 
* `-k`，`--keySize <arg>`                        生成密钥的位数(默认值: `2048`) 
* `-p`，`--PORT <arg>`                           证书颁发机构侦听的端口(默认值: `8443`) 
* `-s`，`--signingAlgorithm <arg>`               用于签名证书的算法(默认值: `SHA256WITHRSA`) 
* `-T`，`--keyStoreType <arg>`                   要生成的密钥库的类型(默认值: `jks`) 
* `-t`，`--token <arg>`                          用于阻止MITM的令牌(必需且必须与客户端使用的令牌相同) 

===== 客户 

端客户端可用于从CA请求新证书. 客户端实用程序生成密钥对和证书签名请求(CSR)，并将CSR发送到证书颁发机构. 通过运行调用客户端 `./bin/tls-toolkit.sh client -h` 它会打印使用信息以及可以指定的选项说明. 

您可以使用以下命令行选项 `tls-toolkit` 在客户端模式: 

* `-a`，`--keyAlgorithm <arg>`                   用于生成密钥的算法(默认值: `RSA`) 
* `-c`，`--certificateAuthorityHostname <arg>`   Orchsym Studio证书颁发机构的主机名(默认值: `localhost`) 
* `-C`，`--certificateDirectory <arg>`           写入CA证书的目录(默认值: `.`) 
* `--configJsonIn <arg>`                        从中暗示读取配置信息的地方 `useConfigJson` 如果设置(默认值: `configJson` 值) 
* `-D`，`--dn <arg>`                             用于客户端证书的DN(默认值: `CN=<localhost name>,OU=Orchsym Studio`)(这是由工具自动填充) 
* `-f`，`--configJson <arg>`                     写配置信息的地方(默认: `config.json`) 
* `-F`，`--useConfigJson`                        指定从中读取所有配置的标志 `configJson` 便于自动使用(否则 `configJson` 只会被写入) 
* `-g`，`--differentKeyAndKeystorePasswords`     为密钥和密钥库使用不同的生成密码 
* `-h`，`--help`                                 打印帮助并退出 
* `-k`，`--keySize <arg>`                        生成密钥的位数(默认值: `2048`) 
* `-p`，`--PORT <arg>`                           用于与证书颁发机构通信的端口(默认值: `8443`) 
* `--subjectAlternativeNames <arg>`             以逗号分隔的域列表，用作证书中的主题备用名称 
* `-T`，`--keyStoreType <arg>`                   要生成的密钥库的类型(默认值: `jks`) 
* `-t`，`--token <arg>`                          用于阻止MITM的令牌(必需且必须与CA使用的令牌相同) 

运行客户端后，您将拥有CA的证书，密钥库，信任库和 `config.json` 有关他们的信息以及他们的密码. 

对于可以轻松导入浏览器的客户端证书，请指定: `-T PKCS12` 

[[user_authentication]] 
== 用户身份验证 

Orchsym Studio支持通过客户端证书，用户名/密码，Apache Knox或通过用户身份验证link:http://openid.net/connect[OpenId Connect^]. 

用户名/密码验证由"登录身份提供商”执行.登录身份提供程序是一种可插入的机制，用于
通过用户名/密码对用户进行 身份验证. 要使用哪个登录标识提供程序 _Orchsym Studio.properties_ 文件. 
目前，Orchsym Studio为LDAP和Kerberos提供了用户名/密码和登录身份提供商选项. 

该 `Orchsym Studio.login.identity.provider.configuration.file` property指定登录标识提供程序的配置文件. 
该 `Orchsym Studio.security.user.login.identity.provider` property表示应
使用哪个配置的登录标识提供程序 . 默认情况下，未配置此属性意味着必须明确启用用户名/密码. 

在OpenId Connect身份验证期间，Orchsym Studio会在返回Orchsym Studio之前将用户重定向到使用提供商登录.然后，Orchsym Studio将 
致电提供商以获取用户身份. 

在Apache Knox身份验证期间，Orchsym Studio将重定向用户使用Apache Knox登录，然后再返回Orchsym Studio.Orchsym Studio将
在身份验证期间验证Apache Knox 令牌. 

NOTE: Orchsym Studio只能在给定时间配置为用户名/密码，OpenId Connect或Apache Knox.它不支持同时运行
这些中的每一个 . 如果没有配置这些，则Orchsym Studio将要求客户端证书通过HTTPS对用户进行身份验证. 

除非配置为使用LDAP或Kerberos登录身份提供程序，否则无法匿名访问受保护的Orchsym Studio实例，而必须将其配置为明确允许匿名访问. 默认的FileAuthorizer目前无法进行匿名访问(请参阅<<authorizer-configuration>>)，但这是未来的努力(link:https://issues.apache.org/jira/browse/Orchsym Studio-2730[Orchsym Studio-2730^]). 

NOTE: Orchsym Studio不通过HTTP执行用户身份验证. 使用HTTP，所有用户都将被授予所有角色. 

[[ldap_login_identity_provider]] 
=== 轻量级目录访问协议(LDAP) 

以下是配置登录身份提供程序的示例和说明，该登录身份提供程序与Directory Server集成以对用户进行身份验证. 


---- 
<provider> 
    <identifier>ldap-provider</identifier> 
    <class>org.apache.Orchsym Studio.ldap.LdapProvider</class> 
    <property name="Authentication Strategy">START_TLS</property> 

    <property name="Manager DN"></property> 
    <property name="Manager Password"></property> 

    <property name="TLS - Keystore"></property> 
    <property name="TLS - Keystore Password"></property> 
    <property name="TLS - Keystore Type"></property> 
    <property name="TLS - Truststore"></property> 
    <property name="TLS - Truststore Password"></property> 
    <property name="TLS - Truststore Type"></property> 
    <property name="TLS - Client Auth"></property> 
    <property name="TLS - Protocol"></property> 
    <property name="TLS - Shutdown Gracefully"></property> 

    <property name="Referral Strategy">FOLLOW</property> 
    <property name="Connect Timeout">10 secs</property> 
    <property name="Read Timeout">10 secs</property> 

    <property name="Url"></property> 
    <property name="User Search Base"></property> 
    <property name="User Search Filter"></property> 

    <property name="Identity Strategy">USE_DN</property> 
    <property name="Authentication Expiration">12 hours</property> 
</provider> 
---- 


使用此配置，可以通过引用此提供程序来启用用户名/密码身份验证 _Orchsym Studio.properties_. 


---- 
Orchsym Studio.security.user.login.identity.provider=ldap-provider 
---- 


[options="header,footer"] 
|================================================================================================================================================== 
| Property Name | 描述 
|`Authentication Strategy` | 如何验证与LDAP服务器的连接. 可能的值为ANONYMOUS，SIMPLE，LDAPS或START_TLS. 
|`Manager DN` | 用于绑定到LDAP服务器以搜索用户的管理器的DN. 
|`Manager Password` | 用于绑定到LDAP服务器以搜索用户的管理器的密码. 
|`TLS - Keystore` | 使用LDAPS或START_TLS连接到LDAP时使用的密钥库的路径. 
|`TLS - Keystore Password` | 使用LDAPS或START_TLS连接到LDAP时使用的密钥库的密码. 
|`TLS - Keystore Type` | 使用LDAPS或START_TLS连接到LDAP时使用的密钥库的类型(i.Ë. JKS或PKCS12). 
|`TLS - Truststore` | 使用LDAPS或START_TLS连接到LDAP时使用的Truststore的路径. 
|`TLS - Truststore Password` | 使用LDAPS或START_TLS连接到LDAP时使用的Truststore的密码. 
|`TLS - Truststore Type` | 使用LDAPS或START_TLS连接到LDAP时使用的Truststore的类型(i.Ë. JKS或PKCS12). 
|`TLS - Client Auth` | 使用LDAPS或START_TLS连接到LDAP时的客户端身份验证策略. 可能的值是REQUIRED，WANT，NONE. 
|`TLS - Protocol` | 使用LDAPS或START_TLS连接到LDAP时使用的协议. (一世.Ë. TLS，TLSv1.1，TLSv1.2等). 
|`TLS - Shutdown Gracefully` | 指定在关闭目标上下文之前是否应正常关闭TLS. 默认为false. 
|`Referral Strategy` | 处理推荐的策略. 可能的值为FOLLOW，IGNORE，THROW. 
|`Connect Timeout` | 连接超时的持续时间. (一世.Ë. 10秒). 
|`Read Timeout` | 读取超时的持续时间. (一世.Ë. 10秒). 
|`Url` | 以空格分隔的LDAP服务器的URL列表(i.Ë. LDAP:// <主机名>:<端口>). 
|`User Search Base` | 用于搜索用户的基本DN(i.Ë. CN =用户，DC =实施例，DC = COM). 
|`User Search Filter` | 根据"用户搜索库”过滤搜索用户. (一世.Ë. sAMAccountName赋= {0}). 用户指定的名称将插入"{0}”. 
|`Identity Strategy` | 识别用户的策略. 可能的值是USE_DN and USE_用户名.缺少此属性的默认功能是USE_DN，以保持向后 
兼容性. 使用_DN will use the full DN of the user entry if possible. USE_USERNAME将使用用户登录的用户名. 
|`Authentication Expiration` | 用户身份验证有效期的持续时间. 如果用户从未注销，则需要在此持续时间之后重新登录. 
|================================================================================================================================================== 

[[kerberos_login_identity_provider]] 
=== Kerberos 

下面是配置登录身份提供程序的示例和说明，该登录身份提供程序与Kerberos密钥分发中心(KDC)集成以对用户进行身份验证. 


---- 
<provider> 
    <identifier>kerberos-provider</identifier> 
    <class>org.apache.Orchsym Studio.kerberos.KerberosProvider</class> 
    <property name="Default Realm">Orchsym Studio.APACHE.ORG</property> 
    <property name="Kerberos Config File">/etc/krb5.conf</property> 
    <property name="Authentication Expiration">12 hours</property> 
</provider> 
---- 


使用此配置，可以通过引用此提供程序来启用用户名/密码身份验证 _Orchsym Studio.properties_. 


---- 
Orchsym Studio.security.user.login.identity.provider=kerberos-provider 
---- 


[options="header,footer"] 
|================================================================================================================================================== 
| Property Name | 描述 
|`Default Realm` | 当用户输入不完整的用户主体时提供的默认域(i.Ë. Orchsym Studio.APACHE.ORG). 
|`Kerberos Config File` | Kerberos客户端配置文件的绝对路径. 
|`Authentication Expiration`| 用户身份验证有效期的持续时间. 如果用户从未注销，则需要在此持续时间之后重新登录. 
|================================================================================================================================================== 

另请参阅<<kerberos_service>>以允许通过客户端Kerberos票证进行单点登录访问. 

[[openid_connect]] 
=== OpenId Connect 

要通过OpenId Connect启用身份验证，必须在Orchsym Studio中配置以下属性.性能. 

[options="header,footer"] 
|================================================================================================================================================== 
| Property Name | 描述 
|`Orchsym Studio.security.user.oidc.discovery.url` | 所需OpenId Connect Provider的发现URL(link:http://openid.net/specs/openid-connect-discovery-1_0.html[http://openid.net/specs/openid-connect-discovery-1_0.html^]). 
|`Orchsym Studio.security.user.oidc.connect.timeout` | 与OpenId Connect Provider通信时连接超时. 
|`Orchsym Studio.security.user.oidc.read.timeout` | 与OpenId Connect Provider通信时读取超时. 
|`Orchsym Studio.security.user.oidc.client.id` | 注册OpenId Connect Provider后，Orchsym Studio的客户端ID. 
|`Orchsym Studio.security.user.oidc.client.secret` | 在向OpenId Connect Provider注册后，Orchsym Studio的客户机密. 
|`Orchsym Studio.security.user.oidc.preferred.jwsalgorithm` | 用于验证身份令牌的首选算法. 如果此值为空，则默认为"RS256”' 
根据规范，OpenId Connect Provider 需要支持 . 如果此值为"HS256”，"HS384”或"HS512”，Orchsym Studio将尝试使用指定的客户端密钥验证HMAC保护的令牌. 
如果此值为"none”，Orchsym Studio将尝试验证不安全/普通令牌.此算法的其他值将尝试解析为RSA或EC算法，以与
通过发现URL中找到的元数据中的jwks_uri提供的JSON Web Key(JWK)结合使用 . 
|================================================================================================================================================== 

[[apache_knox]] 
=== Apache Knox 

要通过Apache Knox启用身份验证，必须在Orchsym Studio中配置以下属性.性能. 

[options="header,footer"] 
|================================================================================================================================================== 
| Property Name | 描述 
|`Orchsym Studio.security.user.knox.url` | Apache Knox登录页面的URL. 
|`Orchsym Studio.security.user.knox.publicKey` | Apache Knox公钥的路径，用于验证HTTP Cookie中的身份验证令牌的签名. 
|`Orchsym Studio.security.user.knox.cookieName` | 成功登录后Apache Knox将生成的HTTP Cookie的名称. 
|`Orchsym Studio.security.user.knox.audiences` | 可选的. 逗号分开列出的允许的受众群体.如果设置，则令牌中的受众必须出现在 
此列表中. 可以在Knox中配置令牌中填充的受众. 
|================================================================================================================================================== 

[[multi-tenant-authorization]] 
== 多租户授权 

将Orchsym Studio配置为安全运行并使用身份验证机制后，您必须配置谁有权访问系统及其访问级别. 
您可以使用"多租户授权”执行此操作.多租户授权允许多组用户(租户)命令，控制和观察
数据流的不同 部分，具有不同级别的授权.当经过身份验证的用户尝试查看或修改Orchsym Studio资源时，系统会检查
用户是否 具有执行该操作的权限. 这些权限由可以在系统范围内应用于单个组件的策略定义. 

[[authorizer-configuration]] 
=== 授权人配置 

'授权人' 通过在启动时创建初步授权，授予用户管理用户和策略的权限. 

授权者使用'Orchsym Studio中的两个属性进行配置.性能' 文件: 

* 该 `Orchsym Studio.authorizer.configuration.file` property指定定义授权程序的配置文件.  默认情况下，'授权人.XML' 选择位于根安装conf目录中的文件. 
* 该 `Orchsym Studio.security.user.authorizer` property指示"授权者”中配置的授权者.XML' 要使用的文件. 

[[authorizers-setup]] 
=== 授权人.xml设置 

'授权者.XML' file用于定义和配置可用的授权程序.  默认授权程序是StandardManagedAuthorizer.  托管授权程序由UserGroupProvider 
和AccessPolicyProvider组成.  将加载用户，组和访问策略，并可通过这些提供程序进行配置.  托管授权人将根据
提供的用户，组和访问策略做出所有访问决策 . 

在启动期间，检查以确保没有两个具有相同身份/名称的用户/组. 无论配置的实现如何，都会执行此检查. 这是必要的，因为这是在访问决策期间识别和授权用户/组的方式. 

默认的UserGroupProvider是FileUserGroupProvider，但是，您可以将其他UserGroupProviders开发为扩展.  FileUserGroupProvider具有以下属性: 

* 用户文件 - FileUserGroupProvider存储用户和组的文件.  默认情况下，'用户.XML' 在'conf' 目录被选中. 
* 旧版授权用户文件 - 现有授权用户的完整路径.xml将自动用于将用户和组加载到用户文件中. 
* 初始用户身份 - 用于为用户文件设定种子的用户和系统的标识.每个属性的名称必须是唯一的，例如:"初始用户身份A”，"初始用户身份B”，"初始用户身份C”或"初始用户身份1”，"初始用户身份2”，"初始用户身份3" 

UserGroupProvider的另一个选项是LdapUserGroupProvider. 默认情况下，此选项已注释掉，但可以配置为代替FileUserGroupProvider. 这将从目录服务器同步用户和组，并以只读形式在Orchsym Studio UI中显示它们. LdapUserGroupProvider具有以下属性: 

* 认证策略 - 如何验证与LDAP服务器的连接. 可能的值为ANONYMOUS，SIMPLE，LDAPS或START_TLS 
* 经理DN - 用于绑定到LDAP服务器以搜索用户的管理器的DN. 
* 经理密码 - 用于绑定到LDAP服务器以搜索用户的管理器的密码. 
* TLS - 密钥库 - 使用LDAPS或START_TLS连接到LDAP时使用的密钥库的路径. 
* TLS - 密钥库密码 - 使用LDAPS或START_TLS连接到LDAP时使用的密钥库的密码. 
* TLS - 密钥库类型 - 使用LDAPS或START_TLS连接到LDAP时使用的密钥库的类型(i.Ë. JKS或PKCS12). 
* TLS - 信任 - 使用LDAPS或START_TLS连接到LDAP时使用的Truststore的路径. 
* TLS - 信任库密码 - 使用LDAPS或START_TLS连接到LDAP时使用的Truststore的密码. 
* TLS - 信任库类型 - 使用LDAPS或START_TLS连接到LDAP时使用的Truststore的类型(i.Ë. JKS或PKCS12). 
* TLS - 客户身份验证 - 使用LDAPS或START_TLS连接到LDAP时的客户端身份验证策略. 可能的值是REQUIRED，WANT，NONE. 
* TLS - 协议 - 使用LDAPS或START_TLS连接到LDAP时使用的协议. (一世.Ë. TLS，TLSv1.1，TLSv1.2等). 
* TLS - 优雅地关机 - 指定在关闭目标上下文之前是否应正常关闭TLS. 默认为false. 
* 推荐策略 - 处理推荐的策略. 可能的值为FOLLOW，IGNORE，THROW. 
* 连接超时 - 连接超时的持续时间. (一世.Ë. 10秒). 
* 读取超时 - 读取超时的持续时间. (一世.Ë. 10秒). 
* 网址 - 以空格分隔的LDAP服务器的URL列表(i.Ë. LDAP:// <主机名>:<端口>). 
* 页面大小 - 检索用户和组时设置页面大小. 如果未指定，则不执行分页. 
* 同步间隔 - 同步用户和组之间的持续时间. (一世.Ë. 30分钟). 最小允许值为10秒. 
* 用户搜索库 - 用于搜索用户的基本DN(i.Ë. OU =用户，O = Orchsym Studio). 搜索用户时需要. 
* 用户对象类 - 用于识别用户的对象类(i.Ë. 人). 搜索用户时需要. 
* 用户搜索范围 - 搜索用户的搜索范围(ONE_LEVEL，OBJECT或SUBTREE). 搜索用户时需要. 
* 用户搜索过滤器 - 根据"用户搜索库”过滤搜索用户' (一世.Ë. (memberof = cn = team1，ou = groups，o = Orchsym Studio)). 可选的. 
* 用户身份属性 - 用于提取用户身份的属性(i.Ë. CN). 可选的. 如果未设置，则使用整个DN. 
* 用户组名称属性 - 用于定义组成员身份的属性(i.Ë. 成员). 可选的. 如果未设置，则不会通过用户计算组成员身份. 将依赖于通过"组成员属性”定义的组成员身份' 如果设置. 此属性的值是用户ldap条目中将属性与组关联的属性的名称. 例如，该用户属性的值可以是dn或组名. 在"用户组名称属性”中配置了预期的值 - 引用的组属性'. 
* 用户组名称属性 - 引用的组属性 - 如果为空，则为"用户组名称属性”中定义的属性值' 预计将成为该组的完整dn. 如果不为空，则此属性将定义组ldap条目的属性，即"用户组名称属性”中定义的属性值' 引用(i.Ë. 名称). 使用此属性需要"组搜索库”' 也配置了. 
* 群组搜索库 - 用于搜索组的基本DN(i.Ë. OU =基团，O = Orchsym Studio). 搜索组时需要. 
* 组对象类 - 用于识别组的对象类(i.Ë. 是groupofNames). 搜索组时必需. 
* 组搜索范围 - 搜索组的搜索范围(ONE_LEVEL，OBJECT或SUBTREE). 搜索组时必需. 
* 组搜索过滤器 - 根据"群组搜索库”过滤搜索群组. 可选的. 
* 组名属性 - 用于提取组名的属性(i.Ë. CN). 可选的. 如果未设置，则使用整个DN. 
* 组成员属性 - 用于定义组成员身份的属性(i.Ë. 会员). 可选的. 如果未设置，则不会通过组计算组成员身份. 将依赖于通过"用户组名称属性”定义的组成员身份' 如果设置. 此属性的值是组ldap条目中的属性的名称，该属性将它们与用户相关联. 例如，该组属性的值可以是dn或memberUid. 在"组成员属性”中配置了预期的值 - 引用的用户属性'. (一世.Ë. member:cn =用户1，ou =用户，o = Orchsym Studio vs. memberUid:user1) 
* 组成员属性 - 引用的用户属性 - 如果为空，则为"组成员属性”中定义的属性值' 预计将是用户的完整dn. 如果不为空，则此属性将定义用户ldap条目的属性，即"组成员属性”中定义的属性值' 引用(i.Ë. UID). 使用此属性需要"用户搜索库”' 也配置了. (一世.Ë. member:cn =用户1，ou =用户，o = Orchsym Studio vs.memberUid:user1) 

UserGroupProvider的另一个选项是复合实现. 这意味着可以配置和组合多个源/实现. 例如，管理员可以配置要从文件和目录服务器加载的用户/组. 有两个复合实现，一个支持多个UserGroupProviders，一个支持多个UserGroupProviders和一个可配置的UserGroupProvider. 

CompositeUserGroupProvider将支持从多个源检索用户和组. CompositeUserGroupProvider具有以下属性: 

* 用户组提供商 - 要加载的用户组提供程序的标识符.每个属性的名称必须是唯一的，例如:"用户组提供商A”，"用户组提供商B”，"用户组提供商C”或"用户组提供商1”，"用户组提供商2”，"用户组” Provider 3" 

CompositeConfigurableUserGroupProvider将支持从多个源检索用户和组. 此外，还需要一个可配置的用户组提供程序. 可配置用户组提供程序中的用户是可配置的，但是用户从其中一个用户组提供程序加载 [unique key] 不会是. CompositeConfigurableUserGroupProvider具有以下属性: 

* 可配置的用户组提供商 - 可配置的用户组提供程序. 
* 用户组提供商 - 要加载的用户组提供程序的标识符.每个属性的名称必须是唯一的，例如:"用户组提供商A”，"用户组提供商B”，"用户组提供商C”或"用户组提供商1”，"用户组提供商2”，"用户组”提供者3" 

默认的AccessPolicyProvider是FileAccessPolicyProvider，但是，您可以将其他AccessPolicyProvider开发为扩展名.  FileAccessPolicyProvider具有以下属性: 

* 用户组提供商 - 上面定义的用户组提供程序的标识符，用于访问用于托管访问策略的用户和组. 
* 授权文件 - FileAccessPolicyProvider将存储策略的文件. 
* 初始管理员身份 - 初始管理员用户的身份，该用户将被授予对UI的访问权限，并且能够创建其他用户，组和策略. 使用证书或LDAP或Kerberos主体时，此属性的值可以是DN. 仅在未定义其他策略时才使用此属性. 如果指定了此属性，则无法指定旧版授权用户文件. 
* 旧版授权用户文件 - 现有授权用户的完整路径.xml将自动转换为新的授权模型. 如果指定了此属性，则无法指定初始管理员标识，并且仅在未定义其他用户，组和策略时才使用此属性. 
* 节点标识 - Orchsym Studio群集节点的标识. 在群集时，应定义每个节点的属性，以便每个节点都知道每个其他节点. 如果不是群集，则可以忽略这些属性.每个属性的名称必须是唯一的，例如对于三节点群集:"节点标识A”，"节点标识B”，"节点标识C”或"节点标识1”，"节点标识2”，"节点标识” 3" 

在初始管理员标识中配置的标识，节点标识属性或在旧版授权用户文件中发现的标识必须在配置的用户组提供程序中可用. 

默认授权程序是StandardManagedAuthorizer，但是，您可以将其他授权程序开发为扩展程序.  StandardManagedAuthorizer具有以下属性: 

* 访问策略提供商 - 上面定义的访问策略提供程序的标识符. 

FileAuthorizer已被上述更精细的StandardManagedAuthorizer方法所取代. 但是，由于向后兼容性原因，它仍然可用.该 
FileAuthorizer具有以下属性. 

* 授权文件 - FileAuthorizer存储策略的文件.  默认情况下，'授权.XML' 在'conf' 目录被选中. 
* 用户文件 - FileAuthorizer存储用户和组的文件.  默认情况下，'用户.XML' 在'conf' 目录被选中. 
* 初始管理员身份 - 被授予对UI的访问权限并且能够创建其他用户，组和策略的初始管理员用户的身份. 仅在未定义其他用户，组和策略时使用此属性. 
* 旧版授权用户文件 - 现有授权用户的完整路径.自动转换为多租户授权模型的xml.  仅在未定义其他用户，组和策略时使用此属性. 
* 节点标识 - Orchsym Studio群集节点的标识. 在群集时，应定义每个节点的属性，以便每个节点都知道每个其他节点. 如果不是群集，则可以忽略这些属性. 

[[initial-admin-identity]] 
==== 初始管理员标识(新Orchsym Studio实例) 

如果您是第一次设置安全的Orchsym Studio实例，则必须在"授权人”中手动指定"初始管理员标识”.XML' 文件.  此初始管理员用户被授予对UI的访问权限，并且可以创建其他用户，组和策略. 此属性的值可以是DN(使用证书或LDAP时)或Kerberos主体.  如果您是Orchsym Studio管理员，请将自己添加为"初始管理员身份”. 

以下是使用John Smith名称的LDAP条目示例: 


---- 
<authorizers> 
    <userGroupProvider> 
        <identifier>file-user-group-provider</identifier> 
        <class>org.apache.Orchsym Studio.authorization.FileUserGroupProvider</class> 
        <property name="Users File">./conf/users.xml</property> 
        <property name="Legacy Authorized Users File"></property> 

        <property name="Initial User Identity 1">cn=John Smith,ou=people,dc=example,dc=com</property> 
    </userGroupProvider> 
    <accessPolicyProvider> 
        <identifier>file-access-policy-provider</identifier> 
        <class>org.apache.Orchsym Studio.authorization.FileAccessPolicyProvider</class> 
        <property name="User Group Provider">file-user-group-provider</property> 
        <property name="Authorizations File">./conf/authorizations.xml</property> 
        <property name="Initial Admin Identity">cn=John Smith,ou=people,dc=example,dc=com</property> 
        <property name="Legacy Authorized Users File"></property> 

        <property name="Node Identity 1"></property> 
    </accessPolicyProvider> 
    <authorizer> 
        <identifier>managed-authorizer</identifier> 
        <class>org.apache.Orchsym Studio.authorization.StandardManagedAuthorizer</class> 
        <property name="Access Policy Provider">file-access-policy-provider</property> 
    </authorizer> 
</authorizers> 
---- 


以下是使用John Smith和realm这个名称的Kerberos条目示例 `Orchsym Studio.APACHE.ORG`: 


---- 
<authorizers> 
    <userGroupProvider> 
        <identifier>file-user-group-provider</identifier> 
        <class>org.apache.Orchsym Studio.authorization.FileUserGroupProvider</class> 
        <property name="Users File">./conf/users.xml</property> 
        <property name="Legacy Authorized Users File"></property> 

        <property name="Initial User Identity 1">johnsmith@Orchsym Studio.APACHE.ORG</property> 
    </userGroupProvider> 
    <accessPolicyProvider> 
        <identifier>file-access-policy-provider</identifier> 
        <class>org.apache.Orchsym Studio.authorization.FileAccessPolicyProvider</class> 
        <property name="User Group Provider">file-user-group-provider</property> 
        <property name="Authorizations File">./conf/authorizations.xml</property> 
        <property name="Initial Admin Identity">johnsmith@Orchsym Studio.APACHE.ORG</property> 
        <property name="Legacy Authorized Users File"></property> 

        <property name="Node Identity 1"></property> 
    </accessPolicyProvider> 
    <authorizer> 
        <identifier>managed-authorizer</identifier> 
        <class>org.apache.Orchsym Studio.authorization.StandardManagedAuthorizer</class> 
        <property name="Access Policy Provider">file-access-policy-provider</property> 
    </authorizer> 
</authorizers> 
---- 


编辑并保存"授权人”后.XML' 文件，重启Orchsym Studio.  "初始管理员身份”用户和管理策略将添加到"用户”.XML' 和'授权.XML' 重启期间的文件. 一旦Orchsym Studio启动，"初始管理员身份”用户就可以访问UI并开始管理用户，组和策略. 

NOTE: 对于全新的安全流，提供"初始管理员身份”使用户可以访问用户界面并管理用户，组和策略.  但是，如果该用户想要开始修改流，他们需要为根进程组授予自己的策略. 系统无法自动执行此操作，因为在新流程中，根进程组的UUID在流程之前不是永久性的.XML.生成gz.  如果Orchsym Studio实例是现有流的升级.XML.gz或1.x实例从不安全到安全，然后"初始管理员身份”用户自动获得修改流的权限. 

以下是从LDAP加载用户和组的示例. 组成员资格将通过每个组的成员属性来驱动. 授权仍将使用基于文件的访问策略: 


---- 
dn: cn=User 1,ou=users,o=Orchsym Studio 
objectClass: organizationalPerson 
objectClass: person 
objectClass: inetOrgPerson 
objectClass: top 
cn: User 1 
sn: User1 
uid: user1 

dn: cn=User 2,ou=users,o=Orchsym Studio 
objectClass: organizationalPerson 
objectClass: person 
objectClass: inetOrgPerson 
objectClass: top 
cn: User 2 
sn: User2 
uid: user2 

dn: cn=admins,ou=groups,o=Orchsym Studio 
objectClass: groupOfNames 
objectClass: top 
cn: admins 
member: cn=User 1,ou=users,o=Orchsym Studio 
member: cn=User 2,ou=users,o=Orchsym Studio 

<authorizers> 
    <userGroupProvider> 
        <identifier>ldap-user-group-provider</identifier> 
        <class>org.apache.Orchsym Studio.ldap.tenants.LdapUserGroupProvider</class> 
        <property name="Authentication Strategy">ANONYMOUS</property> 

        <property name="Manager DN"></property> 
        <property name="Manager Password"></property> 

        <property name="TLS - Keystore"></property> 
        <property name="TLS - Keystore Password"></property> 
        <property name="TLS - Keystore Type"></property> 
        <property name="TLS - Truststore"></property> 
        <property name="TLS - Truststore Password"></property> 
        <property name="TLS - Truststore Type"></property> 
        <property name="TLS - Client Auth"></property> 
        <property name="TLS - Protocol"></property> 
        <property name="TLS - Shutdown Gracefully"></property> 

        <property name="Referral Strategy">FOLLOW</property> 
        <property name="Connect Timeout">10 secs</property> 
        <property name="Read Timeout">10 secs</property> 

        <property name="Url">ldap://localhost:10389</property> 
        <property name="Page Size"></property> 
        <property name="Sync Interval">30 mins</property> 

        <property name="User Search Base">ou=users,o=Orchsym Studio</property> 
        <property name="User Object Class">person</property> 
        <property name="User Search Scope">ONE_LEVEL</property> 
        <property name="User Search Filter"></property> 
        <property name="User Identity Attribute">cn</property> 
        <property name="User Group Name Attribute"></property> 
        <property name="User Group Name Attribute - Referenced Group Attribute"></property> 

        <property name="Group Search Base">ou=groups,o=Orchsym Studio</property> 
        <property name="Group Object Class">groupOfNames</property> 
        <property name="Group Search Scope">ONE_LEVEL</property> 
        <property name="Group Search Filter"></property> 
        <property name="Group Name Attribute">cn</property> 
        <property name="Group Member Attribute">member</property> 
        <property name="Group Member Attribute - Referenced User Attribute"></property> 
    </userGroupProvider> 
    <accessPolicyProvider> 
        <identifier>file-access-policy-provider</identifier> 
        <class>org.apache.Orchsym Studio.authorization.FileAccessPolicyProvider</class> 
        <property name="User Group Provider">ldap-user-group-provider</property> 
        <property name="Authorizations File">./conf/authorizations.xml</property> 
        <property name="Initial Admin Identity">John Smith</property> 
        <property name="Legacy Authorized Users File"></property> 

        <property name="Node Identity 1"></property> 
    </accessPolicyProvider> 
    <authorizer> 
        <identifier>managed-authorizer</identifier> 
        <class>org.apache.Orchsym Studio.authorization.StandardManagedAuthorizer</class> 
        <property name="Access Policy Provider">file-access-policy-provider</property> 
    </authorizer> 
</authorizers> 
---- 


'初始管理员身份' 值将根据"用户身份属性”从John Smith的条目中加载cn' 值. 

以下是从LDAP加载用户和组的示例. 组成员资格将通过每个组的成员属性来驱动. 授权仍将使用基于文件的访问策略: 


---- 
dn: uid=User 1,ou=Users,dc=local 
objectClass: inetOrgPerson 
objectClass: posixAccount 
objectClass: shadowAccount 
uid: user1 
cn: User 1 

dn: uid=User 2,ou=Users,dc=local 
objectClass: inetOrgPerson 
objectClass: posixAccount 
objectClass: shadowAccount 
uid: user2 
cn: User 2 

dn: cn=Managers,ou=Groups,dc=local 
objectClass: posixGroup 
cn: Managers 
memberUid: user1 
memberUid: user2 

<authorizers> 
    <userGroupProvider> 
        <identifier>ldap-user-group-provider</identifier> 
        <class>org.apache.Orchsym Studio.ldap.tenants.LdapUserGroupProvider</class> 
        <property name="Authentication Strategy">ANONYMOUS</property> 

        <property name="Manager DN"></property> 
        <property name="Manager Password"></property> 

        <property name="TLS - Keystore"></property> 
        <property name="TLS - Keystore Password"></property> 
        <property name="TLS - Keystore Type"></property> 
        <property name="TLS - Truststore"></property> 
        <property name="TLS - Truststore Password"></property> 
        <property name="TLS - Truststore Type"></property> 
        <property name="TLS - Client Auth"></property> 
        <property name="TLS - Protocol"></property> 
        <property name="TLS - Shutdown Gracefully"></property> 

        <property name="Referral Strategy">FOLLOW</property> 
        <property name="Connect Timeout">10 secs</property> 
        <property name="Read Timeout">10 secs</property> 

        <property name="Url">ldap://localhost:10389</property> 
        <property name="Page Size"></property> 
        <property name="Sync Interval">30 mins</property> 

        <property name="User Search Base">ou=Groups,dc=local</property> 
        <property name="User Object Class">posixAccount</property> 
        <property name="User Search Scope">ONE_LEVEL</property> 
        <property name="User Search Filter"></property> 
        <property name="User Identity Attribute">cn</property> 
        <property name="User Group Name Attribute"></property> 
        <property name="User Group Name Attribute - Referenced Group Attribute"></property> 

        <property name="Group Search Base">ou=Groups,dc=local</property> 
        <property name="Group Object Class">posixGroup</property> 
        <property name="Group Search Scope">ONE_LEVEL</property> 
        <property name="Group Search Filter"></property> 
        <property name="Group Name Attribute">cn</property> 
        <property name="Group Member Attribute">memberUid</property> 
        <property name="Group Member Attribute - Referenced User Attribute">uid</property> 
    </userGroupProvider> 
    <accessPolicyProvider> 
        <identifier>file-access-policy-provider</identifier> 
        <class>org.apache.Orchsym Studio.authorization.FileAccessPolicyProvider</class> 
        <property name="User Group Provider">ldap-user-group-provider</property> 
        <property name="Authorizations File">./conf/authorizations.xml</property> 
        <property name="Initial Admin Identity">John Smith</property> 
        <property name="Legacy Authorized Users File"></property> 

        <property name="Node Identity 1"></property> 
    </accessPolicyProvider> 
    <authorizer> 
        <identifier>managed-authorizer</identifier> 
        <class>org.apache.Orchsym Studio.authorization.StandardManagedAuthorizer</class> 
        <property name="Access Policy Provider">file-access-policy-provider</property> 
    </authorizer> 
</authorizers> 
---- 


以下是从LDAP和本地文件加载用户和组的示例复合实现. 组成员资格将通过每个组的成员属性来驱动. 来自LDAP的用户将是只读的，而从文件加载的用户可以在UI中进行配置. 


---- 
<authorizers> 
    <userGroupProvider> 
        <identifier>file-user-group-provider</identifier> 
        <class>org.apache.Orchsym Studio.authorization.FileUserGroupProvider</class> 
        <property name="Users File">./conf/users.xml</property> 
        <property name="Legacy Authorized Users File"></property> 

        <property name="Initial User Identity 1">cn=Orchsym Studio-node1,ou=servers,dc=example,dc=com</property> 
        <property name="Initial User Identity 2">cn=Orchsym Studio-node2,ou=servers,dc=example,dc=com</property> 
    </userGroupProvider> 
    <userGroupProvider> 
        <identifier>ldap-user-group-provider</identifier> 
        <class>org.apache.Orchsym Studio.ldap.tenants.LdapUserGroupProvider</class> 
        <property name="Authentication Strategy">ANONYMOUS</property> 

        <property name="Manager DN"></property> 
        <property name="Manager Password"></property> 

        <property name="TLS - Keystore"></property> 
        <property name="TLS - Keystore Password"></property> 
        <property name="TLS - Keystore Type"></property> 
        <property name="TLS - Truststore"></property> 
        <property name="TLS - Truststore Password"></property> 
        <property name="TLS - Truststore Type"></property> 
        <property name="TLS - Client Auth"></property> 
        <property name="TLS - Protocol"></property> 
        <property name="TLS - Shutdown Gracefully"></property> 

        <property name="Referral Strategy">FOLLOW</property> 
        <property name="Connect Timeout">10 secs</property> 
        <property name="Read Timeout">10 secs</property> 

        <property name="Url">ldap://localhost:10389</property> 
        <property name="Page Size"></property> 
        <property name="Sync Interval">30 mins</property> 

        <property name="User Search Base">ou=users,o=Orchsym Studio</property> 
        <property name="User Object Class">person</property> 
        <property name="User Search Scope">ONE_LEVEL</property> 
        <property name="User Search Filter"></property> 
        <property name="User Identity Attribute">cn</property> 
        <property name="User Group Name Attribute"></property> 
        <property name="User Group Name Attribute - Referenced Group Attribute"></property> 

        <property name="Group Search Base">ou=groups,o=Orchsym Studio</property> 
        <property name="Group Object Class">groupOfNames</property> 
        <property name="Group Search Scope">ONE_LEVEL</property> 
        <property name="Group Search Filter"></property> 
        <property name="Group Name Attribute">cn</property> 
        <property name="Group Member Attribute">member</property> 
        <property name="Group Member Attribute - Referenced User Attribute"></property> 
    </userGroupProvider> 
    <userGroupProvider> 
        <identifier>composite-user-group-provider</identifier> 
        <class>org.apache.Orchsym Studio.authorization.CompositeConfigurableUserGroupProvider</class> 
        <property name="Configurable User Group Provider">file-user-group-provider</property> 
        <property name="User Group Provider 1">ldap-user-group-provider</property> 
    </userGroupProvider> 
    <accessPolicyProvider> 
        <identifier>file-access-policy-provider</identifier> 
        <class>org.apache.Orchsym Studio.authorization.FileAccessPolicyProvider</class> 
        <property name="User Group Provider">composite-user-group-provider</property> 
        <property name="Authorizations File">./conf/authorizations.xml</property> 
        <property name="Initial Admin Identity">John Smith</property> 
        <property name="Legacy Authorized Users File"></property> 

        <property name="Node Identity 1">cn=Orchsym Studio-node1,ou=servers,dc=example,dc=com</property> 
        <property name="Node Identity 2">cn=Orchsym Studio-node2,ou=servers,dc=example,dc=com</property> 
    </accessPolicyProvider> 
    <authorizer> 
        <identifier>managed-authorizer</identifier> 
        <class>org.apache.Orchsym Studio.authorization.StandardManagedAuthorizer</class> 
        <property name="Access Policy Provider">file-access-policy-provider</property> 
    </authorizer> 
</authorizers> 
---- 


在此示例中，用户和组是从LDAP加载的，但服务器是在本地文件中管理的. '初始管理员身份' 值来自基于"用户身份属性”的LDAP条目中的属性. '节点标识' 使用"初始用户标识”在本地文件中建立值' 性能. 

[[legacy-authorized-users]] 
==== 旧版授权用户(Orchsym Studio实例升级) 

如果要从0升级.x Orchsym Studio实例，您可以将以前配置的用户和角色转换为多租户授权模型.  在'授权人.XML' 文件，指定现有"授权用户”的位置.XML' 文件在"旧版授权用户文件”属性中. 

这是一个示例条目: 


---- 
<authorizers> 
    <userGroupProvider> 
        <identifier>file-user-group-provider</identifier> 
        <class>org.apache.Orchsym Studio.authorization.FileUserGroupProvider</class> 
        <property name="Users File">./conf/users.xml</property> 
        <property name="Legacy Authorized Users File">/Users/johnsmith/config_files/authorized-users.xml</property> 

        <property name="Initial User Identity 1"></property> 
    </userGroupProvider> 
    <accessPolicyProvider> 
        <identifier>file-access-policy-provider</identifier> 
        <class>org.apache.Orchsym Studio.authorization.FileAccessPolicyProvider</class> 
        <property name="User Group Provider">file-user-group-provider</property> 
        <property name="Authorizations File">./conf/authorizations.xml</property> 
        <property name="Initial Admin Identity"></property> 
        <property name="Legacy Authorized Users File">/Users/johnsmith/config_files/authorized-users.xml</property> 

        <property name="Node Identity 1"></property> 
    </accessPolicyProvider> 
    <authorizer> 
        <identifier>managed-authorizer</identifier> 
        <class>org.apache.Orchsym Studio.authorization.StandardManagedAuthorizer</class> 
        <property name="Access Policy Provider">file-access-policy-provider</property> 
    </authorizer> 
</authorizers> 
---- 


编辑并保存"授权人”后.XML' 文件，重启Orchsym Studio. 来自'授权用户'的用户和角色.XML' 文件将被转换并添加为"用户”中的身份和策略.XML' 和'授权.XML' 档.  应用程序启动后，之前具有旧管理员角色的用户可以访问UI并开始管理用户，组和策略. 

如果Orchsym Studio实例具有现有的流，则下表总结了分配给每个旧角色的全局和组件策略.XML.gz': 

===== 全球访问政策 
[cols=">s,^s,^s,^s,^s,^s,^s", options="header"] 
|========================== 
|                                  |管理员| DFM | 监控| 来源| Orchsym Studio | 代理 
|view the UI                       |*      |*    |*        | | | 
|access the controller - view      |*      |*    |*        | |*     | 
|access the controller - modify    |       |*    | | | | 
|query provenance                  |       | | |*           | | 
|access restricted components      |       |*    | | | | 
|access all policies - view        |*      | | | | | 
|access all policies - modify      |*      | | | | | 
|access users/user groups - view   |*      | | | | | 
|access users/user groups - modify |*      | | | | | 
|retrieve site-to-site details     |       | | | |*     | 
|view system diagnostics           |       |*    |*        | | | 
|proxy user requests               |       | | | | |* 
|access counters                   |       | | | | | 
|========================== 

===== 根进程组上的组件访问策略 
[cols=">s,^s,^s,^s,^s,^s,^s", options="header"] 
|========================== 
|                                  |管理员| DFM | 监控| 来源| Orchsym Studio | 代理 
|view the component                |*      |*    |*        | | | 
|modify the component              |       |*    | | | | 
|view the data                     |       |*    | |*           | |* 
|modify the data                   |       |*    | | | |* 
|========================== 


有关表中各个策略的详细信息，请参阅<<access-policies>>. 

NOTE: 如果"初始管理员身份”和"旧版授权用户文件”属性都存在值，则Orchsym Studio无法重新启动.  您只能指定其中一个值来初始化授权. 

NOTE: 不要手动编辑'授权.XML' 文件. 仅在初始设置期间以及之后使用Orchsym Studio UI创建授权. 

[[cluster-node-identities]] 
==== 群集节点标识 

如果在群集环境中运行Orchsym Studio，则必须为每个节点指定标识.  在启动期间创建节点通信所需的授权策略. 

例如，如果要为每个节点设置具有以下DN的2节点集群: 


---- 
cn=Orchsym Studio-1,ou=people,dc=example,dc=com 
cn=Orchsym Studio-2,ou=people,dc=example,dc=com 
---- 



---- 
<authorizers> 
    <userGroupProvider> 
        <identifier>file-user-group-provider</identifier> 
        <class>org.apache.Orchsym Studio.authorization.FileUserGroupProvider</class> 
        <property name="Users File">./conf/users.xml</property> 
        <property name="Legacy Authorized Users File"></property> 

        <property name="Initial User Identity 1">johnsmith@Orchsym Studio.APACHE.ORG</property> 
        <property name="Initial User Identity 2">cn=Orchsym Studio-1,ou=people,dc=example,dc=com</property> 
        <property name="Initial User Identity 3">cn=Orchsym Studio-2,ou=people,dc=example,dc=com</property> 
    </userGroupProvider> 
    <accessPolicyProvider> 
        <identifier>file-access-policy-provider</identifier> 
        <class>org.apache.Orchsym Studio.authorization.FileAccessPolicyProvider</class> 
        <property name="User Group Provider">file-user-group-provider</property> 
        <property name="Authorizations File">./conf/authorizations.xml</property> 
        <property name="Initial Admin Identity">johnsmith@Orchsym Studio.APACHE.ORG</property> 
        <property name="Legacy Authorized Users File"></property> 

        <property name="Node Identity 1">cn=Orchsym Studio-1,ou=people,dc=example,dc=com</property> 
        <property name="Node Identity 2">cn=Orchsym Studio-2,ou=people,dc=example,dc=com</property> 
    </accessPolicyProvider> 
    <authorizer> 
        <identifier>managed-authorizer</identifier> 
        <class>org.apache.Orchsym Studio.authorization.StandardManagedAuthorizer</class> 
        <property name="Access Policy Provider">file-access-policy-provider</property> 
    </authorizer> 
</authorizers> 
---- 


NOTE: 在群集中，所有节点必须具有相同的"授权”.XML' 和'用户.XML”.   唯一的例外是节点是否具有空的授权.XML' 和'用户.XML' 加入群集之前的文件.  在此方案中，节点在启动期间从群集继承它们. 

现在已经创建了初始授权，可以在Orchsym Studio UI中创建和管理其他用户，组和授权. 

[[config-users-access-policies]] 
=== 配置用户和访问策略 

根据配置的UserGroupProvider和AccessPolicyProvider的功能，可以在UI中配置用户，组和策略.如果扩展名不可配置，则 
用户，组和策略在UI中将是只读的.如果配置的授权程序不使用UserGroupProvider和AccessPolicyProvider 
，则基于底层实现，用户和策略可能在UI中可见或可 配置. 

本节假定用户，组和策略可在UI中配置，并描述: 

* 如何创建用户和组 
* 访问策略如何用于定义授权 
* 如何查看在用户上设置的策略 
* 如何通过遍历特定示例来配置访问策略 

NOTE: 需要与UI交互的说明假定User1(具有管理员权限的用户)访问应用程序，例如"初始管理员身份”用户或转换后的旧管理员用户(请参阅<<authorizers-setup>>). 

[[creating-users-groups]] 
==== 创建用户和组 

从UI，从全局菜单中选择"用户”.  这将打开一个用于创建和管理用户和组的对话框. 

image:Orchsym Studio-users-dialog.png["Orchsym Studio Users Dialog"] 

单击"添加”图标(image:iconAddUser.png["Add User Icon"]).  要创建用户，请输入"身份”' 与为保护您的Orchsym Studio实例而选择的身份验证方法相关的信息.  单击确定. 

image:user-creation-dialog.png["User Creation Dialog"] 

要创建组，请选择"组”单选按钮，输入组的名称，然后选择要包括在组中的用户.  单击确定. 


image:group-creation-dialog.png["Group Creation Dialog"] 

[[access-policies]] 
==== 访问策略 

您可以使用"访问策略”管理用户和组查看或修改Orchsym Studio资源的能力.  可以将两种类型的访问策略应用于资源: 

* 视图 -- 如果为资源创建了视图策略，则只有添加到该策略的用户或组才能看到该资源的详细信息. 
* 修改 -- 如果资源具有修改策略，则只有添加到该策略的用户或组才能更改该资源的配置. 

您可以在全局和组件级别创建和应用访问策略. 

[[global-access-policies]] 
===== 全局访问策略 

全局访问策略管理以下系统级授权: 

|=== 
|Policy |权限|全局菜单选择 

|查看UI 
|允许用户查看UI 
| N / A 

|访问控制器 
|允许用户查看/修改控制器，包括"群集” 
|"控制器设置” 

|查询中的" 报告任务”，"控制器服务”和"节点 ” 来源 
|允许用户提交原型搜索并请求事件沿袭 
|数据源 

|访问受限组件 
|允许用户创建/修改受限制的组件，假设其他权限已足够.受限 
组件可以指示需要哪些特定权限.可以为特定
限制授予权限，也可以在 不受限制的情况下授予权限.如果授予权限而不受限制， 
则用户可以创建/修改所有受限制的组件. 
| N / A 

|访问所有策略 
|允许用户查看/修改所有组件的 
策略|策略 

|访问用户/用户组 
|允许用户查看/修改用户和用户组 
|用户 

|检索站点到站点详细信息 
|允许其他Orchsym Studio实例检索站点到站点详细信息 
| N / A 

|查看系统诊断 
|允许用户查看系统诊断 
|摘要 

|代理用户请求 
|允许代理计算机代表他人发送请求 
| N / A 

| access counters 
|允许用户查看/修改计数器 
|计数器 
|=== 

[[component-level-access-policies]] 
===== 组件级访问策略 

组件级访问策略管理以下组件级授权: 

|=== 
|Policy |特权 

|查看组件 
|允许用户查看组件配置的细节 

|修改组件 
|允许用户修改组件配置的细节 

|查看数据 
|允许用户查看元数据和内容，用于通过种源数据此组件和flowfile在出站连接队列 

|修改数据 
|允许用户在出站连接中清空流文件队列并提交重放 

|查看策略 
|允许用户查看可以查看/修改组件的用户列表 

|修改策略 
|允许用户修改用户列表可以查看/修改组件 

|通过站点到站点接收数据 
|允许端口从Orchsym Studio实例接收数据 

|通过站点到站点 
发送数据|允许端口从Orchsym Studio实例发送数据 
|=== 

NOTE: 您可以将访问策略应用于除连接之外的所有组件类型.  连接授权由连接的源和目标组件上的各个访问策略以及包含组件的进程组的访问策略推断.  这将在下面的"创建连接”和"编辑连接”示例中更详细地讨论. 

NOTE: 为了访问连接的列表队列或删除队列，用户需要在组件上"查看数据”和"修改数据”策略的权限. 在集群环境中，所有节点也必须添加到这些策略中，因为可以通过集群中的任何节点复制用户请求. 

[[access-policy-inheritance]] 
===== 访问策略继承 

管理员无需为数据流中的每个组件手动创建策略.  为了减少管理员在授权管理上花费的时间，策略将从父资源继承到子资源.  例如，如果授予用户查看和修改进程组的权限，则该用户还可以查看和修改进程组中的组件.  策略继承使管理员可以一次分配策略，并使策略适用于整个数据流. 

您可以覆盖继承的策略(如下面的<<moving-a-processor>>示例中所述).  覆盖策略会删除继承的策略，从父项到子项断开继承链，并创建替换策略以根据需要添加用户.  可以通过删除替换策略来恢复继承的策略及其用户. 

NOTE: "查看策略”和"修改策略”组件级访问策略是此继承行为的例外. 将用户添加到任一策略后，它们将添加到当前管理员列表中. 他们不会覆盖更高级别的管理员. 因此，仅显示特定于组件的管理员以"查看策略”和"修改策略”访问策略. 

NOTE: 您无法修改继承策略上的用户/组.  只能在父策略或覆盖策略中添加或删除用户和组. 

[[viewing-policies-users]] 
==== 查看用户策略在 

UI中，从全局菜单中选择"用户”. 这将打开"Orchsym Studio用户”对话框. 

image:user-policies.png["User Policies Window"] 

选择"查看用户策略”图标(image:iconUserPolicies.png["User Policies Icon"]). 

image:user-policies-detail.png["User Policies Detail"] 

"用户策略”窗口显示已为所选用户设置的全局和组件级策略.  选择"转到”图标(image:iconGoTo.png["Go To Icon"])导航到画布中的该组件. 

[[access-policy-config-examples]] 
==== 访问策略配置示例 

了解如何创建和应用访问策略的最有效方法是介绍一些常见示例.  以下方案假定User1是管理员，而User2是新添加的用户，该用户仅被授予对UI的访问权限. 

让我们从画布上的两个组件开始作为我们的起点:GenerateFlowFile和LogAttribute. 

image:access-policy-config-start.png["Access Policy Config Start"] 

User1可以向数据流添加组件，并能够移动，编辑和连接所有组件.  User1可以看到根进程组和组件的详细信息和属性. 

image:user1-full-access.png["User1 Full Access"] 

User1希望保持其对数据流及其组件的当前权限. 

User2无法将组件添加到数据流或移动，编辑或连接组件.  User2将隐藏根进程组和组件的详细信息和属性. 

image:user2-restricted-access.png["User2 Restricted Access"] 

[[moving-a-processor]] 
===== 移动组件 

为了允许User2在数据流中移动GenerateFlowFile组件而仅移动该组件，User1执行以下步骤: 

1. 选择GenerateFlowFile组件以使其突出显示. 
2. 选择"访问策略”图标(image:iconAccessPolicies.png["Access Policies Icon"])从"操作”选项板和"访问策略”对话框打开. 
3. 从策略下拉列表中选择"修改组件”. 组件(子)上当前存在的"修改组件”策略是从User1具有权限的根进程组(父)继承的"修改组件”策略. 
+ 
image::processor-modify-policy.png["Processor Modify Policy"] 
4. 在策略继承消息中选择"覆盖”链接.  创建替换策略时，您可以选择使用继承策略的副本或空策略覆盖. 选择"覆盖”按钮以创建副本. 
+ 
image::override_policy_copy_empty.png["Create Override Policy"] 
五. 在创建的替换策略上，选择"添加用户”图标(image:iconAddUser.png["Add User Icon"]). 在"用户标识”字段中查找或输入User2，然后选择"确定”. 通过这些更改，User1可以在画布上移动两个组件.  User2现在可以移动GenerateFlowFile组件，但无法移动LogAttribute组件. 
+ 
image::processor-replacement-modify-policy.png["Processor Replacement Modify Policy"] 
+ 
image::user2-moved-processor.png["User2 Moved Processor"] 

[[editing-a-processor]] 
===== 编辑组件 

在上面的"移动组件”示例中，User2已添加到GenerateFlowFile的"修改组件”策略中.  如果无法查看组件属性，User2将无法修改组件的配置.  为了编辑组件，用户必须同时处于"查看组件”和"修改组件”策略.为实现此目的，User1执行以下步骤: 

1. 选择GenerateFlowFile组件. 
2. 选择"访问策略”图标(image:iconAccessPolicies.png["Access Policies Icon"])从"操作”选项板和"访问策略”对话框打开. 
3. 从策略下拉列表中选择"查看组件”. 组件"当前存在于组件(子)上的策略的视图是”查看组件"策略，该策略继承自User1具有权限的根进程组(父). 
+ 
image::processor-view-policy.png["Processor View Policy"] 
4. 在策略继承消息中选择"覆盖”链接，保留"复制策略”的默认值，然后选择"覆盖”按钮. 
五. 在创建的覆盖策略上，选择"添加用户”图标(image:iconAddUser.png["Add User Icon"]). 在"用户标识”字段中查找或输入User2，然后选择"确定”. 通过这些更改，User1可以在画布上查看和编辑组件. User2现在可以查看和编辑GenerateFlowFile组件. 
+ 
image::processor-replacement-view-policy.png["Processor Replacement View Policy"] 
+ 
image::user2-edit-processor.png["User2 Edit Processor"] 

[[creating-a-connection]] 
===== 创建连接 

使用前面两个示例中讨论的配置访问策略，User1能够将GenerateFlowFile连接到LogAttribute: 

image:user1-create-connection.png["User1 Create Connection"] 

User2无法建立连接: 

image:user2-no-connection.png["User2 No Connection"] 

这是因为: 

* User2对进程组没有修改权限. 
* 即使User2具有查看和修改对源组件(GenerateFlowFile)的访问权限，User2也没有对目标组件的访问策略(LogAttribute). 

允许User2将GenerateFlowFile连接到LogAttribute，如User1: 

1. 选择根进程组. 操作选项板将更新根进程组的详细信息. 
2. 选择"访问策略”图标(image:iconAccessPolicies.png["Access Policies Icon"])从"操作”选项板和"访问策略”对话框打开. 
3. 从策略下拉列表中选择"修改组件”. 
  image:process-group-modify-policy.png["Process Group Modify Policy"] 
[start=4] 
4. 选择添加用户图标(image:iconAddUser.png["Add User Icon"]). 找到或输入User2并选择确定. 

image:process-group-modify-policy-add-user2.png["Process Group Modify Policy Add User2"] 

通过将User2添加到进程组上的"修改组件”策略，通过策略继承将User2添加到LogAttribute组件上的"修改组件”策略.  要确认这一点，请突出显示LogAttribute组件并选择"访问策略”图标(image:iconAccessPolicies.png["Access Policies Icon"])来自操作调色板: 

image:processor-inherited-modify-policy.png["User2 Inherited Edit Processor"] 

通过这些更改，User2现在可以将GenerateFlowFile组件连接到LogAttribute组件. 

image:user2-can-connect.png["User2 Can Connect"] 

image:user2-connected-processors.png["User2 Connected Processors"] 

[[editing-a-connection]] 
===== 编辑连接 

假设User1或User2将ReplaceText组件添加到根进程组: 

image:replacetext-processor-added.png["ReplaceText Processor Added"] 

User1可以选择并更改现有连接(在GenerateFlowFile和LogAttribute之间)，现在将GenerateFlowFile连接到ReplaceText: 

image:user1-edit-connection.png["User1 Edit Connection"] 

用户2无法执行此操作. 

image:user2-no-edit-connection.png["User2 No Edit Connection"] 

允许User2将GenerateFlowFile连接到ReplaceText，如User1: 

1. 选择根进程组. 操作选项板将更新根进程组的详细信息. 
2. 选择"访问策略”图标(image:iconAccessPolicies.png["Access Policies Icon"]). 
3. 从策略下拉列表中选择"查看组件”. 
  image:process-group-view-policy.png["Process Group View Policy"] 
[start=4] 
4. 选择添加用户图标(image:iconAddUser.png["Add User Icon"]). 找到或输入User2并选择确定. 

image:process-group-view-policy-add-user2.png["Process Group View Policy Add User2"] 

添加到进程组的视图和修改策略，User2现在可以将GenerateFlowFile组件连接到ReplaceText组件. 

image:user2-edit-connection.png["User2 Edit Connection"] 

[[encryption]] 
== 加密配置 

本节概述了Orchsym Studio加密和解密数据的功能. 

该 `EncryptContent` 组件允许加密和解密数据，这些数据都在Orchsym Studio内部并与外部系统集成，例如 `openssl` 和其他数据来源和消费者. 

[[key-derivation-functions]] 
=== 密钥派生函数 

密钥派生函数(KDF)是将人类可读信息(通常是密码或其他秘密信息)转换为适合数据保护的加密密钥的机制。. 有关详细信息，请阅读 link:https://en.wikipedia.org/wiki/Key_derivation_function[Wikipedia entry on Key Derivation Functions^]. 
目前，KDF被摄取 `CipherProvider` 实现并返回完全初始化 `Cipher` 用于加密或解密的对象. 由于使用了 `CipherProviderFactory`，KDF目前无法定制. 未来的增强功能包括在初始化时向KDF提供自定义成本参数的能力. 作为解决方案， `CipherProvider` 可以使用构造函数中的自定义成本参数初始化实例，但目前不支持 `CipherProviderFactory`. 
以下是Orchsym Studio目前支持的KDF(主要是在 `EncryptContent` 基于密码的加密组件(PBE))和相关说明: 

* Orchsym Studio Legacy KDF 
** Orchsym Studio用于PBE内部密钥派生的原始KDF，这是密码串联和8或16字节随机盐的MD5摘要的1000次迭代(盐长度取决于所选的密码块大小). 
** 这个KDF是 *从Orchsym Studio 0开始弃用.五.0* 并且应仅用于向后兼容以解密先前由传统版本的Orchsym Studio加密的数据. 
* OpenSSL PKCS＃5 v1.5 EVP_BytesToKey 
** 该vDF在v0中添加.4.0. 
** 此KDF用于与使用OpenSSL的默认PBE加密的数据兼容，称为 `EVP_BytesToKey`. 这是MD5在密码和8字节随机ASCII盐的串联上的单次迭代. OpenSSL建议使用 `PBKDF2` 用于密钥派生但不公开命令行工具所需的库方法，因此该KDF仍然是命令行加密的事实上的默认值. 
* Bcrypt 
** 该vDF在v0中添加.五.0. 
** link:https://en.wikipedia.org/wiki/Bcrypt[Bcrypt^] 是一种基于的自适应功能 link:https://en.wikipedia.org/wiki/Blowfish_(cipher)[Blowfish^] cipher. This KDF is strongly recommended as it automatically incorporates a random 16 byte salt, configurable cost parameter (or "work factor"), and is hardened against brute-force attacks using link:https://en.wikipedia.org/wiki/General-purpose_computing_on_graphics_processing_units[GPGPU^] (通过在密钥推导期间访问"大”内存块来共享内核之间的内存). 它抵抗力较弱 link:https://en.wikipedia.org/wiki/Field-programmable_gate_array[FPGA^] 门阵列可以访问各个嵌入式RAM块的暴力攻击. 
** 由于Bcrypt派生密钥的长度始终为184位，因此完整输出将输入到a `SHA-512` 消化并截断到所需的密钥长度. 这为格式化输入提供了雪崩效应的好处. 
** 建议的最小工作因数是12(2 ^ 12 ^密钥派生轮次)(截至2016年2月1日的商品硬件)，应增加到合法系统遇到有害延迟的阈值(见下面的时间表或使用 `BcryptCipherProviderGroovyTest#testDefaultConstructorShouldProvideStrongWorkFactor()` 计算安全最小值). 
** 盐格式是 `$2a$10$ABCDEFGHIJKLMNOPQRSTUV`. 盐被分隔 `$` 这三个部分如下: 
*** `2a` - 格式的版本. 可以找到广泛的解释 link:http://blog.ircmaxell.com/2012/12/seven-ways-to-screw-up-bcrypt.html[here^]. Orchsym Studio目前使用 `2a` 对于内部产生的所有盐. 
*** `10` - 工作因素. 这实际上是log~2~值，因此在这种情况下总迭代次数将是2 ^ 10 ^. 
*** `ABCDEFGHIJKLMNOPQRSTUV` - 22个字符，Base64编码，未填充，原盐值. 这解码为密钥派生中使用的16字节盐. 
* Scrypt 
** 该vDF在v0中添加.五.0. 
** link:https://en.wikipedia.org/wiki/Scrypt[Scrypt^] 是一个响应的设计的自适应功能 `bcrypt`. 建议使用此KDF，因为它需要相对大量的内存用于每个派生，从而抵抗硬件暴力攻击. 
** 建议的最低费用是 `N`= 2 ^ 14 ^， `r`= 8， `p`= 1(截至2016年2月1日的商品硬件)并且应该增加到合法系统遇到有害延迟的阈值(参见下面的时间表或使用 `ScryptCipherProviderGroovyTest#testDefaultConstructorShouldProvideStrongParameters()` 计算安全最小值). 
** 盐格式是 `$s0$e0101$ABCDEFGHIJKLMNOPQRSTUV`. 盐被分隔 `$` 这三个部分如下: 
*** `s0` - 格式的版本. Orchsym Studio目前使用 `s0` 对于内部产生的所有盐. 
*** `e0101` - 成本参数. 这实际上是一个十六进制编码 `N`， `r`， `p` 使用轮班. 这可以使用形成/解析 `Scrypt#encodeParams()` 和 `Scrypt#parseParameters()`. 
**** 一些外部库编码 `N`， `r`，和 `p` 单独的形式 `$400$1$1$`. 可以使用实用方法 `ScryptCipherProvider#translateSalt()` 这会将外部表单转换为内部表单. 
*** `ABCDEFGHIJKLMNOPQRSTUV` - 12-44字符，Base64编码，未填充，原盐值. 这解码为密钥派生中使用的8-32字节的盐. 
* PBKDF2 
** 该vDF在v0中添加.五.0. 
** link:https://en.wikipedia.org/wiki/PBKDF2[Password-Based Key Derivation Function 2^] 是一个自适应推导函数，它使用内部伪随机函数(PRF)并通过密码和盐(至少16个字节)多次迭代它. 
** 建议使用PRF `HMAC/SHA-256` 要么 `HMAC/SHA-512`. HMAC加密散列函数的使用减轻了长度扩展攻击. 
** 建议的最小迭代次数为160,000(截至2016年2月1日的商品硬件). 这个数字应该每两年增加一倍(见下面的时间表或使用 `PBKDF2CipherProviderGroovyTest#testDefaultConstructorShouldProvideStrongIterationCount()` 计算安全最小值). 
** 这个KDF不是内存很难(可以用商用硬件进行大规模并行化)但仍然建议用http:// csrc.NIST.GOV /出版/ nistpubs / 800-132 / NIST-sp800-132.PDF格式[NIST SP 800-132 (PDF)] 和许多密码学家(当使用适当的迭代计数和HMAC加密哈希函数). 
* 没有 
** 该vDF在v0中添加.五.0. 
** 此KDF不对输入执行任何操作，并且是指示将原始密钥提供给密码的标记. 密钥必须以十六进制编码提供，并且对于关联的密码/算法具有有效长度. 

==== 其他资源 

* link:http://stackoverflow.com/a/30308723/70465[Explanation of optimal scrypt cost parameters and relationships^] 
* link:http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf[NIST Special Publication 800-132^] 
* link:https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet#Work_Factor[OWASP Password Storage Work Factor Calculations^] 
* link:http://security.stackexchange.com/a/3993/16485[PBKDF2 rounds calculations^] 
* link:http://blog.ircmaxell.com/2014/03/why-i-dont-recommend-scrypt.html[Scrypt as KDF vs password storage vulnerabilities^] 
* link:http://security.stackexchange.com/a/26253/16485[Scrypt vs. Bcrypt (as of 2010)^] 
* link:http://security.stackexchange.com/a/6415/16485[Bcrypt vs PBKDF2^] 
* link:http://wildlyinaccurate.com/bcrypt-choosing-a-work-factor/[Choosing a work factor for Bcrypt^] 
* link:https://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/crypto/bcrypt/BCrypt.html[Spring Security Bcrypt^] 
* link:https://www.openssl.org/docs/man1.1.0/crypto/EVP_BytesToKey.html[OpenSSL EVP BytesToKey PKCS#1v1.5^] 
* link:https://wiki.openssl.org/index.php/Manual:PKCS5_PBKDF2_HMAC(3)[OpenSSL PBKDF2 KDF^] 
* link:http://security.stackexchange.com/a/29139/16485[OpenSSL KDF flaws description^] 

=== 盐和IV编码 

最初， `EncryptContent` 组件有一种从用户提供的密码导出加密密钥的方法. 现在称为 `Orchsym StudioLegacy` 模式，有效 `MD5 digest, 1000 iterations`. 在v0.4.0，另一种导出密钥的方法， `OpenSSL PKCS#5 v1.5 EVP_BytesToKey` was added for compatibility with content encrypted outside of Orchsym Studio using the `openssl` command-line tool. Both of these <<key-derivation-functions, Key Derivation Functions>> (KDF) had hard-coded digest functions and iteration counts, and the salt format was also hard-coded. With v0.5.0, additional KDFs are introduced with variable iteration counts, work factors, and salt formats. In addition, _还引入了raw keyed encryption_. 这需要能够将任意盐和初始化矢量(IV)编码到密码流中，以便通过Orchsym Studio或后续系统进行恢复以解密这些消息. 

对于现有的KDF，salt格式没有改变. 

==== Orchsym Studio Legacy输入 

的前8或16个字节是salt. 盐长度基于所选算法的密码块长度确定. 如果无法确定密码块大小(例如使用流密码) `RC4`)，使用默认值8字节. 在解密时，盐被读入并与密码组合以导出加密密钥和IV. 

image:Orchsym Studio-legacy-salt.png["Orchsym Studio Legacy Salt Encoding"] 

==== OpenSSL PKCS＃5 v1.5 EVP_BytesToKey 

OpenSSL允许使用salted或unsalted密钥派生. _*Unsalted key derivation is a security risk and is not recommended.*_ 如果存在salt，则输入的前8个字节是ASCII字符串"`Salted__`"(`0x53 61 6C 74 65 64 5F 5F`)接下来的8个字节是ASCII编码的盐. 在解密时，盐被读入并与密码组合以导出加密密钥和IV. 如果没有salt标头，则整个输入被认为是密文. 

image:openssl-salt.png["OpenSSL Salt Encoding"] 

对于新的KDF，每个都允许非确定性IV，IV必须与密文一起存储. 这不是一个漏洞，因为IV不需要保密，而只是对于使用相同密钥加密的消息是唯一的，以减少加密攻击的成功. 对于这些KDF，输出由盐组成，后跟盐分隔符，UTF-8字符串"`Orchsym StudioSALT`"(`0x4E 69 46 69 53 41 4C 54`)然后是IV，接着是IV分隔符，UTF-8字符串"`Orchsym StudioIV`"(`0x4E 69 46 69 49 56`)，然后是密文. 

==== Bcrypt，Scrypt，PBKDF2 

image:bcrypt-salt.png["Bcrypt Salt & IV Encoding"] 

image:scrypt-salt.png["Scrypt Salt & IV Encoding"] 

image:pbkdf2-salt.png["PBKDF2 Salt & IV Encoding"] 

=== Java密码学扩展(JCE)有限的强度管辖权政策 

由于美国的出口法规，默认的JVM有link:http://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html#importlimits[limits imposed on the strength of cryptographic operations^] 可供他们使用. 例如，AES操作仅限于 `128 bit keys` 默认. 而 `AES-128` 是加密安全的，这可能会产生意想不到的后果，尤其是基于密码的加密(PBE). 

PBE是从中导出用于加密或解密的加密密钥的过程 _user-provided secret material_，通常是密码. 使用密码或密码短语而不是人类记住(随机出现的)32或64个字符的十六进制字符串. 

由于潜在的密钥长度检查，Orchsym Studio提供的许多PBE算法对密码长度施加了严格的限制. 下表列出了具有有限加密强度的JVM上的最大密码长度. 

.有限加密强度JVM上的最大密码长度 
|=== 
|Algorithm |最大密码长度 

|`PBEWITHMD5AND128BITAES-CBC-OPENSSL` 
| 16 

|`PBEWITHMD5AND192BITAES-CBC-OPENSSL` 
| 16 

|`PBEWITHMD5AND256BITAES-CBC-OPENSSL` 
| 16 

|`PBEWITHMD5ANDDES` 
| 16 

|`PBEWITHMD5ANDRC2` 
| 16 

|`PBEWITHSHA1ANDRC2` 
| 16 

|`PBEWITHSHA1ANDDES` 
| 16 

|`PBEWITHSHAAND128BITAES-CBC-BC` 
| 7 

|`PBEWITHSHAAND192BITAES-CBC-BC` 
| 7 

|`PBEWITHSHAAND256BITAES-CBC-BC` 
| 7 

|`PBEWITHSHAAND40BITRC2-CBC` 
| 7 

|`PBEWITHSHAAND128BITRC2-CBC` 
| 7 

|`PBEWITHSHAAND40BITRC4` 
| 7 

|`PBEWITHSHAAND128BITRC4` 
| 7 

|`PBEWITHSHA256AND128BITAES-CBC-BC` 
| 7 

|`PBEWITHSHA256AND192BITAES-CBC-BC` 
| 7 

|`PBEWITHSHA256AND256BITAES-CBC-BC` 
| 7 

|`PBEWITHSHAAND2-KEYTRIPLEDES-CBC` 
| 7 

|`PBEWITHSHAAND3-KEYTRIPLEDES-CBC` 
| 7 

|`PBEWITHSHAANDTWOFISH-CBC` 
|7 
|=== 

=== Allow Insecure Cryptographic Modes 

By default, the `Allow Insecure Cryptographic Modes` property in `EncryptContent` processor settings is set to `not-allowed`. This means that if a password of fewer than `10` characters is provided, a validation error will occur. 10 characters is a conservative estimate and does not take into consideration full entropy calculations, patterns, etc. 

image:allow-weak-crypto.png["Allow Insecure Cryptographic Modes", width=940] 

On a JVM with limited strength cryptography, some PBE algorithms limit the maximum password length to 7, and in this case it will not be possible to provide a "safe" password. It is recommended to install the JCE Unlimited Strength Jurisdiction Policy files for the JVM to mitigate this issue. 

* link:http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html[JCE Unlimited Strength Jurisdiction Policy files for Java 8^] 

If on a system where the unlimited strength policies cannot be installed, it is recommended to switch to an algorithm that supports longer passwords (see table above). 

[WARNING] 
.Allowing Weak Crypto 
===================== 
If it is not possible to install the unlimited strength jurisdiction policies, the `Allow Weak Crypto` setting can be changed to `allowed`, but *this is _not_ recommended*. Changing this setting explicitly acknowledges the inherent risk in using weak cryptographic configurations. 
===================== 

It is preferable to request upstream/downstream systems to switch to link:https://cwiki.apache.org/confluence/display/Orchsym Studio/Encryption+Information[keyed encryption^] or use a "strong" link:https://cwiki.apache.org/confluence/display/Orchsym Studio/Key+Derivation+Function+Explanations[Key Derivation Function (KDF) supported by Orchsym Studio^]. 

== Encrypted Passwords in Configuration Files 

In order to facilitate the secure setup of Orchsym Studio, you can use the `encrypt-config` command line utility to encrypt raw configuration values that Orchsym Studio decrypts in memory on startup. This extensible protection scheme transparently allows Orchsym Studio to use raw values in operation, while protecting them at rest.  In the future, hardware security modules (HSM) and external secure storage mechanisms will be integrated, but for now, an AES encryption provider is the default implementation. 

This is a change in behavior; prior to 1.0, all configuration values were stored in plaintext on the file system. POSIX file permissions were recommended to limit unauthorized access to these files 

If no administrator action is taken, the configuration values remain unencrypted. 

[[encrypt-config_tool]] 
=== Encrypt-Config Tool 

The `encrypt-config` command line tool (invoked as `./bin/encrypt-config.sh` or `bin\encrypt-config.bat`) reads from a 'Orchsym Studio.properties' file with plaintext sensitive configuration values, prompts for a master password or raw hexadecimal key, and encrypts each value. It replaces the plain values with the protected value in the same file, or writes to a new 'Orchsym Studio.properties' file if specified. 

The default encryption algorithm utilized is AES/GCM 128/256-bit. 128-bit is used if the JCE Unlimited Strength Cryptographic Jurisdiction Policy files are not installed, and 256-bit is used if they are installed. 

You can use the following command line options with the `encrypt-config` tool: 

* `-h`,`--help`                                 Prints this usage message 
* `-v`,`--verbose`                             Sets verbose mode (default false) 
* `-n`,`--Orchsym StudioProperties <arg>`                 The Orchsym Studio.properties file containing unprotected config values (will be overwritten) 
* `-l`,`--loginIdentityProviders <arg>`         The login-identity-providers.xml file containing unprotected config values (will be overwritten) 
* `-a`,`--authorizers <arg>`                    The authorizers.xml file containing unprotected config values (will be overwritten) 
* `-f`,`--flowXml <arg>`                        The flow.xml.gz file currently protected with old password (will be overwritten) 
* `-b`,`--bootstrapConf <arg>`                 The bootstrap.conf file to persist master key 
* `-o`,`--outputOrchsym StudioProperties <arg>`           The destination Orchsym Studio.properties file containing protected config values (will not modify input Orchsym Studio.properties) 
* `-i`,`--outputLoginIdentityProviders <arg>`   The destination login-identity-providers.xml file containing protected config values (will not modify input login-identity-providers.xml) 
* `-u`,`--outputAuthorizers <arg>`              The destination authorizers.xml file containing protected config values (will not modify input authorizers.xml) 
* `-g`,`--outputFlowXml <arg>`                  The destination flow.xml.gz file containing protected config values (will not modify input flow.xml.gz) 
* `-k`,`--key <arg>`                            The raw hexadecimal key to use to encrypt the sensitive properties 
* `-e`,`--oldKey <arg>`                         The old raw hexadecimal key to use during key migration 
* `-p`,`--password <arg>`                       The password from which to derive the key to use to encrypt the sensitive properties 
* `-w`,`--oldPassword <arg>`                    The old password from which to derive the key during migration 
* `-r`,`--useRawKey`                            If provided, the secure console will prompt for the raw key value in hexadecimal form 
* `-m`,`--migrate`                              If provided, the Orchsym Studio.properties and/or login-identity-providers.xml sensitive properties will be re-encrypted with a new key 
* `-x`,`--encryptFlowXmlOnly`                   If provided, the properties in flow.xml.gz will be re-encrypted with a new key but the Orchsym Studio.properties and/or login-identity-providers.xml files will not be modified 
* `-s`,`--propsKey <arg>`                       The password or key to use to encrypt the sensitive processor properties in flow.xml.gz 
* `-A`,`--newFlowAlgorithm <arg>`               The algorithm to use to encrypt the sensitive processor properties in flow.xml.gz 
* `-P`,`--newFlowProvider <arg>`                The security provider to use to encrypt the sensitive processor properties in flow.xml.gz 

As an example of how the tool works, assume that you have installed the tool on a machine supporting 256-bit encryption and with the following existing values in the 'Orchsym Studio.properties' file: 


---- 
# security properties # 
Orchsym Studio.sensitive.props.key=thisIsABadSensitiveKeyPassword 
Orchsym Studio.sensitive.props.algorithm=PBEWITHMD5AND256BITAES-CBC-OPENSSL 
Orchsym Studio.sensitive.props.provider=BC 
Orchsym Studio.sensitive.props.additional.keys= 

Orchsym Studio.security.keystore=/path/to/keystore.jks 
Orchsym Studio.security.keystoreType=JKS 
Orchsym Studio.security.keystorePasswd=thisIsABadKeystorePassword 
Orchsym Studio.security.keyPasswd=thisIsABadKeyPassword 
Orchsym Studio.security.truststore= 
Orchsym Studio.security.truststoreType= 
Orchsym Studio.security.truststorePasswd= 
---- 


Enter the following arguments when using the tool: 


---- 
encrypt-config.sh 
-b bootstrap.conf 
-k 0123456789ABCDEFFEDCBA98765432100123456789ABCDEFFEDCBA9876543210 
-n Orchsym Studio.properties 
---- 


As a result, the 'Orchsym Studio.properties' file is overwritten with protected properties and sibling encryption identifiers (`aes/gcm/256`, the currently supported algorithm): 


---- 
# security properties # 
Orchsym Studio.sensitive.props.key=n2z+tTTbHuZ4V4V2||uWhdasyDXD4ZG2lMAes/vqh6u4vaz4xgL4aEbF4Y/dXevqk3ulRcOwf1vc4RDQ== 
Orchsym Studio.sensitive.props.key.protected=aes/gcm/256 
Orchsym Studio.sensitive.props.algorithm=PBEWITHMD5AND256BITAES-CBC-OPENSSL 
Orchsym Studio.sensitive.props.provider=BC 
Orchsym Studio.sensitive.props.additional.keys= 

Orchsym Studio.security.keystore=/path/to/keystore.jks 
Orchsym Studio.security.keystoreType=JKS 
Orchsym Studio.security.keystorePasswd=oBjT92hIGRElIGOh||MZ6uYuWNBrOA6usq/Jt3DaD2e4otNirZDytac/w/KFe0HOkrJR03vcbo 
Orchsym Studio.security.keystorePasswd.protected=aes/gcm/256 
Orchsym Studio.security.keyPasswd=ac/BaE35SL/esLiJ||+ULRvRLYdIDA2VqpE0eQXDEMjaLBMG2kbKOdOwBk/hGebDKlVg== 
Orchsym Studio.security.keyPasswd.protected=aes/gcm/256 
Orchsym Studio.security.truststore= 
Orchsym Studio.security.truststoreType= 
Orchsym Studio.security.truststorePasswd= 
---- 


另外，'bootstrap.CONF' 使用加密密钥更新文件，如下所示: 


---- 
# Master key in hexadecimal format for encrypted sensitive configuration values 
Orchsym Studio.bootstrap.sensitive.key=0123456789ABCDEFFEDCBA98765432100123456789ABCDEFFEDCBA9876543210 
---- 


默认情况下，工具会对敏感配置值进行加密，但如果需要，您可以加密任何其他属性.  要加密其他属性，请在其中将它们指定为逗号分隔值 `Orchsym Studio.sensitive.props.additional.keys` 属性. 

如果是'Orchsym Studio.性能' 文件已具有有效的受保护值，该工具不会修改这些属性值. 

应用于'login-identity-providers时.XML' 和'授权人.xml'，属性元素用a更新 `encryption` attribute: 

受保护的login-identity-providers的示例.XML: 


---- 
   <!-- LDAP Provider --> 
   <provider> 
       <identifier>ldap-provider</identifier> 
       <class>org.apache.Orchsym Studio.ldap.LdapProvider</class> 
       <property name="Authentication Strategy">START_TLS</property> 
       <property name="Manager DN">someuser</property> 
       <property name="Manager Password" encryption="aes/gcm/128">q4r7WIgN0MaxdAKM||SGgdCTPGSFEcuH4RraMYEdeyVbOx93abdWTVSWvh1w+klA</property> 
       <property name="TLS - Keystore"></property> 
       <property name="TLS - Keystore Password" encryption="aes/gcm/128">Uah59TWX+Ru5GY5p||B44RT/LJtC08QWA5ehQf01JxIpf0qSJUzug25UwkF5a50g</property> 
       <property name="TLS - Keystore Type"></property> 
       
... 
   </provider> 
---- 


Example of protected authorizers.xml: 

--- 
   <!-- LDAP User Group Provider --> 
   <userGroupProvider> 
       <identifier>ldap-user-group-provider</identifier> 
       <class>org.apache.Orchsym Studio.ldap.tenants.LdapUserGroupProvider</class> 
       <property name="Authentication Strategy">START_TLS</property> 
       <property name="Manager DN">someuser</property> 
       <property name="Manager Password" encryption="aes/gcm/128">q4r7WIgN0MaxdAKM||SGgdCTPGSFEcuH4RraMYEdeyVbOx93abdWTVSWvh1w+klA</property> 
       <property name="TLS - Keystore"></property> 
       <property name="TLS - Keystore Password" encryption="aes/gcm/128">Uah59TWX+Ru5GY5p||B44RT/LJtC08QWA5ehQf01JxIpf0qSJUzug25UwkF5a50g</property> 
       <property name="TLS - Keystore Type"></property> 
       ... 

   </ userGroupProvider> 
--- 

[encrypt_config_property_migration] 
=== 敏感属性密钥迁移 

为了更改用于加密敏感值的密钥，请指明*迁移模式* 使用 `-m` 要么 `--migrate` 标志，使用提供新密钥或密码 `-k` 要么 `-p` 像往常一样标记，并使用提供现有密钥或密码 `-e` 要么 `-w` 分别. 这将允许工具包解密现有值并重新加密它们并进行更新 `bootstrap.conf` 用新钥匙. 每个阶段只需要指定一个密钥或密码(旧的vs. 新的)，任何组合就足够了: 

* 旧钥匙 ->新钥匙 
* 旧钥匙 ->新密码 
* 旧密码 ->新钥匙 
* 旧密码 ->新密码 

[encrypt_config_flow_migration] 
=== 现有流量迁移 

此工具还可用于更改值 `Orchsym Studio.sensitive.props.key` 对于现有流程. 该工具将读取现有的 `flow.xml.gz` 并使用原始密钥解密任何敏感组件属性， 
然后使用新密钥重新加密敏感属性，并写出新版本的 `flow.xml.gz`，或覆盖现有的. 

当前敏感属性键不作为命令行参数提供，因为它直接从中读取 `Orchsym Studio.properties`. 由于此文件是必需参数，因此 `-x`/`--encryptFlowXmlOnly` 标志告诉工具 *不* 尝试加密中的属性 `Orchsym Studio.properties`，而是 *只要* 更新 `Orchsym Studio.sensitive.props.key` 使用新密钥的值. 例外是如果 `Orchsym Studio.properties` 是 *已经* 加密后，新的敏感属性密钥也会在写入之前被加密 `Orchsym Studio.properties`. 

以下命令将迁移敏感属性密钥，这意味着它将覆盖现有密钥 `flow.xml.gz` 和 `Orchsym Studio.properties`: 

---- 
./encrypt-config.sh -f /path/to/flow.xml.gz -n ./path/to/Orchsym Studio.properties -s newpassword -x 
---- 


以下命令将迁移敏感属性密钥并写出单独的密钥 `flow.xml.gz` 和 `Orchsym Studio.properties`: 

---- 
./encrypt-config.sh -f ./path/to/src/flow.xml.gz -g /path/to/dest/flow.xml.gz -n /path/to/src/Orchsym Studio.properties -o /path/to/dest/Orchsym Studio.properties -s newpassword -x 
---- 


[[encrypt-config_password]] 
=== 密码密钥派生 

您可以提供密钥，而不是提供32或64个字符的原始十六进制密钥。. 截至1.0.0，密码必须至少为12个字符，并且密钥将使用导出 `SCrypt` 参数: 

* `pw` - - 密码字节 `UTF-8` 
* `salt` - - 固定盐值(`Orchsym Studio_SCRYPT_SALT`)字节 `UTF-8` 
* `N` -- 2 ^ 16 ^ 
* `r` -- 8 
* `p` -- 1 
* `dkLen` - - 根据可用的JCE政策确定 

截至2016年8月，这些值对于此威胁模型确定为强，但在未来版本中可能会更改. 

NOTE: 虽然固定盐与最佳实践相反，但静态盐对于确定性密钥推导是必需的，而无需额外存储盐值. 

[[encrypt-config_secure_prompt]] 
=== 安全提示 

如果您不想在工具的命令行调用中提供密码或原始密钥，则不保留这些参数将提示安全控制台读取密码(默认情况下)或原始密钥(如果 `-r` 在调用时提供标志). 

[[admin-toolkit]] 
== 管理工具 
管理工具包包含命令行实用程序，供管理员在独立
环境和集群环境中支持Orchsym Studio维护 . 这些工具包括: 

* 通知 -- 通知工具允许管理员使用命令行将公告发送到Orchsym Studio UI. 
* 节点管理器 -- 节点管理器工具允许管理员对节点执行状态检查，以及连接，断开或删除属于集群的节点. 
* 文件管理器 -- 文件管理器工具允许管理员从备份中备份，安装或恢复Orchsym Studio安装. 

管理工具包与Orchsym Studio-toolkit捆绑在一起，可以使用脚本中的脚本执行 _bin_ 夹. 

=== 在安全环境中运行Admin Toolkit的先决条件 
对于安全节点和群集，应预先配置两个策略: 

*访问控制器 - 有权访问这些实用程序的用户应通过创建"访问
控制器”策略在Orchsym Studio中获得授权 (`/controller`)具有查看和修改权限. 
*代理用户请求 - 如果之前未设置节点的标识(节点证书的DN值)，则应授权代表用户代理请求在 

安全环境中执行通知或节点管理器工具时 `proxyDN` 应使用flag选项 
以正确识别有权执行这些命令的用户.在非安全环境中，或者
在节点管理器工具上运行 状态操作时，将忽略该标志. 

=== Notify 
Notify允许管理员将消息作为公告发送给Orchsym Studio.  Orchsym Studio版本1支持通知.2.0和更高. 
通知工具也可用于 _notify.bat_ 用于Windows机器的文件. 

发送通知: 

通知.SH -d {$ Orchsym Studio_HOME} -b {Orchsym Studio bootstrap文件路径} -m {message} [-l {level}] [-v] 

要显示帮助: 

通知.SH -h 

以下是可用选项: 

* `-b`，`--bootstrapConf <arg>`     现有的Bootstrap配置文件(必需) 
* `-d`，`--Orchsym StudioInstallDir <arg>`     Orchsym Studio根文件夹(必填) 
* `-h`，`--help`                     帮助文字(可选) 
* `-l`，`--level <arg>`              公告的状态级别 - INFO，WARN，ERROR 
* `-m`，`--message <arg>`            公告信息(必填) 
* `-p`，`--proxyDN <arg>`           代理或用户DN(安全节点所需) 
* `-v`，`--verbose`                 详细消息传递(可选) 


Linux上的示例用法: 

./通知.SH -d / usr / Orchsym Studio / Orchsym Studio_current -b /usr/Orchsym Studio/Orchsym Studio_电流/ CONF /引导.CONF -m"测试消息服务器1” -l"WARN”-p"ydavis @Orchsym Studio” -v 

Windows上的示例用法: 

  notify.蝙蝠 -v -d"C:\\ Program Files \\ Orchsym Studio \\ Orchsym Studio-1.2.0-快照” -b"C:\\ Program Files \\ Orchsym Studio \\ Orchsym Studio-1.2.0-SNAPSHOT \\ CONF \\自举.CONF” -m"测试消息服务器1” -v 

执行上述命令行会导致公告出现在Orchsym Studio中: 

image::Orchsym Studio-notifications.png["Orchsym Studio Notifications"] 

=== 节点管理器 

节点管理器支持在群集中连接，断开连接和删除节点(
如果节点不是群集的一部分，则显示错误消息 )以及获取节点的状态.  当节点与
群集断开连接 并需要 
连接或删除时，应提供连接节点的URL列表以将所需命令发送到 
活动群集.  节点管理器支持Orchsym Studio版本1.0.0和更高.节点管理器也可以在 
'node-manager中使用.蝙蝠' 用于Windows机器的文件. 

从群集连接，断开连接或删除节点: 

node-manager.SH -d {$ Orchsym Studio_HOME} -b {Orchsym Studio bootstrap文件路径} 
-o {remove | disconnect | connect | status} [-u {url list}] [-p {proxy name}] [-v] 

要显示帮助: 

  node-manager.SH -h 

以下是可用选项: 

* `-b`，`--bootstrapConf <arg>`     现有的Bootstrap配置文件(必需) 
* `-d`，`--Orchsym StudioInstallDir <arg>`    Orchsym Studio根文件夹(必填) 
* `-h`，`--help`                    帮助文字(可选) 
* `-o`， `--operation <arg>`        支持的操作:状态，连接(群集)，断开连接(群集)，删除(群集) 
* `-p`，`--proxyDN <arg>`           代理或用户DN(安全节点执行连接，断开连接和删除操作所需) 
* `-u`，`--clusterUrls <arg>`       逗号分隔的群集活动URL列表(可选). 在连接或从群集中删除时，不需要断开节点 
* `-v`，`--verbose`                 详细消息传递(可选) 


Linux上的示例用法: 

#connect without cluster url list 
./节点管理器.SH 
-d / usr / Orchsym Studio / Orchsym Studio_current 
-b / usr / Orchsym Studio / Orchsym Studio_current / conf / bootstrap.CONF 
-o断开 
-p ydavis @Orchsym Studio 
-v 

#with url list 
./节点管理器.SH 
-d / usr / Orchsym Studio / Orchsym Studio_current 
-b / usr / Orchsym Studio / Orchsym Studio_current / conf / bootstrap.CONF 
-连接 
-你的http:// Orchsym Studio-server-1:8080，http:// Orchsym Studio-server-2:8080' 
-v 

Windows上的示例用法: 

node-manager.蝙蝠 
-d"C:\\ Program Files \\ Orchsym Studio \\ Orchsym Studio-1.2.0-快照” 
-b"C:\\ Program Files \\ Orchsym Studio \\ Orchsym Studio-1.2.0-SNAPSHOT \\ CONF \\自举.CONF” 
-o断开 
-v 

==== 预期行为 

状态: 

要获取有关节点的UI可用性的信息，可以使用状态操作来确定节点是否正在运行. 
如果 `–u (clusterUrls)` 没有提供选项当前节点url被检查，否则将检查提供的URL. 

断开连接: 

当节点与群集断开连接时，节点本身应显示为已断开连接，群集 
应有一个公告，指示已收到断开连接请求. 群集也应该显示 _n-1/n_ 
群集中可用的节点.例如，如果1个节点与3节点群集断开连接，则3个节点中的2个节点 
应显示在群集中的其余节点上.  在
具有断开连接的节点的群集上不应允许对流进行更改 . 

连接: 

执行connect命令以将节点重新连接到群集时，完成后节点本身 
应显示它已通过显示重新加入群集 _n/n_ 节点. 以前它会显示Disconnected. 
群集中的其他节点应该收到连接请求的公告并显示 _n/n_ 允许
对流进行更改的节点 . 

删除: 

执行remove命令时，节点应显示为与群集断开连接.
应显示群集中  剩余的节点 _n-1/n-1_ 节点.例如，如果从3节点集群中删除1个节点，则其余2个节点 
应显示2个节点中的2个节点).  群集应允许调整流量.
如果重新启动，  则已删除的节点可以重新加入 群集，并且群集的流未更改.如果更改了流，
则应在重新启动节点之前删除已删除节点的流模板， 以允许其获取集群流(否则 
可能会发生不可用的流文件异常). 

=== 文件管理器 

文件管理器实用程序允许系统管理员备份现有的Orchsym Studio安装，
在指定位置安装新版本的Orchsym Studio (在迁移任何先前的配置设置时)或从以前的备份恢复安装. 
文件管理器支持Orchsym Studio版本1.0.0和更高版本，可在'文件管理器中找到.蝙蝠' 用于Windows机器的文件. 

显示帮助: 

  文件管理器.SH -h 

以下是可用选项: 

* `-b`，`--backupDir <arg>`          备份Orchsym Studio目录(用于备份或恢复操作) 
* `-c`，`--Orchsym StudioCurrentDir <arg>`     当前的Orchsym Studio安装目录(可选择安装或恢复操作) 
* `-d`，`--Orchsym StudioInstallDir <arg>`     Orchsym Studio安装目录(用于安装或恢复操作) 
* `-h`，`--help`                     打印帮助信息(可选) 
* `-i`，`--installFile <arg>`        Orchsym Studio安装文件(用于安装操作) 
* `-m`，`--moveRepositories`         允许将存储库从现有安装移动到新的/恢复的Orchsym Studio目录(如果可用)(可选地与安装或恢复操作一起使用) 
* `-o`，`--operation <arg>`          文件操作(安装|备份|恢复) 
* `-r`，`--Orchsym StudioRollbackDir <arg>`    Orchsym Studio安装目录(用于安装或恢复操作) 
* `-t`，`--bootstrapConf <arg>`     当前的Orchsym Studio Bootstrap配置文件(可选) 
* `-v`，`--verbose`                 详细消息(可选) 
* `-x`，`--overwriteConfigs`         使用升级更改覆盖现有配置目录(可选择使用安装或还原操作) 

Linux上的示例用法: 

#backup Orchsym Studio installation 
＃option -可以提供t以确保外部boostrap的备份.conf文件 
./文件管理器.SH 
-o backup 
-b / tmp / Orchsym Studio_bak 
-c / usr / Orchsym Studio_old 
-v 

＃使用压缩的tar文件将Orchsym Studio安装到/ usr / Orchsym Studio目录中(应安装为/ usr / Orchsym Studio / Orchsym Studio-1.3.0). 
＃迁移现有配置，其位置由外部引导程序确定.conf并从Orchsym Studio_old 
＃options 移动存储库 -t和 -如果需要迁移配置，状态和存储库，则应同时提供c 
./文件管理器.SH 
-o安装 
-i Orchsym Studio-1.3.0.柏油.gz 
-d / usr / Orchsym Studio 
-c / usr / Orchsym Studio / Orchsym Studio_old 
-t / usr / Orchsym Studio / old_conf / bootstrap.CONF 
-v 
-m 

＃从备份目录恢复Orchsym Studio安装并移回存储库 
＃选项 -可以提供t以确保引导程序.conf被恢复到提供的文件路径，否则它被放置在 
回滚路径下的#default目录中(例如，.G. 的/ usr / Orchsym Studio_old / CONF) 
./文件管理器.SH 
-o恢复 
-b / tmp / Orchsym Studio_bak 
-r / usr / Orchsym Studio_old 
-c / usr / Orchsym Studio 
-米 
-v 

=== 预期行为 

备份: 

在备份操作期间，将在指定位置为现有Orchsym Studio安装创建备份目录.备份将捕获所有的重要文件 
(包括任何内部或外部配置，库，脚本和文档)，但是它排除备份由于潜在规模库和日志. 
如果配置/库文件在现有安装文件夹的外部，则备份操作也将捕获这些文件. 

安装:

在安装 过程中，文件管理器将使用指定的Orchsym Studio二进制文件(tar.gz或zip文件) 
来创建新安装或将现有的Orchsym Studio安装迁移到新安装.  安装可任选地移动存储库(如果位于配置中 
当前安装的文件夹中)到新的安装以及迁移的配置文件来更新的安装. 

还原: 

还原操作允许现有安装还原为以前的安装.  使用现有备份目录(从备份操作创建) 
，FileManager实用程序将还原库，脚本和文档以及还原到以前的配置. NOTE: 如果由于安装
了较新版本的Orchsym Studio 而更改了存储库，则在恢复期间这些存储库 可能不再兼容.  在那种情况下排除 -m选项以确保将创建新的存储库，或者如果存储库 
位于Orchsym Studio目录之外，则删除它们以便在恢复后可以在启动时重新创建它们. 


[[clustering]] 
== 群集配置 

本节简要概述了Orchsym Studio群集以及有关如何设置基本群集的说明. 
在未来，我们希望提供涵盖Orchsym Studio集群架构的补充文档. 

image::zero-master-cluster-http-access.png["Orchsym Studio Cluster HTTP Access"] 

Orchsym Studio采用Zero-Master Clustering范例.集群中的每个节点对
数据执行相同的任务，但每个节点都在 不同的数据集上运行.其中一个节点自动选择(通过Apache 
ZooKeeper)作为集群协调器.然后，群集中的所有节点都会
向此节点发送心跳/状态信息 ，并且此节点负责断开
在一段时间内未报告任何心跳状态的节点 .此外，当新节点选择加入群集时，新节点必须首先 
连接到当前选定的群集协调器，以获取最新的流量.如果群集 
协调器确定允许该节点加入(基于其配置的防火墙文件)，则将当前 
流提供给该节点，并且该节点能够加入群集，假设该节点的
流副本与该节点 匹配由集群协调员提供的副本.如果节点的流配置版本与
群集协调器的版本不同 ，则该节点将不会加入群集. 

*为什么集群？* + 

Orchsym Studio管理员或数据流管理器(DFM)可能会发现在单个服务器上使用一个Orchsym Studio实例 
不足以处理他们拥有的数据量. 因此，一种解决方案是在多个Orchsym Studio服务器上运行相同的数据流. 
但是，这会产生管理问题，因为每次DFM想要更改或更新数据流时，他们必须
在每个服务器上进行 这些更改，然后单独监视每个服务器.通过集群Orchsym Studio服务器，可以 
增加处理能力以及单个接口，通过该接口可以更改数据流并监控 
数据流.群集允许DFM仅进行一次更改，然后将更改复制到
群集的所有节点 . 通过单一接口，DFM还可以监视所有节点的健康状况和状态. 

Orchsym Studio Clustering是独一无二的，有自己的术语. 在设置群集之前了解以下术语非常重要. 

[template="glossary", id="terminology"] 
*术语* + 

*Orchsym Studio集群协调员*:Orchsym Studio群集群集协调器是Orchsym Studio群集中的节点，负责执行 
任务以管理群集中允许的节点，并为新加入的节点提供最新流量.当 
DataFlow Manager管理群集中的数据流时，他们可以通过群集中任何节点的用户界面来执行此操作.
然后，所做的任何 更改都将复制到群集中的所有节点. 

*节点*:每个群集由一个或多个节点组成. 节点执行实际的数据处理. 

*主节点*:每个群集都有一个主节点. 在此节点上，可以运行"隔离组件”(见下文). 
ZooKeeper用于自动选择主节点.如果该节点由于任何原因断开与群集的连接，
则将自动选择新的 主节点.用户可以通过
查看用户界面的"群集管理”页面来确定当前选择哪个节点作为主节点 . 

*孤立的组件*:在Orchsym Studio群集中，相同的数据流在所有节点上运行.因此，流中的每个组件都在 
每个节点上运行. 但是，可能存在DFM不希望每个组件在每个节点上运行的情况.最 
常见的情况是使用的组件使用不能很好扩展的协议与外部服务进行通信. 
例如，GetSFTP组件从远程目录中提取，如果GetSFTP组件在
集群中的每个节点上运行 同时尝试从同一个远程目录中提取，则可能存在竞争条件.因此，DFM可以 
将主节点上的GetSFTP配置为独立运行，这意味着它只在该节点上运行. 它可以提取数据和 - 
使用正确的数据流配置 - 在集群中的其余节点上对其进行负载平衡.请注意，虽然
存在此 功能，但仅使用独立的Orchsym Studio实例来提取数据并将其提供给群集也很常见. 
它仅取决于可用资源以及管理员如何决定配置群集. 

*心跳*:节点通过"心跳”将其健康状况和状态传达给当前选定的群集协调器， 
这使协调器知道它们仍然连接到群集并正常工作.默认情况下，节点
每5秒发出 一次心跳，如果群集协调器在40秒内没有从节点收到心跳，则 
由于"缺乏心跳”而断开节点连接. (5秒钟的设置可配置在 _Orchsym Studio.properties_ 文件. 
有关更多信息，请参阅本文档的<<system_properties>>部分.)群集协调器 
断开节点的原因是协调器需要确保群集中的每个节点都处于同步状态，并且如果
没有定期听到节点，协调器无法确定它是否与其余节点 同步集群.如果在
40秒后 节点发送新的心跳，协调器将自动请求节点重新加入群集， 
以包括重新验证节点的流量. 
一旦接收到心跳，由于心跳不足导致的断开连接和重新连接都会报告给
用户界面中的DFM . 

*集群内的通信* + 

如上所述，节点通过心跳与集群协调器通信.当选择群集协调器时，它会
使用其连接信息更新 Apache ZooKeeper中众所周知的ZNode，以便节点了解发送心跳的位置.如果其中一个 
节点发生故障，则群集中的其他节点将不会自动获取丢失节点的负载.这是可能 
的DFM配置为故障转移突发数据流; 但是，这取决于数据流设计，并不会 
自动发生. 

当DFM对数据流进行更改时，接收更改流的请求的节点将这些更改传递给所有 
节点并等待每个节点响应，表明它已对其本地流进行了更改. 


*处理断开的节点* + 

DFM可以手动断开节点与群集的连接.但是，如果节点由于任何其他原因(例如由于缺乏心跳)而断开连接， 
则群集协调器将在用户界面上显示公告.在
解决断开连接节点的问题之前，DFM将无法对数据流进行任何更改 .DFM或管理员将需要解决节点的问题并在
对数据流进行任何新的更改之前解决它 .但是，值得注意的是，仅因为节点断开连接并不意味着它不起作用; 
这可能由于某些原因而发生，包括由于网络问题，节点无法与群集协调器通信. 

在某些情况下，DFM可能希望继续对流进行更改，即使节点未连接到群集也是如此. 
在这种情况下，DFM可以选择完全通过"群集管理”对话框从群集中删除节点.删除后，
在重新启动节点之前， 节点无法重新加入群集. 

*流动选举* + 
当群集首次启动时，Orchsym Studio必须确定哪个节点具有流的 
"正确”版本. 这是通过对每个节点具有的流进行投票来完成的.当节点 
尝试连接到群集时，它会将其本地流的副本提供给群集协调器.如果 
尚未选择流"正确”流，则将节点的流与每个其他节点进行比较' 流动.如果另一个 
节点的流与此节点匹配，则为此流投票.如果还没有其他节点报告相同的流，则此 
流将以一票投票的方式添加到可能选择的流池中.经过 
一段时间后(通过设置配置 `Orchsym Studio.cluster.flow.election.max.wait.time` 属性)或 
一些节点有投票(通过设置 `Orchsym Studio.cluster.flow.election.max.candidates` 属性)， 
流被当选为流动的"正确的”副本.然后，具有不兼容流的所有节点将
与群集断开连接，而具有兼容流的节点将 继承群集的流.选举是根据 
"普选投票”进行的，但需要注意的是，除非所有流动都是空的，否则获胜者永远不会是"空流”.这 
允许管理员删除节点 `flow.xml.gz` 文件并重新启动节点，知道节点的流将 
不会被投票为"正确”流，除非找不到其他流. 

*基本群集设置* + 

本节介绍由三个Orchsym Studio实例组成的简单三节点非安全集群的设置. 

对于每个实例，中的某些属性 _Orchsym Studio.properties_ 文件需要更新.特别是，
应根据您的情况评估Web和群集属性 并进行相应调整.所有属性都在本
指南的<<system_properties>>部分中描述 ; 但是，在本节中，我们将重点关注必须为简单集群设置的最小属性. 

对于所有三个实例，可以使用默认设置保留群集公共属性.但请注意，如果更改这些设置， 
则必须在群集中的每个实例上设置相同的设置. 

对于每个节点，要配置的最小属性如下: 

* 在下面 _Web Properties_ 部分，设置您希望节点运行的HTTP或HTTPS端口. 
  另外，请考虑是否需要设置HTTP或HTTPS主机属性. 群集中的所有节点都应使用相同的协议设置. 
* 在下面 _State Management section_，设置 `Orchsym Studio.state.management.provider.cluster` 属性 
  到群集状态提供程序的标识符.确保已在中
  配置了群集状态提供程序 _state-management.xml_ 文件. 有关更多信息，请参见<<state_providers>>. 
* 下 _Cluster Node_ 属性，设置如下: 
** Orchsym Studio.簇.是.节点 - 将此设置为 _true_. 
** Orchsym Studio.簇.节点.地址 - 将其设置为节点的标准主机名. 如果留空，则默认为"localhost”. 
** Orchsym Studio.簇.节点.协议.港口 - 将其设置为高于1024的开放端口(任何低端需要root). 
** Orchsym Studio.簇.节点.协议.线程 - 应该用于与群集中的其他节点通信的线程数.此属性 
   默认为10.线程池用于将请求复制到所有节点，并且 
   线程池的线程数永远不会少于此数量. 它会根据需要增长到最大值 `Orchsym Studio.cluster.node.protocol.max.threads` 
   属性. 
** Orchsym Studio.簇.节点.协议.最大.线程 - 应该用于与群集中其他节点通信的最大线程数.此属性 
默认为50. 线程池用于对所有节点的复制请求，并且线程池将具有由"...”配置的"核心”大小 
`Orchsym Studio.cluster.node.protocol.threads` 属性.但是，如有必要，线程池会将活动线程数增加到
此属性设置的限制 . 
** Orchsym Studio.动物园管理员.连.串 - 连接到Apache ZooKeeper所需的连接字符串.这是
   主机名:端口对的逗号分隔列表 . 例如，localhost:2181，localhost:2182，localhost:2183.这应该包含
   ZooKeeper仲裁中所有ZooKeeper 实例的列表 . 
** Orchsym Studio.动物园管理员.根.节点 - 应该在ZooKeeper中使用的根ZNode.ZooKeeper提供了一个类似目录的结构 
   来存储数据. 每个'目录' 在这种结构中称为ZNode.这表示
   应该用于存储数据的根ZNode或"目录” . 默认值为 _/root_.这对于正确设置很重要，因为
   Orchsym Studio实例尝试加入的集群 取决于它连接到哪个ZooKeeper实例以及
   指定的ZooKeeper根节点 . 
** Orchsym Studio.簇.流.选举.最大.等待.时间 - 指定在选择Flow作为"正确”流之前等待的时间量. 
   如果已投票的节点数等于该指定的数量 `Orchsym Studio.cluster.flow.election.max.candidates` 
   财产，集群不会等这么久. 默认值为 _5 mins_.需要注意的是时间只要一次投票开始 
   铸造. 
** Orchsym Studio.簇.流.选举.最大.候选人 - 指定群集中所需的节点数，以便提前 
   选择流.这允许群集中的节点避免在开始处理之前等待很长时间，如果我们
   至少达到 群集中的此数量的节点. 

现在，可以启动集群. 实例启动的顺序无关紧要.导航到
其中一个节点的URL， 用户界面应类似于以下内容: 

image:ncm.png["Clustered User Interface"] 

*故障排除* 

如果您遇到问题且群集无法按照说明运行，请调查Orchsym Studio-app.日志和Orchsym Studio用户.
节点上的日志 文件. 如果需要，您可以通过编辑conf / logback将日志记录级别更改为DEBUG.xml文件.具体来说， 
在以下行中设置level ="DEBUG”(而不是"INFO”): 


---- 
    <logger name="org.apache.Orchsym Studio.web.api.config" level="INFO" additivity="false"> 
        <appender-ref ref="USER_FILE"/> 
    </logger> 
---- 




[[state_management]] 
== 状态管理 

Orchsym Studio为组件，报告任务，控制器服务和框架本身提供了一种机制来保持状态.
例如，这 允许组件在重新启动Orchsym Studio后从其停止的位置恢复.此外，它允许 
组件存储一些信息，以便组件可以从
集群中的所有不同节点访问该信息 . 这允许一个节点拾取另一个节点停止的位置，或者在集群中的所有节点之间进行协调. 

[[state_providers]] 
=== 配置状态提供程序 
当组件决定存储或检索状态时，它通过提供"范围”来实现- 节点本地或群集范围.
然后，基于此Scope以及配置的状态
提供程序确定用于存储和检索此状态的 机制 . 该 _Orchsym Studio.properties_ file包含三个与配置这些State Providers相关的不同属性. 

|==== 
|*Property*|*描述* 
|Orchsym Studio.state.management.configuration.file|第一个是指定外部XML文件的属性，该文件用于配置本地和/或群集范围的状态提供程序. 此XML文件可能包含多个提供程序的配置 
|Orchsym Studio.state.management.provider.local|提供此XML文件中配置的本地State Provider标识符的属性 
|Orchsym Studio.state.management.provider.cluster|同样，该属性提供在此XML文件中配置的群集范围的State Provider的标识符. 
|==== 

此XML文件由顶级文件组成 `state-management` 元素，有一个或多个 `local-provider` 和零或更多 `cluster-provider` 
分子. 这些元素中的每一个都包含一个 `id` 用于指定可在其中引用的标识符的元素 
_Orchsym Studio.properties_ 文件，以及 `class` element，指定要用于实例化State 
Provider 的完全限定类名 . 最后，这些元素中的每一个可以具有零或更多 `property` 分子. 每 `property` element有一个属性， `name` 这是名称 
的 `property` 国家提供者支持. property元素的文本内容是属性的值. 

一旦这些状态提供者配置了 _state-management.xml_ 文件(或配置的任何文件)，这些提供者可能被 
其标识符引用. 

默认情况下，本地状态提供程序配置为a `WriteAheadLocalStateProvider` 将数据持久化到 
_$Orchsym Studio_HOME / state / local_目录. 默认的群集状态提供程序配置为a `ZooKeeperStateProvider`.默认 
的基于ZooKeeper的提供程序必须具有它 `Connect String` 在可以使用之前填充的属性.如果多个Orchsym Studio实例
将使用相同的ZooKeeper实例，那么它的值也是可取 的 `Root Node` 财产被改变. 例如，可以将值设置为 
`/Orchsym Studio/<team name>/production`. 一个 `Connect String` 采用逗号分隔的<host>:<port>元组的形式，例如 
my-zk-server1:2181，my-zk-server2:2181，my-zk-server3:2181.如果没有为任何主机指定端口，
则假定ZooKeeper默认为 2181. 

向ZooKeeper添加数据时，Access Control有两个选项: `Open` 和 `CreatorOnly`. 如果 `Access Control` 属性 
设置为 `Open`，然后允许任何人登录ZooKeeper并拥有查看，更改，删除或管理数据的完全权限. 
如果 `CreatorOnly` 如果已指定，则只允许创建数据的用户读取，更改，删除或管理数据. 
为了使用 `CreatorOnly` 选项，Orchsym Studio必须提供某种形式的身份验证. 见<<zk_access_
有关如何配置身份验证的详细信息，请参阅下面的">> . 

如果Orchsym Studio配置为在独立模式下运行，则 `cluster-provider` 元素不需要填充 _state-management.xml_ 
文件，如果填充它们，实际上将被忽略. 但是，那 `local-provider` 元素必须始终存在并填充. 
此外，如果Orchsym Studio在群集中运行，则每个节点也必须具有 `cluster-provider` 元素存在并正确配置. 
否则，Orchsym Studio将无法启动. 

虽然没有多少属性需要为这些提供程序配置，但它们被外部化为单独的 _state-management.xml_ 
文件，而不是通过 _Orchsym Studio.properties_ 文件，只是因为不同的实现可能需要不同的属性， 
并且更容易维护和理解基于XML的文件中的配置，而不是将Provider的属性
与所有其他Orchsym Studio框架特定的属性混合在一起 . 

应该注意的是，如果组件和其他组件使用"集群”作用域保存状态，则
如果实例是独立实例(不在集群中)或与集群断开连接，则将使用本地状态提供程序 .这也意味着，如果一个独立实例 
迁移成为一个集群，那么国家将不再可用，因为该组件将开始使用集群状态，供应商 
，而不是地方国家提供的. 


[[embedded_zookeeper]] 
=== 嵌入式ZooKeeper服务器 
如上所述，群集范围状态的默认状态提供程序是 `ZooKeeperStateProvider`.在撰写本文时，这是 
唯一存在用于处理群集范围状态的状态提供程序.这意味着Orchsym Studio依赖于ZooKeeper以 
表现为集群. 但是，有许多环境可以在没有维护现有ZooKeeper集合的地方部署Orchsym Studio. 
为了避免强迫管理员维护单独的ZooKeeper实例的负担，Orchsym Studio提供了启动
嵌入式ZooKeeper服务器的选项 . 

|==== 
|*Property*|*描述* 
|Orchsym Studio.state.management.embedded.zookeeper.start|指定此Orchsym Studio实例是否应运行嵌入式ZooKeeper服务器 
|Orchsym Studio.state.management.embedded.zookeeper.properties|提供要使用的ZooKeeper属性的属性文件 `Orchsym Studio.state.management.embedded.zookeeper.start` 设置为true 
|==== 

这可以通过设置来完成 `Orchsym Studio.state.management.embedded.zookeeper.start` 物业 _Orchsym Studio.properties_ 至 `true` 在那些
应该运行嵌入式ZooKeeper服务器的节点 上. 通常，建议在3或5个节点上运行ZooKeeper.在少于3个节点上运行在 
面对故障时提供较低的耐久性. 在超过5个节点上运行通常会产生比必要更多的网络流量.此外， 
在4个节点上运行ZooKeeper没有比在3个节点上运行更多的好处，ZooKeeper需要大多数节点处于活动状态才能运行. 
但是，由管理员决定最适合Orchsym Studio特定部署的节点数. 

如果 `Orchsym Studio.state.management.embedded.zookeeper.start` 属性设置为 `true`， `Orchsym Studio.state.management.embedded.zookeeper.properties` 物业 
在 _Orchsym Studio.properties_ 也变得相关. 这指定要使用的ZooKeeper属性文件.此属性文件至少需要填充 
ZooKeeper服务器列表. 服务器以。的形式指定为属性 `server.1`， `server.2`， 至 `server.n`.每个服务器都 
配置为<hostname>:<quorum port>[:<leader election port>]. 例如， `myhost:2888:3888`.此节点列表应该是Orchsym Studio 
群集中具有相同节点的节点 `Orchsym Studio.state.management.embedded.zookeeper.start` 属性设置为 `true`.另请注意，由于ZooKeeper将侦听这些 
端口，因此可能需要配置防火墙以打开这些端口以用于传入流量，至少在群集中的节点之间.此外，
必须在防火墙中打开侦听客户端连接的端口 . 这个的默认值是 _2181_ 但可以通过 _clientPort_ 物业 
在 _zookeeper.properties_ 文件. 

当使用嵌入式ZooKeeper时， ./__CONF /饲养员.性能__ file有一个名为的属性 `dataDir`. 默认情况下，此值设置为 `./state/zookeeper`. 
如果多个Orchsym Studio节点正在运行嵌入式ZooKeeper，则告诉服务器它是哪一个非常重要. 这是通过创建一个名为的文件来完成的 
_myid_ 并将其放在ZooKeeper的数据目录中. 此文件的内容应该是特定于服务器的索引 `server.<number>`.因此，对于 
其中一个ZooKeeper服务器，我们将通过执行以下命令来实现此目的: 

[source] 
cd $ Orchsym Studio_HOME 
mkdir state 
mkdir state / zookeeper 
echo 1> state / zookeeper / myid 

对于将运行ZooKeeper的下一个Orchsym Studio节点，我们可以通过执行以下命令来完成此任务: 

[source] 
cd $ Orchsym Studio_HOME 
mkdir state 
mkdir state / zookeeper 
echo 2> state / zookeeper / myid 

等等. 

有关用于管理ZooKeeper的属性的更多信息，请参阅 
link:https://zookeeper.apache.org/doc/current/zookeeperAdmin.html[ZooKeeper Admin Guide^]. 

有关保护嵌入式ZooKeeper服务器的信息，请参阅下面的"secured_zookeeper”部分. 



[[zk_access_control]] 
=== ZooKeeper访问控制 
ZooKeeper通过访问控制列表(ACL)机制为其数据提供访问控制.当数据写入ZooKeeper时，Orchsym Studio将提供一个ACL 
，指示允许任何用户拥有对数据的完全权限，或提供一个ACL，指示只
允许创建数据的用户 访问数据. 使用哪个ACL取决于的值 `Access Control` 财产 `ZooKeeperStateProvider`(
有关更多信息，请参阅 <<state_providers>>部分). 

为了使用指示只允许Creator访问数据的ACL，我们需要告诉ZooKeeper创建者是谁.有两种 
机制可以实现这一目标. 第一种机制是使用Kerberos提供身份验证. 见<<zk_kerberos_客户>>了解更多信息. 

第二个选项是使用用户名和密码. 这是通过指定的值来配置的 `Username` 和一个值 `Password` 性质 
为 `ZooKeeperStateProvider` (有关更多信息，请参阅<<state_providers>>部分).但是，要记住的重要一点是，ZooKeeper 
将以纯文本传递密码.这意味着不应使用用户名和密码，除非ZooKeeper在localhost上作为 
单实例集群运行，或者与ZooKeeper的通信仅通过加密通信(例如VPN或SSL连接)发生.ZooKeeper将 
在版本3中为SSL连接提供支持.五.0. 



[[securing_zookeeper]] 
=== 保护ZooKeeper 
当Orchsym Studio与ZooKeeper通信时，默认情况下所有通信都是不安全的，登录ZooKeeper的任何人都能够查看和操作
存储在ZooKeeper中的所有 Orchsym Studio状态. 为了防止这种情况，我们可以使用Kerberos来管理身份验证.目前，ZooKeeper不 
支持通过SSL加密. 正在积极开发对ZooKeeper中的SSL的支持，预计将在3中提供.五.x发布版本. 

为了保护通信安全，我们需要确保客户端和服务器都支持相同的配置.下面提供了配置 
Orchsym Studio ZooKeeper客户端和嵌入式ZooKeeper服务器以使用Kerberos的说明. 

如果您的环境中尚未设置Kerberos，则可以在
https://访问时找到有关安装和设置Kerberos服务器的信息 .红帽.COM /文档/ EN-US /红_Hat_企业_Linux/6/html/Managing_聪明_Cards/Configuring_一个_Kerberos_5_Server.HTML[Red Hat Customer Portal: Configuring a Kerberos 5 Server]. 本指南假定Kerberos已经安装在运行Orchsym Studio的环境中. 

请注意，在Orchsym Studio节点中对嵌入式ZooKeeper服务器进行kerberizing并对ZooKeeper Orchsym Studio客户端进行kerber化的以下过程将要求 
安装Kerberos客户端库. 这是通过以下方式在基于Fedora的Linux发行版中完成的: 

[source] 
yum install krb5-workstation 

一旦完成，/ etc / krb5.需要为您组织的Kerberos环境正确配置conf. 



[[zk_kerberos_server]] 
==== Kerberizing嵌入式ZooKeeper服务器 
krb5.具有嵌入式zookeeper服务器的系统上的conf文件应与运行krb5kdc服务的系统上的conf文件相同. 
使用嵌入式ZooKeeper服务器时，我们可能会选择使用Kerberos来保护服务器.配置为启动嵌入式ZooKeeper并
使用Kerberos的所有节点 都应遵循以下步骤. 使用嵌入式ZooKeeper服务器时，我们可能会选择使用Kerberos来保护服务器.
配置为启动嵌入式ZooKeeper并使用Kerberos的所有节点 都应遵循以下步骤. 

为了使用Kerberos，我们首先需要为ZooKeeper服务器生成Kerberos Principal.以下命令在运行
krb5kdc服务的服务器上 运行. 这是通过kadmin工具完成的: 

[source] 
kadmin:addprinc"zookeeper / myHost.例.COM @实例.COM" 

在这里，我们正在创建一个主要的主体 `zookeeper/myHost.example.com`，使用领域 `EXAMPLE.COM`.我们需要使用
名字为的Principal `<service name>/<instance name>`. 在这种情况下，服务是 `zookeeper` 而实例名称是 `myHost.example.com` (我们主机的完全限定名称). 

接下来，我们需要为此Principal创建一个KeyTab，此命令在具有嵌入式zookeeper服务器的Orchsym Studio实例的服务器上运行: 

[source] 
kadmin:xst -k zookeeper-server.keytab zookeeper / myHost.例.COM @实例.COM 

这将在当前目录中创建一个名为的文件 `zookeeper-server.keytab`. 我们现在可以将该文件复制到 `$Orchsym Studio_HOME/conf/` 目录.我们应该确保 
只允许运行Orchsym Studio的用户读取该文件. 

我们需要为将要运行嵌入式ZooKeeper服务器的每个Orchsym Studio实例重复上述步骤，确保更换 _myHost.example.com_ 同 
__myHost2.例.COM__或者运行ZooKeeper服务器的任何完全限定的主机名. 

既然我们已经为每个运行Orchsym Studio的服务器配备了KeyTab，我们需要配置Orchsym Studio的嵌入式ZooKeeper服务器来使用这个配置. 
ZooKeeper使用Java身份验证和授权服务(JAAS)，因此我们需要创建一个与JAAS兼容的文件 `$Orchsym Studio_HOME/conf/` 目录，创建一个
名为的文件 `zookeeper-jaas.conf` (如果客户端已配置为通过Kerberos进行身份验证，则此文件已存在. 没关系，只需添加到文件中). 
我们将添加到此文件中，以下代码段: 

[source] 
服务器{ 
  com.太阳.安全.AUTH.模.Krb5LoginModule需要 
  useKeyTab = true 
  keyTab ="./ conf目录/饲养员服务器.keytab" 
  storeKey = true 
  useTicketCache = false 
  principal =”zookeeper / myHost.例.COM @实例.COM"; 
}; 

请务必替换值 _principal_ 上面有适当的Principal，包括服务器的完全限定域名. 

接下来，我们需要告诉Orchsym Studio将其用作JAAS配置. 这是通过设置JVM系统属性来完成的，因此我们将编辑 `conf/bootstrap.conf` 文件. 
如果客户端已配置为使用Kerberos，则无需执行此操作，如上所述. 否则，我们将向我们添加以下行 _bootstrap.conf_ 文件: 

[source] 
java的.ARG.15 = -Djava.安全.AUTH.登录.配置=./ CONF /动物园管理员-JAAS.conf 

注意:文件中的这一附加行不必是数字15，它只需要添加到引导程序中.conf文件，使用适合您的配置的任何数字. 

我们希望通过运行以下命令来初始化我们的Kerberos票证: 

[source] 
kinit -kt zookeeper-server.keytab"zookeeper / myHost.例.COM @实例.COM" 

同样，请务必使用适当的值替换Principal，包括您的领域和完全限定的主机名. 

最后，我们需要告诉Kerberos服务器使用SASL身份验证提供程序. 为此，我们编辑了 `$Orchsym Studio_HOME/conf/zookeeper.properties` 文件并添加以下 
行: 

[source] 
authProvider.1 =有机.阿帕奇.动物园管理员.服务器.AUTH.SASLAuthenticationProvider 
kerberos.removeHostFromPrincipal = true 
kerberos.removeRealmFromPrincipal = true 
jaasLoginRenew = 3600000 
requireClientAuthScheme = sasl 

kerberos.removeHostFromPrincipal和kerberos.removeRealmFromPrincipal属性用于在将标识与
应用于Znode的acl 进行比较之前规范化用户主体名称 .  默认情况下使用完整主体但是将removeHostFromPrincipal和removeRealmFromPrincipal kerberos属性设置为true将指示 
Zookeeper从登录用户的标识中删除主机和域以进行比较.  如果Orchsym Studio节点(在同一群集内)使用
具有不同主机/域值的主体， 则可以配置这些kerberos属性以确保节点' 身份将被规范化，并且节点将具有 
对Zookeeper中共享的Znodes的适当访问权限. 

最后一行是可选的，但指定客户端必须使用Kerberos与我们的ZooKeeper实例进行通信. 

现在，我们可以启动Orchsym Studio，嵌入式ZooKeeper服务器将使用Kerberos作为身份验证机制. 



[[zk_kerberos_client]] 
==== Kerberizing Orchsym Studio的动物园管理员客户端 
注:Orchsym Studio节点上运行的嵌入式服务器动物园管理员还需要按照以下步骤操作，因为他们也将在作为客户端 
的同时. 

使用ZooKeeper验证用户的首选机制是使用Kerberos.为了使用Kerberos进行身份验证，我们必须配置一些 
系统属性，以便ZooKeeper客户端知道用户是谁以及KeyTab文件的位置.所有节点被配置为存储群集范围状态 
使用 `ZooKeeperStateProvider` 并使用Kerberos应遵循这些步骤. 

首先，我们必须创建在与ZooKeeper通信时使用的Principal. 这通常是通过 `kadmin` 工具: 

[source] 
kadmin:addprinc"Orchsym Studio @ EXAMPLE.COM" 

Kerberos Principal由三部分组成:主要部分，实例和领域. 在这里，我们正在创建一个主要的Principal `Orchsym Studio`， 
没有实例和领域 `EXAMPLE.COM`. 首要的 (`Orchsym Studio`在这种情况下)是用于在
通过Kerberos进行身份验证时识别用户的标识符 . 

在我们创建了Principal后，我们需要为Principal创建一个KeyTab: 

[source] 
kadmin:xst -k Orchsym Studio.keytab Orchsym Studio @ EXAMPLE.COM 

此密钥表文件可以复制到具有嵌入式zookeeper服务器的其他Orchsym Studio节点. 

这将在当前目录中创建一个名为的文件 `Orchsym Studio.keytab`. 我们现在可以将该文件复制到 _$Orchsym Studio_HOME / conf / _目录.我们应该确保 
只允许运行Orchsym Studio的用户读取该文件. 

接下来，我们需要配置Orchsym Studio以使用此KeyTab进行身份验证.由于ZooKeeper使用Java身份验证和授权服务(JAAS)，我们需要 
创建一个与JAAS兼容的文件. 在里面 `$Orchsym Studio_HOME/conf/` 目录，创建一个名为的文件 `zookeeper-jaas.conf` 并添加以下代码段: 

[source] 
客户{ 
  com.太阳.安全.AUTH.模.Krb5LoginModule需要 
  useKeyTab = true 
  keyTab ="./ conf目录/ Orchsym Studio.keytab" 
  storeKey = true 
  useTicketCache = false 
  principal =”Orchsym Studio @ EXAMPLE.COM"; 
}; 


然后我们需要告诉Orchsym Studio使用它作为我们的JAAS配置. 这是通过设置JVM系统属性来完成的，因此我们将编辑 _conf/bootstrap.conf_ 文件. 
我们在此文件中的任何位置添加以下行，以告知Orchsym Studio JVM使用此配置: 

[source] 
java的.ARG.15 = -Djava.安全.AUTH.登录.配置=./ CONF /动物园管理员-JAAS.CONF 

最后，我们需要更新 `Orchsym Studio.properties` 为了确保Orchsym Studio知道为Znodes应用SASL特定的ACL，它将在Zookeeper中创建以进行集群管理. 
要启用此功能，请执行此操作 `$Orchsym Studio_HOME/conf/Orchsym Studio.properties` 文件并编辑以下属性，如下所示: 

[source] 
Orchsym Studio.动物园管理员.AUTH.type = sasl 
Orchsym Studio.动物园管理员.Kerberos的.removeHostFromPrincipal = true 
Orchsym Studio.动物园管理员.Kerberos的.removeRealmFromPrincipal = true 

注意:kerberos.removeHostFromPrincipal和kerberos.removeRealmFromPrincipal应与Zookeeper配置中设置的一致. 

我们可以通过运行以下命令来初始化我们的Kerberos票证: 

[source] 
使用kinit -kt Orchsym Studio.keytab Orchsym Studio @ EXAMPLE.COM 

现在，当我们启动Orchsym Studio时，它将使用Kerberos进行身份验证 `Orchsym Studio` 用户与ZooKeeper通信时. 



[[troubleshooting_kerberos]] 
==== Kerberos配置故障排除 
使用Kerberos时，导入使用完全限定的域名而不使用 _localhost_.请确保
在以下位置使用每个服务器的完全限定主机名 : 

- _conf/zookeeper.properties_ 文件应该使用FQDN `server.1`， `server.2`， ...， `server.N` 值. 
- 该 `Connect String` ZooKeeperStateProvider的属性 
- / etc / hosts文件还应将FQDN解析为IP地址 *不* _127.0.0.1_. 

如果不这样做，可能会导致类似以下的错误: 

[source] 
2016-01-08 16:08:57,588错误 [pool-26-thread-1-SendThread(localhost:2181)] Ø.一个.动物园管理员.客户.ZooKeeperSaslClient一个错误:(java.安全.PrivilegedActionException:javax.安全.SASL.SaslException:GSS启动失败 [Caused by GSSException: No valid credentials provided (Mechanism level: Server not found in Kerberos database (7) - LOOKING_UP_SERVER)])在评估Zookeeper Quorum Member收到的SASL令牌时发生. Zookeeper Client将进入AUTH_FAILED状态. 

如果在使用Kerberos进行通信或身份验证时出现问题，请执行此操作 
link:http://docs.oracle.com/javase/7/docs/technotes/guides/security/jgss/tutorials/Troubleshooting.html[Troubleshooting Guide^] 可能是有价值的. 

上述故障排除指南中最重要的注意事项之一是为Kerberos启用调试输出的机制. 
这是通过设置 `sun.security.krb5.debug` 环境变量. 
在Orchsym Studio中，这可以通过添加以下行来实现 _$Orchsym Studio_HOME / conf目录/引导.conf_文件: 

[source] 
java的.ARG.16 = -Dsun.安全.KRB5.debug = true 

这将导致调试输出写入Orchsym Studio Bootstrap日志文件. 默认情况下，它位于 _$Orchsym Studio_HOME /日志/ Orchsym Studio自举.LOG_. 
此输出可能相当冗长，但为解决Kerberos故障提供了非常有价值的信息. 

[[zookeeper_migrator]] 
=== ZooKeeper Migrator 
您可以使用Orchsym Studio ZooKeeper Migrator执行以下任务: 

* 将ZooKeeper信息从一个ZooKeeper集群移动到另一个集群 
*迁移ZooKeeper节点所有权 

例如，您可能希望在以下情况下使用ZooKeeper Migrator: 

* 从Orchsym Studio升级0.x到Orchsym Studio 1.x使用嵌入式ZooKeeper 
* 从Orchsym Studio 0中的嵌入式ZooKeeper迁移.x或1.x到外部ZooKeeper 
* 从Orchsym Studio升级0.x带外部ZooKeeper到Orchsym Studio 1.x使用相同的外部ZooKeeper 
* 从外部ZooKeeper迁移到Orchsym Studio 1中的嵌入式ZooKeeper.x 

Orchsym Studio ZooKeeper Migrator是Orchsym Studio工具包的一部分，可以单独下载 
link:https://Orchsym Studio.apache.org/download.html[Orchsym Studio download page^]. 

[[zk_migrator_command_line_parameters]] 
==== ZK-迁移.sh命令行参数 

您可以将以下命令行选项与ZooKeeper Migrator一起使用: 

* `-a`，`--auth <username:password>`               允许指定用于使用ZooKeeper进行身份验证的用户名和密码.  此选项与 `-k`，`--krb-conf` 选项. 
* `-f`，`--file <filename>`                        用于ZooKeeper数据的文件序列化为JSON.  与...一起使用时 `-r`，`--receive` 选项，从ZooKeeper读取的数据将存储在给定的文件名中.  与...一起使用时 `-s`，`--send` 选项，文件中的数据将被发送到ZooKeeper. 
* `-h`，`--help`                                   打印帮助，显示可用参数和说明 
* `--ignore-source`                               允许ZooKeeper Migrator写入ZooKeeper和从中获取数据的路径. 
* `-k`，`--krb-conf <jaas-filename>`               允许指定JAAS配置文件以允许使用配置为使用Kerberos的ZooKeeper进行身份验证.  此选项与 `-a`，`--auth` 选项. 
* `-r`，`--receive`                                从ZooKeeper接收数据并写入给定的文件名(如果是 `-f`，`--file` 提供选项)或标准输出. 收到的数据将包含从ZooKeeper读取的每个节点的完整路径. 此选项与 `-s`，`--send` 选项. 
* `-s`，`--send`                                   将数据发送到从给定文件名读取的ZooKeeper(如果是 `-f`，`--file` 提供选项)或标准输入. 发送到ZooKeeper的数据中每个节点的路径都是绝对路径，并将存储在ZooKeeper下的 *路径* 的一部分 `-z`，`--zookeeper` 论据.  通常， *路径* 参数的一部分可以省略，它将节点存储在它们的绝对路径上. 此选项与 `-r`，`--receive` 选项. 
* `--use-existing-acl`                            允许Zookeeper Migrator将从源Zookeeper服务器检索到的ACL值写入目标服务器. 默认操作将应用未安全目标的打开权限或安全目标的仅创建者权限. 
* `-z`，`--zookeeper <zookeeper-endpoint>`         要使用的ZooKeeper服务器，由连接字符串指定，由一个或多个逗号分隔的主机:端口对组成，后跟路径，格式为 _host:port[,host2:port...,hostn:port]/znode/path_. 

[[migrating_between_source_destination_zookeepers]] 
==== 在源和目标ZooKeepers之间迁移在 

开始之前，请确认: 

* 您已安装目标ZooKeeper集群. 
* 您已安装并配置了Orchsym Studio群集以使用目标ZooKeeper群集. 
* 如果由于从0升级Orchsym Studio而迁移ZooKeepers.x到1.x ,,您已经遵循了适当的Orchsym Studio升级步骤. 
* 您已根据需要配置了Kerberos. 
* 您尚未开始处理任何数据流(以避免重复数据处理). 
* 如果您使用的其中一个ZooKeeper集群配置了Kerberos，则您从可以访问Orchsym Studio的ZooKeeper客户端jaas配置文件的主机上运行ZooKeeper Migrator(请参阅<<zk_kerberos_客户>>了解更多信息). 

===== ZooKeeper迁移步骤 

1.收集以下信息: 
+ 
|==== 
|*Required Information*|*描述* 
|Source ZooKeeper hostname (*sourceHostname*)|主机名必须是ZooKeeper集合中运行的主机之一，可以在<Orchsym Studio installation dir> / conf / zookeeper中找到.性能.  在中声明的任何主机名 *服务器.ñ* 属性可以使用. 
|Destination ZooKeeper hostname (*destinationHostname*)|主机名必须是ZooKeeper集合中运行的主机之一，可以在<Orchsym Studio installation dir> / conf / zookeeper中找到.性能.  在中声明的任何主机名 *服务器.ñ* 属性可以使用. 
|Source ZooKeeper port (*sourceClientPort*)|这可以在 *动物园管理员.性能* 的<Orchsym Studio安装目录> / conf / zookeeper.性能.  端口在。中指定 *CLIENTPORT* 属性. 
|Destination ZooKeeper port (*destinationClientPort*)|这可以在 *动物园管理员.性能* 的<Orchsym Studio安装目录> / conf / zookeeper.性能.  端口在。中指定 *CLIENTPORT* 属性. 
|Export data path|确定将存储包含ZooKeeper数据导出的json文件的路径.  它必须是运行zk-migrator工具的用户可读写的. 
|Source ZooKeeper Authentication Information|此信息位于<Orchsym Studio安装目录> / conf / state-management中.XML. 对于Orchsym Studio 0.x，如果在状态管理中指定了仅创建者.xml，您需要使用提供身份验证信息 `-a,--auth` 带有来自状态管理中"用户名”和"密码”属性的值的参数.XML. 对于Orchsym Studio 1.x，使用提供认证信息 `-k,--krb-conf` 论据. 
+ 
如果是国家管理.xml指定Open，不需要身份验证. 
|Destination ZooKeeper Authentication Information|此信息位于<Orchsym Studio安装目录> / conf / state-management中.XML. 对于Orchsym Studio 0.x，如果在状态管理中指定了仅创建者.xml，您需要使用提供身份验证信息 `-a,--auth` 带有来自状态管理中"用户名”和"密码”属性的值的参数.XML. 对于Orchsym Studio 1.x，使用提供认证信息 `-k,--krb-conf` 论据. 
+ 
如果是国家管理.xml指定Open，不需要身份验证. 
|Root path to which Orchsym Studio writes data in Source ZooKeeper (*sourceRootPath*)|此信息可在<Orchsym Studio安装目录> / conf / state-management中找到.cluster-provider元素中Root节点属性下的xml. (默认:/ Orchsym Studio) 
|Root path to which Orchsym Studio writes data in Destination ZooKeeper (*destinationRootPath*)|此信息可在<Orchsym Studio安装目录> / conf / state-management中找到.cluster-provider元素中Root节点属性下的xml. 
|==== 
2. 停止Orchsym Studio流程中的所有组件.  如果要在两个Orchsym Studio安装之间进行迁移，则必须停止两者上的流量. 
3. 从源ZooKeeper导出Orchsym Studio组件数据.  以下命令使用提供的数据路径从指定的hostname:port上运行的指定ZooKeeper读取，并使用给定的用户名和密码对ZooKeeper进行身份验证.  从ZooKeeper读取的数据将写入提供的文件. 

* 对于Orchsym Studio 0.X 
** 对于开放的ZooKeeper: 
*** ZK-迁移.SH -[R -ž *sourceHostname:sourceClientPort*/*sourceRootPath*/组件 -F /*路径*/*至*/*出口*/*ZK-源数据.JSON* 
** 对于使用username:password进行身份验证的ZooKeeper: 
*** ZK-迁移.SH -[R -ž *sourceHostname:sourceClientPort*/*sourceRootPath*/组件 -一个<用户名:密码> -F /*路径*/*至*/*出口*/*ZK-源数据.JSON* 
* 对于Orchsym Studio 1.X 
** 对于开放的ZooKeeper: 
*** ZK-迁移.SH -[R -ž *sourceHostname:sourceClientPort*/*sourceRootPath*/组件 -F /*路径*/*至*/*出口*/*ZK-源数据.JSON* 
** 对于使用Kerberos进行身份验证的ZooKeeper: 
*** ZK-迁移.SH -[R -ž *sourceHostname:sourceClientPort*/*sourceRootPath*/组件 -k /*路径*/*至*/*jaasconfig*/*JAAS的配置.CONF* -F /*路径*/*至*/*出口*/*ZK-源数据.JSON* 

4. (可选)如果您已使用新的Orchsym Studio安装进行任何处理，您还可以在执行迁移之前将其ZooKeeper数据导出为备份. 

* 对于开放的ZooKeeper: 
** ZK-迁移.SH -[R -ž *destinationHostname:destinationClientPort*/*destinationRootPath*/组件 -F /*路径*/*至*/*出口*/*ZK-目的地备份数据.JSON* 
* 对于使用Kerberos进行身份验证的ZooKeeper: 
** ZK-迁移.SH -[R -ž *destinationHostname:destinationClientPort*/*destinationRootPath*/组件 -k /*路径*/*至*/*jaasconfig*/*JAAS的配置.CONF* -F /*路径*/*至*/*出口*/*ZK-目的地备份数据.JSON* 

五. 将ZooKeeper数据迁移到目标ZooKeeper. 如果源和目的ZooKeepers是相同的，那么 `--ignore-source` 选项可以添加到以下示例中. 

* 对于开放的ZooKeeper: 
** ZK-迁移.SH -小号 -ž *destinationHostname:destinationClientPort*/*destinationRootPath*/组件 -F /*路径*/*至*/*出口*/*ZK-源数据.JSON* 
* 对于使用Kerberos进行身份验证的ZooKeeper: 
** ZK-迁移.SH -小号 -ž *destinationHostname:destinationClientPort*/*destinationRootPath*/组件 -k /*路径*/*至*/*jaasconfig*/*JAAS的配置.CONF* -F /*路径*/*至*/*出口*/*ZK-源数据.JSON* 

6. 迁移成功完成后，启动Orchsym Studio流程中的组件.  当Orchsym Studio流停止时，处理应从停止时开始. 

[[bootstrap_properties]] 
== 引导属性 
的 _bootstrap.conf_ 文件中 _conf_ 目录允许用户配置Orchsym Studio应该如何启动的设置. 
这包括参数，例如Java堆的大小，要运行的Java命令以及Java系统属性. 

在这里，我们将解决文件中可用的不同属性.
只有在停止并重新启动Orchsym Studio后，对此文件的任何更改 才会生效. 

|==== 
|*Property*|*描述* 
|java|指定要运行的完全限定的java命令. 默认情况下，它很简单 `java` 但可以更改为绝对路径或引用环境变量，例如 `$JAVA_HOME/bin/java` 
|run.as|运行Orchsym Studio的用户名为. 例如，如果Orchsym Studio应该作为'Orchsym Studio运行' 用户，将此值设置为'Orchsym Studio' 将使Orchsym Studio Process作为'Orchsym Studio'运行' 用户. 
        在Windows上忽略此属性. 对于Linux，指定的用户可能需要sudo权限. 
|lib.dir|该 _lib_ 用于Orchsym Studio的目录. 默认情况下，此设置为 `./lib` 
|conf.dir|该 _conf_ 用于Orchsym Studio的目录. 默认情况下，此设置为 `./conf` 
|graceful.shutdown.seconds|当Orchsym Studio被指示关闭时，Bootstrap将等待这个秒数，以使该过程干净地关闭.在这段时间内， 
                           如果服务仍在运行，Bootstrap将"终止”该进程，或者突然终止该进程. 
|java.arg.N|启动进程时，可以将任意数量的JVM参数传递给Orchsym Studio JVM. 这些参数是通过添加属性来定义的 _bootstrap.conf_ 以... 
            开头 `java.arg.`. 除了不同的属性名称之外，属性名称的其余部分不相关，将被忽略.默认值包括 
            最小和最大Java堆大小的属性，要使用的垃圾收集器等. 
|notification.services.file|当Orchsym Studio启动或停止，或当Bootstrap检测到Orchsym Studio已经死亡时，Bootstrap能够
                            向感兴趣的各方发送这些事件的通知 . 这是通过指定定义可以使用哪些通知服务的XML文件来配置的.有关此
                            文件的更多信息，请 参见<<notification_services>>部分. 
|notification.max.attempts|如果配置了通知服务但无法执行其功能，它将再次尝试最多尝试次数.此属性 
                           配置最大尝试次数. 默认值为 `5`. 
|Orchsym Studio.start.notification.services|此属性是逗号分隔的通知服务标识符列表，对应于中
                                  定义的通知服务 `notification.services.file` 属性.具有指定标识符的服务将用于在
                                  启动Orchsym Studio时通知其 配置的收件人. 
|Orchsym Studio.stop.notification.services|此属性是逗号分隔的通知服务标识符列表，对应于中
                                 定义的通知服务 `notification.services.file` 属性.
                                 每当Orchsym Studio停止时，具有指定标识符的服务将用于通知其 配置的收件人. 
|Orchsym Studio.died.notification.services|此属性是逗号分隔的通知服务标识符列表，对应于中
                                 定义的通知服务 `notification.services.file` 属性.
                                 如果引导程序确定Orchsym Studio意外死亡，则具有指定标识符的服务将用于通知其 配置的收件人. 
|==== 

[[notification_services]] 
== 通知服务 
当Orchsym Studio引导程序启动或停止Orchsym Studio，或检测到它已意外死亡时，它能够通知已配置的收件人.目前，提供 
的唯一机制是发送电子邮件或HTTP POST通知.通知服务配置文件 
是一个XML文件，其中配置了通知功能. 

XML文件的默认位置是 _conf/bootstrap-notification-services.xml_，但这个值可以改变 _conf/bootstrap.conf_ 文件. 

XML文件的语法如下: 


.... 
<services> 
    <!-- any number of service elements can be defined. --> 
    <service> 
        <id>some-identifier</id> 
        <!-- The fully-qualified class name of the Notification Service. --> 
        <class>org.apache.Orchsym Studio.bootstrap.notification.email.EmailNotificationService</class> 

        <!-- Any number of properties can be set using this syntax. 
             The properties available depend on the Notification Service. --> 
        <property name="Property Name 1">Property Value</property> 
        <property name="Another Property Name">Property Value 2</property> 
    </service> 
</services> 
.... 


一旦配置了所需的服务，就可以在中引用它们 _bootstrap.conf_ 文件. 

=== 电子邮件通知服务 + 

第一个通告程序是发送电子邮件，实现是 `org.apache.Orchsym Studio.bootstrap.notification.email.EmailNotificationService`. 
它具有以下属性: 

|==== 
|*Property*|*需要*|*描述* 
|SMTP Hostname|true |用于发送电子邮件通知的SMTP服务器的主机名 
|SMTP Port|true |用于SMTP通信的端口 
|SMTP Username|true | SMTP帐户的用户名 
|SMTP Password|| SMTP帐户的密码 
|SMTP Auth||指示是否应使用身份验证的标志 
|SMTP TLS||指示是否应启用TLS的标志 
|SMTP Socket Factory||使用javax.净.SSL.的SSLSocketFactory 
|SMTP X-Mailer Header|| X-Mailer在传出电子邮件的标题中使用 
|Content Type|| Mime Type用于解释电子邮件的内容，例如text / plain或text / html 
|From|true |指定用作发件人的电子邮件地址.否则，"友好名称”可用作"发件人”地址，但该值 
           必须用双引号括起来. 
|To||要包含在电子邮件的"收件人”行中的收件人 
|CC||收件人要包含在电子邮件的CC-Line中 
|BCC||收件人要包含在电子邮件的BCC-Line中 
|==== 


除了标记为必需的上述属性之外，至少有一个属性 `To`， `CC`， 要么 `BCC` 
必须设置属性 . 

配置电子邮件服务的完整示例如下所示: 


.... 
     <service> 
        <id>email-notification</id> 
        <class>org.apache.Orchsym Studio.bootstrap.notification.email.EmailNotificationService</class> 
        <property name="SMTP Hostname">smtp.gmail.com</property> 
        <property name="SMTP Port">587</property> 
        <property name="SMTP Username">username@gmail.com</property> 
        <property name="SMTP Password">super-secret-password</property> 
        <property name="SMTP TLS">true</property> 
        <property name="From">"Orchsym Studio Service Notifier"</property> 
        <property name="To">username@gmail.com</property> 
     </service> 
.... 


=== HTTP通知服务 + 

第二个通告程序是发送HTTP POST请求，实现是 `org.apache.Orchsym Studio.bootstrap.notification.http.HttpNotificationService`. 
它具有以下属性: 

|==== 
|*Property*|*需要*|*描述* 
|URL|true |要将通知发送到的URL. 支持表达式语言. 
|Connection timeout||连接远程服务的最长等待时间. 支持表达式语言. 默认为10秒. 
|Write timeout||远程服务的最长等待时间，以读取发送的请求. 支持表达式语言. 默认为10秒. 
|Truststore Filename|| Truststore的完全限定文件名 
|Truststore Type|| Truststore的类型. 无论是JKS还是PKCS12 
|Truststore Password|| Truststore的密码 
|Keystore Filename|| Keystore的完全限定文件名 
|Keystore Type||密钥库的密码 
|Keystore Password||密钥的密码. 如果未指定，但指定了密钥库文件名，密码和类型，则假定密钥库密码与密钥密码相同. 
|SSL Protocol||用于此SSL上下文的算法. 这可以是"SSL”或"TLS”. 
|==== 

除上述属性外，还可以添加动态属性. 它们将作为标头添加到HTTP请求中. 支持表达式语言. 

通知消息位于POST请求的正文中. 通知的类型位于标题"通知中.键入"和主题使用标题”通知.学科”. 

配置HTTP服务的完整示例如下所示: 


.... 
     <service> 
        <id>http-notification</id> 
        <class>org.apache.Orchsym Studio.bootstrap.notification.http.HttpNotificationService</class> 
        <property name="URL">https://testServer.com:8080/</property> 
        <property name="Truststore Filename">localhost-ts.jks</property> 
        <property name="Truststore Type">JKS</property> 
        <property name="Truststore Password">localtest<property> 
        <property name="Keystore Filename">localhost-ts.jks</property> 
        <property name="Keystore Type">JKS</property> 
        <property name="Keystore Password">localtest</property> 
        <property name="notification.timestamp">${now()}</property> 
     </service> 
.... 


[[proxy_configuration]] 
== 代理配置 - 
在代理后面运行Orchsym Studio时，在部署期间需要注意几个关键项. 

* Orchsym Studio由许多Web应用程序(Web UI，Web API，文档，自定义UI，数据查看器等)组成，因此需要为 *根路径*.这样，所有上下文 
路径都相应地传递. 例如，如果只有 `/Orchsym Studio` 上下文路径已映射，自定义UI为 `UpdateAttribute` 将无法使用，因为它可用于 `/update-attribute-ui-<version>`. 

* Orchsym Studio的REST API将为图表上的每个组件生成URI. 由于请求是通过代理发出的，因此需要覆盖生成的URI的某些元素.在不 
覆盖的情况下，用户将能够在画布上查看数据流，但无法修改现有组件.请求将尝试直接回拨给Orchsym Studio，而不是通过 
代理. 当代理生成对Orchsym Studio实例的HTTP请求时，可以通过添加以下HTTP标头来覆盖URI的元素: 


.... 
X-ProxyScheme - the scheme to use to connect to the proxy 
X-ProxyHost - the host of the proxy 
X-ProxyPort - the port the proxy is listening on 
X-ProxyContextPath - the path configured to map to the Orchsym Studio instance 
.... 


* 如果Orchsym Studio安全运行，则需要授权任何代理来代理用户请求. 这些可以通过全局菜单在Orchsym Studio UI中配置.一旦这些权限到位，代理 
就可以开始代理用户请求. 必须在HTTP标头中中继最终用户标识. 例如，如果最终用户向代理发送了请求，则代理必须对用户进行身份验证.在
此之后 ，代理可以将请求发送到Orchsym Studio. 在此请求中，应添加HTTP标头，如下所示. 


.... 
X-ProxiedEntitiesChain: <end-user-identity> 
.... 


如果代理配置为发送到另一个代理，则来自第二个代理的对Orchsym Studio的请求应包含如下标头. 


.... 
X-ProxiedEntitiesChain: <end-user-identity><proxy-1-identity> 
.... 


设置所需属性的示例Apache代理配置可能如下所示. 完整的代理配置超出了本文档的范围.请参阅 
代理文档以获取有关部署环境和用例的指导. 


.... 

... 
<Location "/my-Orchsym Studio"> 
    ... 

SSLEngine On 
SSLCertificateFile /path/to/proxy/certificate.crt 
SSLCertificateKeyFile /path/to/proxy/key.key 
SSLCACertificateFile /path/to/ca/certificate.crt 
SSLVerifyClient require 
RequestHeader add X-ProxyScheme "https" 
RequestHeader add X-ProxyHost "proxy-host" 
RequestHeader add X-ProxyPort "443" 
RequestHeader add X-ProxyContextPath "/my-Orchsym Studio" 
RequestHeader add X-ProxiedEntitiesChain "<%{SSL_CLIENT_S_DN}>" 
ProxyPass https://Orchsym Studio-host:8443 
ProxyPassReverse https://Orchsym Studio-host:8443 

... 
</Location> 
... 

.... 


* 必须更新其他Orchsym Studio代理配置，以允许预期的主机和上下文路径HTTP标头. 

** 默认情况下，如果Orchsym Studio安全运行，它将只接受主机标头与主机匹配的HTTP请求[:port] 这是必然的.如果Orchsym Studio接受针对不同
主机的请求 [:port] 需要配置预期值. 在代理服务器或容器化环境中运行时可能需要这样做.这是在逗号
分隔列表中配置 的 _Orchsym Studio.properties_ 使用 `Orchsym Studio.web.proxy.host` 财产(例如.G. localhost:18443，proxyhost:443). 接受IPv6地址.请参阅 
RFC 5952部分link:https://tools.ietf.org/html/rfc5952#section-4[4] 和 link:https://tools.ietf.org/html/rfc5952#section-6[6] 了解更多细节. 

** Orchsym Studio仅接受带有X-ProxyContextPath或X-Forwarded-Context标头的HTTP请求，如果该值在列表中列入白名单 `Orchsym Studio.web.proxy.context.path` 物业 
_Orchsym Studio.properties_. 此属性接受以逗号分隔的预期值列表.如果传入请求具有
白名单中不存在的X-ProxyContextPath或X-Forwarded-Context标头值，则会 显示"发生意外错误”页面，并将错误写入Orchsym Studio-app.日志. 

* 需要在代理服务器和Orchsym Studio群集上进行其他配置，以使Orchsym Studio站点到站点在反向代理后面工作. 见<<网站_to_现场_reverse_proxy_properties>>了解详情. 

** 为了通过反向代理通过站点到站点协议传输数据，代理和站点到站点客户端Orchsym Studio用户都需要具有以下策略，"检索站点到站点的详细信息”，"通过站点接收数据”到-现场' 用于输入端口，以及"通过站点到站点发送数据”' 用于输出端口. 

[[kerberos_service]] 
== 
可以将Kerberos服务 Orchsym Studio配置为使用Kerberos SPNEGO(或"Kerberos服务”)进行身份验证. 在这种情况下，用户将点击REST端点 `/access/kerberos` 并且服务器将以响应 `401` 状态代码和质询响应标头 `WWW-Authenticate: Negotiate`. 这将与浏览器通信以使用GSS-API并加载用户的Kerberos票证，并在后续请求中将其作为Base64编码的标头值提供. 它将是形式 `Authorization: Negotiate YII...`. Orchsym Studio将尝试使用KDC验证此票证. 如果成功，则为用户 _principal_ 将作为标识返回，并且流将遵循登录/凭证认证，因为将在响应中发出JWT以防止在每个后续请求上进行Kerberos身份验证的不必要开销. 如果无法验证故障单，它将返回相应的错误响应代码. 然后，用户将能够将他们的Kerberos凭据提供给登录表单 `KerberosLoginIdentityProvider` 已配置. 见"kerberos”_login_identity_provider>>登录标识提供程序以获取更多详细信息. 

Orchsym Studio只会通过HTTPS连接响应Kerberos SPNEGO协商，因为不安全的请求永远不会被验证. 

必须设置以下属性 _Orchsym Studio.properties_ 启用Kerberos服务身份验证. 

|==== 
|*Property*|*需要*|*描述* 
|Service Principal|true | Orchsym Studio用于与KDC通信的服务主体 
|Keytab Location|true |包含服务主体的keytab的文件路径 
|==== 

有关完整文档，请参见<<kerberos_properties>>. 

[[kerberos_service_notes]] 
=== 笔记 

* Kerberos在许多地方都是区分大小写的，并且错误消息(或缺少错误消息)可能没有充分解释. 检查配置文件中服务主体的区分大小写. 公约是 `HTTP/fully.qualified.domain@REALM`. 
* 在处理SPNEGO谈判时，浏览器具有不同程度的限制. 有些会向请求它的任何域提供本地Kerberos票证，而其他域会将受信任域列入白名单. 看到 link:http://docs.spring.io/autorepo/docs/spring-security-kerberos/1.0.2.BUILD-SNAPSHOT/reference/htmlsingle/#browserspnegoconfig[Spring Security Kerberos - Reference Documentation: Appendix E. Configure browsers for SPNEGO Negotiation^] 对于常见的浏览器. 
* 某些浏览器(旧版IE)不支持最近的加密算法(如AES)，并且仅限于传统算法(DES). 生成keytabs时应注意这一点. 
* 必须配置KDC并为Orchsym Studio定义服务主体并导出密钥表. 有关Kerberos服务器配置和管理的综合说明超出了本文档的范围(请参阅 link:http://web.mit.edu/kerberos/krb5-current/doc/admin/index.html[MIT Kerberos Admin Guide^])，但一个例子如下: 


为服务器添加服务主体 `Orchsym Studio.Orchsym Studio.apache.org` 并从KDC导出keytab: 


.... 
root@kdc:/etc/krb5kdc# kadmin.local 
Authenticating as principal admin/admin@Orchsym Studio.APACHE.ORG with password. 
kadmin.local:  listprincs 
K/M@Orchsym Studio.APACHE.ORG 
admin/admin@Orchsym Studio.APACHE.ORG 

... 
kadmin.local:  addprinc -randkey HTTP/Orchsym Studio.Orchsym Studio.apache.org 
WARNING: no policy specified for HTTP/Orchsym Studio.Orchsym Studio.apache.org@Orchsym Studio.APACHE.ORG; defaulting to no policy 
Principal "HTTP/Orchsym Studio.Orchsym Studio.apache.org@Orchsym Studio.APACHE.ORG" created. 
kadmin.local:  ktadd -k /http-Orchsym Studio.keytab HTTP/Orchsym Studio.Orchsym Studio.apache.org 
Entry for principal HTTP/Orchsym Studio.Orchsym Studio.apache.org with kvno 2, encryption type des3-cbc-sha1 added to keytab WRFILE:/http-Orchsym Studio.keytab. 
Entry for principal HTTP/Orchsym Studio.Orchsym Studio.apache.org with kvno 2, encryption type des-cbc-crc added to keytab WRFILE:/http-Orchsym Studio.keytab. 
kadmin.local:  listprincs 
HTTP/Orchsym Studio.Orchsym Studio.apache.org@Orchsym Studio.APACHE.ORG 
K/M@Orchsym Studio.APACHE.ORG 
admin/admin@Orchsym Studio.APACHE.ORG 
... 

kadmin.local: q 
root@kdc:~# ll /http* 
-rw------- 1 root root 162 Mar 14 21:43 /http-Orchsym Studio.keytab 
root@kdc:~# 
.... 


[[system_properties]] 
== 系统属性 
的 _Orchsym Studio.properties_ 文件中 _conf_ directory是用于控制Orchsym Studio运行方式的主要配置文件. 本节概述了此文件中的属性，并包含有关如何以便于升级的方式对其进行配置的一些注意事项. *更改此文件后，重新启动Orchsym Studio以 
使更改生效.* 

NOTE: 此文件的内容相对稳定，但会不时更改.
升级时查看此文件始终是个好主意， 并注意任何更改.考虑配置 
下面标有星号的项目(*以这种方式升级将更容易.有关详细信息，请参阅
本节末尾有关升级的完整讨论 .请注意，时间段和数据大小的值必须包括度量单位， 
例如"10秒”或"10 MB”，而不仅仅是"10”. 

=== 核心属性 + 

第一部分 _Orchsym Studio.properties_ 文件用于核心属性. 这些属性作为一个整体适用于核心框架. 

|=== 
|*Property*|*描述* 
|Orchsym Studio.flow.configuration.file*|流配置文件的位置(i.Ë.，包含当前在Orchsym Studio图上显示的内容的文件). 默认值为 `./conf/flow.xml.gz`. 
|Orchsym Studio.flow.configuration.archive.enabled*|指定Orchsym Studio是否在更新流时自动创建流的备份副本. 默认值为 `true`. 
|Orchsym Studio.flow.configuration.archive.dir*|归档目录的位置，其中备份副本的流.xml已保存. 默认值为 `./conf/archive`. Orchsym Studio根据归档文件的生命周期，总大小和文件数量删除旧的归档文件以限制磁盘使用量，如 `Orchsym Studio.flow.configuration.archive.max.time`， `max.storage` 和 `max.count` 属性分别. 如果未指定归档的这些限制，则Orchsym Studio使用默认条件，即最多为"30天”.最长时间和"500 MB”.存储. + 
此清理机制仅考虑自动创建的归档流.xml文件. 如果此存档目录中有其他文件或目录，Orchsym Studio将忽略它们. 自动创建的存档具有带ISO 8601格式时间戳前缀的文件名，后跟'_<original-filename>'. That is <year><month><day>T<hour><minute><second>+<timezone offset>_<原始文件名>. 例如， `20160706T160719+0900_flow.xml.gz`. Orchsym Studio在清理归档目录时检查文件名. 如果您想在此目录中保留特定存档而不必担心Orchsym Studio删除它，您可以通过使用不同的文件名模式复制它. 
|Orchsym Studio.flow.configuration.archive.max.time*|归档流程的生命周期.xml文件. Orchsym Studio将在更新流时删除过期的存档文件.xml如果指定了此属性. 到期时间取决于当前系统时间和归档流的上次修改时间戳.XML. 如果在Orchsym Studio中没有指定存档限制.属性，Orchsym Studio删除超过"30天”的档案. 
|Orchsym Studio.flow.configuration.archive.max.storage*|存档流程允许的总数据大小.xml文件. 如果指定了此属性，Orchsym Studio将删除最早的归档文件，直到总归档文件大小小于此配置值. 如果在Orchsym Studio中没有指定存档限制.属性，Orchsym Studio为此使用"500 MB”. 
|Orchsym Studio.flow.configuration.archive.max.count*|允许的归档文件数. 如果指定了此属性，Orchsym Studio将删除最旧的存档文件，以便只保留N个最新存档. 
|Orchsym Studio.flowcontroller.autoResumeState|指示是否 -重启后- Orchsym Studio图上的组件应返回其最后状态. 默认值为 `true`. 
|Orchsym Studio.flowcontroller.graceful.shutdown.period|表示关机时间. 默认值为 `10 secs`. 
|Orchsym Studio.flowservice.writedelay.interval|当对流程进行许多更改时.xml，此属性指定在写出更改之前等待的时间，以便将更改批处理为单个写入. 默认值为 `500 ms`. 
|Orchsym Studio.administrative.yield.duration|如果某个组件允许意外异常转义，则会将其视为错误. 因此，框架将在这段时间内暂停(或在行政上产生)组件. 这样做是为了使组件不会消耗大量的系统资源，因为已知在现有状态下存在问题. 默认值为 `30 secs`. 
|Orchsym Studio.bored.yield.duration|当一个组件没有工作要做时(i.Ë.，"无聊”)，这是在检查是否有新数据可用之前等待的时间. 这样，它不会过多地检查新工作而耗尽CPU资源. 设置此属性时，请注意它可能会为不经常工作的组件添加额外的延迟，因为一旦进入这种"无聊”状态，他们将等待这段时间后再检查更多工作. 默认值为 `10 ms`. 
|Orchsym Studio.queue.backpressure.count|在两个组件之间绘制新连接时，这是该连接的背压对象阈值的默认值. 默认值为10000，值必须为整数. 
|Orchsym Studio.queue.backpressure.size|在两个组件之间绘制新连接时，这是该连接的背压数据大小阈值的默认值. 默认值为1 GB，值必须是包含度量单位的数据大小. 
|Orchsym Studio.authorizer.configuration.file*|这是文件的位置，指定如何定义授权程序.  默认值为 `./conf/authorizers.xml`. 
|Orchsym Studio.login.identity.provider.configuration.file*|这是文件的位置，指定如何执行用户名/密码身份验证.此文件 
仅在以下情况下考虑 `Orchsym Studio.security.user.login.identity.provider` 配置有提供者标识符. 默认值为 `./conf/login-identity-providers.xml`. 
|Orchsym Studio.templates.directory*|这是保存流模板的目录的位置(仅用于向后兼容).  模板存储在流程中.XML.gz从Orchsym Studio 1开始.0. 模板目录可用于(批量)将模板导入流中.XML.在Orchsym Studio启动时自动gz.  默认值为 `./conf/templates`. 
|Orchsym Studio.ui.banner.text|这是横幅文本，可配置为显示在用户界面的顶部. 默认为空白. 
|Orchsym Studio.ui.autorefresh.interval|用户界面自动刷新的时间间隔. 默认值为 `30 secs`. 
|Orchsym Studio.nar.library.directory|nar库的位置. 默认值为 `./lib` 并且可能应该保持原样. + 
+ 
*注意*:可以使用指定其他库目录 *_Orchsym Studio.nar.library.directory._* 带有唯一后缀的前缀和作为值的单独路径. + 
+ 
例如，要提供两个额外的库位置，用户还可以使用以下键指定其他属性: + 
+ 
Orchsym Studio.NAR.图书馆.目录.LIB1 = / NARS / LIB1 + 
Orchsym Studio.NAR.图书馆.目录.LIB2 = / NARS / LIB2 + 
+ 
提供三个总位置，包括  `Orchsym Studio.nar.library.directory`. 
|Orchsym Studio.nar.working.directory|nar工作目录的位置. 默认值为 `./work/nar` 并且可能应该保持原样. 
|Orchsym Studio.documentation.working.directory|文档工作目录. 默认值为 `./work/docs/components` 并且可能应该保持原样. 
|Orchsym Studio.processor.scheduling.timeout|等待组件的生命周期操作(@OnScheduled和@OnUnscheduled)在其他生命周期操作之前完成的时间(e.G.，stop)可以被调用. 默认值为 `1 min`. 
|=== 


=== 国家管理 + 

Properties文件的State Management部分提供了一种机制，用于配置组件的本地和集群范围机制 
以保持状态. 有关如何使用它的更多信息，请参阅<<state_management>>部分. 

|==== 
|*Property*|*描述* 
|Orchsym Studio.state.management.configuration.file|包含本地和群集范围的状态提供程序的配置的XML文件. 默认值为 `./conf/state-management.xml`. 
|Orchsym Studio.state.management.provider.local|要使用的本地状态提供程序的ID. 该值必须与值相匹配 `id` 其中一个的元素 `local-provider` 中的元素 _state-management.xml_ 文件. 
|Orchsym Studio.state.management.provider.cluster|要使用的群集状态提供程序的ID. 该值必须与值相匹配 `id` 其中一个的元素 `cluster-provider` 中的元素 _state-management.xml_ 文件. 如果不是群集，则忽略此值，但群集中的节点需要此值. 
|Orchsym Studio.state.management.embedded.zookeeper.start|指定此Orchsym Studio实例是否应启动嵌入式ZooKeeper服务器. 它与ZooKeeperStateProvider一起使用. 
|Orchsym Studio.state.management.embedded.zookeeper.properties|指定一个属性文件，其中包含已启动的嵌入式ZooKeeper服务器的配置(如果是 `Orchsym Studio.state.management.embedded.zookeeper.start` 属性设置为 `true`) 
|==== 


=== H2设置 

H2设置部分定义H2数据库的设置，该数据库跟踪用户访问和流控制器历史记录. 

|==== 
|*Property*|*描述* 
|Orchsym Studio.database.directory*|H2数据库目录的位置. 默认值为 `./database_repository`. 
|Orchsym Studio.h2.url.append|此属性指定要添加到H2数据库的连接字符串的其他参数. 应使用默认值，不应更改. 它是: `;LOCK_TIMEOUT=25000;WRITE_DELAY=0;AUTO_SERVER=FALSE`. 
|==== 


=== FlowFile存储库 

FlowFile存储库跟踪系统中每个FlowFile的属性和当前状态.默认情况下， 
此存储库与所有其他存储库安装在同一根安装目录中; 但是，
如果可用，建议 在单独的驱动器上进行配置. 

|==== 
|*Property*|*描述* 
|Orchsym Studio.flowfile.repository.implementation|FlowFile Repository实现. 默认值为 `org.apache.Orchsym Studio.controller.repository.WriteAheadFlowFileRepository` 并且应该谨慎改变. 要将流文件存储在内存而不是磁盘上(在电源/机器故障或重新启动Orchsym Studio时接受数据丢失)，请将此属性设置为 `org.apache.Orchsym Studio.controller.repository.VolatileFlowFileRepository`. 
|Orchsym Studio.flowfile.repository.wal.implementation|如果存储库实现配置为使用 `WriteAheadFlowFileRepository`，此属性可用于指定
应使用Write-Ahead Log的哪个实现 . 默认值为 `org.apache.Orchsym Studio.wali.SequentialAccessWriteAheadLog`. 此版本的预写日志已在版本1中添加.6.
为了解决旧实现中存在的问题而开发的Orchsym Studio 0 .在断电或操作系统崩溃的情况下，旧的实现很容易
错误地恢复FlowFiles . 在断电或操作系统崩溃后，这可能会导致在重新启动时将错误的属性或内容分配给FlowFile.但是，
如果需要，仍然可以选择选择 使用先前的实现并接受该风险(例如，如果新实现会出现一些意外错误). 
为此，请将此属性的值设置为 `org.wali.MinimalLockingWriteAheadLog`. 
如果更改了此属性的值，则在重新启动时，Orchsym Studio仍将恢复使用先前配置的存储库写入的记录，并删除先前配置的
实现所写的文件 . 
|Orchsym Studio.flowfile.repository.directory*|FlowFile存储库的位置. 默认值为 `./flowfile_repository`. 
|Orchsym Studio.flowfile.repository.partitions|分区数量. 默认值为 `256`. 
|Orchsym Studio.flowfile.repository.checkpoint.interval| FlowFile存储库检查点间隔. 默认值为 `2 mins`. 
|Orchsym Studio.flowfile.repository.always.sync|如果设置为 `true`，对存储库的任何更改都将同步到磁盘，这意味着Orchsym Studio将要求操作系统不要缓存信息. 这非常昂贵并且可以显着降低Orchsym Studio性能. 但是，如果是的话 `false`如果突然断电或操作系统崩溃，可能会有数据丢失的可能性. 默认值为 `false`. 
|==== 

=== 交换管理 

Orchsym Studio将FlowFile信息保存在内存(JVM)中， 
但在传入数据激增期间，FlowFile信息可能开始占用系统性能
受损的大量JVM .为了抵消这种影响，Orchsym Studio会暂时将FlowFile信息"交换”到磁盘，直到更多JVM空间 
再次可用. 这些属性控制着该过程的发生方式. 

|==== 
|*Property*|*描述* 
|Orchsym Studio.swap.manager.implementation|Swap Manager实现. 默认值为 `org.apache.Orchsym Studio.controller.FileSystemSwapManager` 不应该改变. 
|Orchsym Studio.queue.swap.threshold|Orchsym Studio开始将FlowFile信息交换到磁盘的队列阈值. 默认值为 `20000`. 
|Orchsym Studio.swap.in.period|交换期间. 默认值为 `5 sec`. 
|Orchsym Studio.swap.in.threads|用于交换的线程数. 默认值为 `1`. 
|Orchsym Studio.swap.out.period|换出期. 默认值为 `5 sec`. 
|Orchsym Studio.swap.out.threads|用于交换的线程数. 默认值为 `4`. 
|==== 

=== 内容存储库 

内容存储库保存系统中所有FlowFiles的内容.默认情况下，它
与所有其他存储库安装在同一根 安装目录中; 但是，管理员可能希望在单独的
驱动器上配置它( 如果可用). 如果没有别的，最好是内容存储库与FlowFile存储库不在同一个驱动器上. 
在处理大量数据的数据流中，内容存储库可能会填满磁盘， 
FlowFile存储库(如果也在该磁盘上)可能会损坏. 要避免这种情况，请在不同的驱动器上配置这些存储库. 

|==== 
|*Property*|*描述* 
|Orchsym Studio.content.repository.implementation|内容存储库实现. 默认值为 `org.apache.Orchsym Studio.controller.repository.FileSystemRepository` 并且应该谨慎改变. 要将流文件内容存储在内存而不是磁盘上(在电源/机器发生故障时存在数据丢失的风险)，请将此属性设置为 `org.apache.Orchsym Studio.controller.repository.VolatileContentRepository`. 
|==== 

=== 文件系统内容存储库属性 

|==== 
|*Property*|*描述* 
|Orchsym Studio.content.repository.implementation|内容存储库实现. 默认值为 `org.apache.Orchsym Studio.controller.repository.FileSystemRepository` 并且应该谨慎改变. 要将流文件内容存储在内存而不是磁盘上(在电源/机器发生故障时存在数据丢失的风险)，请将此属性设置为 `org.apache.Orchsym Studio.controller.repository.VolatileContentRepository`. 
|Orchsym Studio.content.claim.max.appendable.size|内容声明的最大大小. 默认值为 `10 MB`. 
|Orchsym Studio.content.claim.max.flow.files|要分配给一个内容声明的最大FlowFiles数. 默认值为 `100`. 
|Orchsym Studio.content.repository.directory.default*|内容存储库的位置. 默认值为 `./content_repository`. + 
+ 
*注意*:可以使用指定多个内容存储库 *_Orchsym Studio.content.repository.directory._* 带有唯一后缀的前缀和作为值的单独路径. + 
+ 
例如，要提供另外两个位置作为内容存储库的一部分，用户还可以使用以下键指定其他属性: + 
+ 
Orchsym Studio.内容.知识库.目录.内容1 = /回购/内容1 + 
Orchsym Studio.内容.知识库.目录.内容2 = /回购/内容2 + 
+ 
提供三个总位置，包括  `Orchsym Studio.content.repository.directory.default`. 
|Orchsym Studio.content.repository.archive.max.retention.period|如果启用了存档(请参阅Orchsym Studio.内容.知识库.档案.在下面启用)，然后 
此属性指定保留存档数据的最长时间. 默认值为 `12 hours`. 
|Orchsym Studio.content.repository.archive.max.usage.percentage|如果启用了存档(请参阅Orchsym Studio.内容.知识库.档案.在下面启用)，然后此属性必须具有一个值，该值指示开始删除存档数据的内容存储库磁盘使用百分比. 如果存档为空且内容存储库磁盘使用率高于此百分比，则暂时禁用存档. 当磁盘使用率低于此百分比时，将继续存档. 默认值为 `50%`. 
|Orchsym Studio.content.repository.archive.enabled|要启用内容存档，请将其设置为 _true_ 并指定一个值 `Orchsym Studio.content.repository.archive.max.usage.percentage` 上面的财产. 内容归档使来源UI能够查看或重放不再位于数据流队列中的内容. 默认情况下，启用存档. 
|Orchsym Studio.content.repository.always.sync|如果设置为 `true`，对存储库的任何更改都将同步到磁盘，这意味着Orchsym Studio将要求操作系统不要缓存信息. 这非常昂贵并且可以显着降低Orchsym Studio性能. 但是，如果是的话 `false`如果突然断电或操作系统崩溃，可能会有数据丢失的可能性. 默认值为 `false`. 
|Orchsym Studio.content.viewer.url|基于Web的内容查看器的URL(如果有). 默认为空白. 
|==== 

=== 易失性内容存储库属性 

|==== 
|*Property*|*描述* 
|Orchsym Studio.volatile.content.repository.max.size|内容存储库中的内容存储库最大大小. 默认值为 `100 MB`. 
|Orchsym Studio.volatile.content.repository.block.size|内容存储库块大小. 默认值为 `32 KB`. 
|==== 

=== Provenance Repository 

Provenance Repository包含与Data Provenance相关的信息. 接下来的四个部分是针对Provenance Repository属性的. 

|==== 
|*Property*|*描述* 
|Orchsym Studio.provenance.repository.implementation|Provenance Repository实现. 默认值为 `org.apache.Orchsym Studio.provenance.PersistentProvenanceRepository`. 
还有两个额外的存储库. 
将起源事件存储在内存而不是磁盘上(在这种情况下，所有事件将在重新启动时丢失，并且事件将按先进先出的顺序逐出)， 
将此属性设置为 `org.apache.Orchsym Studio.provenance.VolatileProvenanceRepository`.这在Java堆中留下了可配置数量的Provenance事件，因此
可以保留的事件数量 非常有限. 

截至Orchsym Studio 1.2.0，第三和第四选项可用: `org.apache.Orchsym Studio.provenance.WriteAheadProvenanceRepository` 和 `org.apache.Orchsym Studio.provenance.EncryptedWriteAheadProvenanceRepository`. 
创建此实现以替换 `PersistentProvenanceRepository`. 该 `PersistentProvenanceRepository`最初编写的目的是
在生成Provenance事件时保持它们的持久性， 并提供按顺序迭代这些事件的能力.后来，希望能够压缩数据以便 
存储更多数据. 之后，添加了索引和查询数据的功能.随着需求的不断变化，存储库不断变化，没有任何重大的 
重新设计. 当在负责处理大量小型FlowFiles的Orchsym Studio实例中使用时， `PersistentProvenanceRepository` 很快就会成为瓶颈. 
该 `WriteAheadProvenanceRepository` 然后编写，以提供相同的功能 `PersistentProvenanceRepository` 同时提供更好的性能. 
换到了 `WriteAheadProvenanceRepository` 很容易实现，因为这两个存储库支持大多数相同的属性. 

*注意好吧*然而，以下警告: `WriteAheadProvenanceRepository` 将利用由...存储的Provenance数据 `PersistentProvenanceRepository`. 但是，那 
`PersistentProvenanceRepository` 可能无法读取由...写的数据 `WriteAheadProvenanceRepository`.因此，一旦种源库更改为使用 
的 `WriteAheadProvenanceRepository`，它无法改变回来 `PersistentProvenanceRepository` 不删除Provenance存储库中的数据.因此， 
建议在更改实施之前，用户确保其Orchsym Studio版本稳定，以防出现任何问题导致用户需要回滚到 
以前版本的Orchsym Studio，而不支持 `WriteAheadProvenanceRepository`. 出于这个原因，默认仍然设置为 `PersistentProvenanceRepository` 
此时. 
|==== 

=== 持久性源代码库属性 

|==== 
|*Property*|*描述* 
|Orchsym Studio.provenance.repository.directory.default*|Provenance存储库的位置. 默认值为 `./provenance_repository`. + 
+ 
*注意*:可以使用以下命令指定多个出处存储库 *_Orchsym Studio.provenance.repository.directory._* 带有唯一后缀的前缀和作为值的单独路径. + 
+ 
例如，要提供另外两个位置作为起源存储库的一部分，用户还可以使用以下键指定其他属性: + 
+ 
Orchsym Studio.出处.知识库.目录.provenance1 = /回购/ provenance1 + 
Orchsym Studio.出处.知识库.目录.provenance2 = /回购/ provenance2 + 
+ 
提供三个总位置，包括 `Orchsym Studio.provenance.repository.directory.default`. 
|Orchsym Studio.provenance.repository.max.storage.time|保留数据出处信息的最长时间. 默认值为 `24 hours`. 
|Orchsym Studio.provenance.repository.max.storage.size|一次存储的最大数据源信息量. 默认值为 `1 GB`. 
|Orchsym Studio.provenance.repository.rollover.time|在滚动最新数据出处信息之前等待的时间量，以便在用户界面中可用. 默认值为 `30 secs`. 
|Orchsym Studio.provenance.repository.rollover.size|一次滚动的信息量. 默认值为 `100 MB`. 
|Orchsym Studio.provenance.repository.query.threads|用于Provenance Repository查询的线程数. 默认值为 `2`. 
|Orchsym Studio.provenance.repository.index.threads|用于索引Provenance事件的线程数，以便可以搜索它们. 默认值为 `2`. 
对于在大量FlowFiles上运行的流，Provenance事件的索引可能成为瓶颈.如果是这种情况，将出现一个公告，表明 
"数据流的速率超过了出处记录率. 减慢流量以适应."如果发生这种情况，增加此属性的值 
可能会提高Provenance Repository处理这些记录的速度，从而提高整体吞吐量. 
|Orchsym Studio.provenance.repository.compress.on.rollover|指示在翻转时是否压缩出处信息. 默认值为 `true`. 
|Orchsym Studio.provenance.repository.always.sync|如果设置为 `true`，对存储库的任何更改都将同步到磁盘，这意味着Orchsym Studio将要求操作系统不要缓存信息. 这非常昂贵并且可以显着降低Orchsym Studio性能. 但是，如果是的话 `false`如果突然断电或操作系统崩溃，可能会有数据丢失的可能性. 默认值为 `false`. 
|Orchsym Studio.provenance.repository.journal.count|应该用于序列化Provenance事件数据的日志文件数. 增加此值将允许更多任务同时更新存储库，但稍后将导致更昂贵的日志文件合并. 理想情况下，此值应等于预期同时更新存储库的线程数，但16在必须的环境中往往运行良好. 默认值为 `16`. 
|Orchsym Studio.provenance.repository.indexed.fields|这是一个以逗号分隔的字段列表，应该将其编入索引并进行搜索. 未编制索引的字段将无法搜索. 有效字段是: `EventType, FlowFileUUID, Filename, TransitURI, ProcessorID, AlternateIdentifierURI, Relationship, Details`. 默认值为: `EventType, FlowFileUUID, Filename, ProcessorID`. 
|Orchsym Studio.provenance.repository.indexed.attributes|这是一个以逗号分隔的FlowFile属性列表，应该对其进行索引并使其可搜索. 默认为空白.  但是要考虑的一些好例子是'filename'，'uuid'和'mime.类型' 以及您可能使用的任何对您的用例有价值的自定义attritubes. 
|Orchsym Studio.provenance.repository.index.shard.size|在搜索Provenance存储库时，分片大小的较大值将导致更多Java堆使用，但应提供更好的性能. 默认值为 `500 MB`. 
|Orchsym Studio.provenance.repository.max.attribute.length|指示从存储库检索Provenance事件时FlowFile属性的最大长度. 如果任何属性的长度超过此值，则在检索事件时将截断该值. 默认值为 `65536`. 
|==== 

=== 易失性来源存储库属性 

|==== 
|*Property*|*描述* 
|Orchsym Studio.provenance.repository.buffer.size|Provenance Repository缓冲区大小. 默认值为 `100000`. 
|==== 

=== 提前编写源代码库属性 

|==== 
|*Property*|*描述* 
|Orchsym Studio.provenance.repository.directory.default*|Provenance存储库的位置. 默认值为 `./provenance_repository`. + 
+ 
*注意*:可以使用以下命令指定多个出处存储库 *_Orchsym Studio.provenance.repository.directory._* 带有唯一后缀的前缀和作为值的单独路径. + 
+ 
例如，要提供另外两个位置作为起源存储库的一部分，用户还可以使用以下键指定其他属性: + 
+ 
Orchsym Studio.出处.知识库.目录.provenance1 = /回购/ provenance1 + 
Orchsym Studio.出处.知识库.目录.provenance2 = /回购/ provenance2 + 
+ 
提供三个总位置，包括 `Orchsym Studio.provenance.repository.directory.default`. 
|Orchsym Studio.provenance.repository.max.storage.time|保留数据出处信息的最长时间. 默认值为 `24 hours`. 
|Orchsym Studio.provenance.repository.max.storage.size|一次存储的最大数据源信息量. 
默认值为 `1 GB`. Data Provenance功能可能会占用大量存储空间，因为保留了大量数据. 
对于生产环境，1-2 TB或更高的值并不罕见.
如果定义了多个存储位置，如上所述，存储库将写入单个"事件文件”(或"事件文件”集合， 如上所述)一段时间(由
Orchsym Studio 定义) .出处.知识库.滚下.时间和Orchsym Studio.出处.知识库.滚下.尺寸属性).数据总是一次老化一个文件，
因此不建议在很长一段时间 内写入单个"事件文件”，因为这样可以防止旧数据老化. 
|Orchsym Studio.provenance.repository.rollover.time|滚动存储库正在写入的"事件文件”之前等待的时间. 
|Orchsym Studio.provenance.repository.rollover.size|要写入单个"事件文件”的数据量."默认值是 `100 MB`.对于生成
大量Data Provenance的生产 环境，1 GB的值也非常合理. 
|Orchsym Studio.provenance.repository.query.threads|用于Provenance Repository查询的线程数. 默认值为 `2`. 
|Orchsym Studio.provenance.repository.index.threads|用于索引Provenance事件的线程数，以便可以搜索它们. 默认值为 `2`. 
对于在大量FlowFiles上运行的流，Provenance事件的索引可能成为瓶颈.如果发生这种情况，增加
此属性的 值可能会提高Provenance Repository处理这些记录的速度，从而提高整体吞吐量. 
建议每个存储位置使用至少1个线程(i.Ë.，如果有3个存储位置，则应使用至少3个线程).对于
可提供更多CPU和磁盘I / O的高 吞吐量环境，可能会显着增加此值.通常
每个存储位置超过 2-4个线程是没有价值的. 但是，这可以根据与I / O资源相比可用的CPU资源进行调整. 
|Orchsym Studio.provenance.repository.compress.on.rollover|指示在滚动"事件文件”时是否压缩出处信息. 默认值为 `true`. 
|Orchsym Studio.provenance.repository.always.sync|如果设置为 `true`，对存储库的任何更改都将同步到磁盘，这意味着Orchsym Studio将要求操作系统 
不要缓存信息. 这非常昂贵并且可以显着降低Orchsym Studio性能. 但是，如果是的话 `false`
如果突然断电或操作系统崩溃，可能会有数据丢失的可能性 . 默认值为 `false`. 
|Orchsym Studio.provenance.repository.indexed.fields|这是一个以逗号分隔的字段列表，应该将其编入索引并进行搜索. 
未编制索引的字段将无法搜索.有效字段为:`EventType，FlowFileUUID，Filename，TransitURI，ProcessorID， 
AlternateIdentifierURI，Relationship，Details`. 默认值为: `EventType, FlowFileUUID, Filename, ProcessorID`. 
|Orchsym Studio.provenance.repository.indexed.attributes|这是一个以逗号分隔的FlowFile属性列表，应该对其进行索引并使其可搜索. 默认为空白. 
但是要考虑的一些好例子是'文件名' 和'哑剧.类型' 以及您可能使用的任何对您的用例有价值的自定义属性. 
|Orchsym Studio.provenance.repository.index.shard.size|存储库使用Apache Lucene来执行索引和搜索功能.此值指示
在Repository开始写入新索引之前Lucene索引应该有多大 .在搜索Provenance存储库时，分片大小的较大值将导致更多Java堆使用，但应 
提供更好的性能. 默认值为 `500 MB`. 但是，这是因为默认设置适用于大多数用户开始使用Orchsym Studio的非常小的环境. 
对于生产环境，建议将此值更改为 *4到8 GB*.一旦索引中的所有Provenance事件都从"事件文件” 
中消失，索引 也将被销毁. 
|Orchsym Studio.provenance.repository.max.attribute.length|指示从存储库检索Provenance事件时FlowFile属性的最大长度. 
如果任何属性的长度超过此值，则在检索事件时将截断该值. 默认值为 `65536`. 
|Orchsym Studio.provenance.repository.concurrent.merge.threads|Apache Lucene在索引中创建了几个"段”.这些段定期合并在一起，以提供更快的 
查询. 此属性指定允许用于的最大线程数 *每* 的存储目录. 默认值为 `2`.对于高吞吐量 
环境，建议将索引线程数设置为大于合并线程数* 存储位置的数量.例如，如果有2个存储 
位置且索引线程数设置为8，那么合并线程的数量应该可能小于4.虽然完成此操作并不重要，但设置 
大于此数量的合并线程数会导致所有索引线程被用于合并，这会导致Orchsym Studio流在索引发生时定期暂停， 
从而导致某些数据被处理具有比其他数据更高的延迟. 
|Orchsym Studio.provenance.repository.warm.cache.frequency|每次运行Provenance查询时，查询必须首先搜索Apache Lucene索引(至少在大多数情况下) - 还有 
那些经常运行一些查询和结果被缓存以避免搜索了Lucene索引).当Lucene索引首次打开时，它可能非常昂贵并且需要 
几秒钟. 这具有许多不同的索引，并且可能导致Provenance查询花费更长时间.打开索引后，操作系统的 
磁盘缓存通常会保留足够的数据，以便更快地重新打开索引- 至少在一段时间内，直到磁盘高速缓存驱逐这些数据.如果设置了此值， 
Orchsym Studio将定期打开每个Lucene索引然后关闭它，以便"加热”缓存. 当Provenance Repository很大时，这将导致更快的查询.
然而，与 所有伟大的事物一样，它带来了成本.加热缓存确实需要一些CPU资源，但更重要的是它会从操作系统磁盘缓存中驱逐其他数据，并
导致从磁盘 读取(可能是大量的)数据. 这可能导致较低的Orchsym Studio性能.但是，如果Orchsym Studio在CPU和磁盘
未充分利用的环境中运行 ，则此功能可以使得Provenance查询速度更快. 此属性的默认值为空(i.Ë. 禁用). 
|==== 

[[encrypted-write-ahead-provenance-repository-properties]] 
=== 加密的提前写入存储库属性 

上面定义的所有属性(请参阅<<write-ahead-provenance-repository-properties，Write Ahead Repository Properties>>)仍然适用. 此处仅列出特定于加密的属性. 请参阅<<user-guide.adoc＃encrypted-provenance，用户指南中的加密源代码库>>了解更多信息. 

|==== 
|*Property*|*描述* 
|Orchsym Studio.provenance.repository.debug.frequency|控制在记录存储库性能指标的DEBUG语句之间处理的事件数. 仅当在日志配置中启用DEBUG级别语句时才使用此值. 
| Orchsym Studio.出处.知识库.加密.键.提供商.实现|这是完全限定的类名 **主要提供者**. 密钥提供程序是用于访问加密密钥以保护起源事件的数据存储区接口. 目前有两种实现方式 -- `StaticKeyProvider` 它直接从中读取密钥 `Orchsym Studio.properties`，和 `FileBasedKeyProvider` 哪个读 *ñ* 来自加密文件的许多密钥. 该接口是可扩展的，并且预计将来会支持HSM或其他提供商. 
| Orchsym Studio.出处.知识库.加密.键.提供商.location |键定义资源的路径(为空时为空) `StaticKeyProvider`， `./keys.nkp` 或类似的路径 `FileBasedKeyProvider`). 对于像HSM这样的未来提供商，这可能是连接字符串或URL. 
| Orchsym Studio.出处.知识库.加密.键.id |用于加密的活动密钥ID(例如:.G. `Key1`). 
| Orchsym Studio.出处.知识库.加密.key |用于的密钥 `StaticKeyProvider`. 密钥格式为十六进制编码(`0123456789ABCDEFFEDCBA98765432100123456789ABCDEFFEDCBA9876543210`)但也可以使用<<encrypt-config_tool加密，`./encrypt-config.sh`>> Orchsym Studio工具包中的工具. 
| Orchsym Studio.出处.知识库.加密.键.ID.*|允许为其指定其他键 `StaticKeyProvider`. 例如，该行 `Orchsym Studio.provenance.repository.encryption.key.id.Key2=012...210` 会提供一个可用的密钥 `Key2`. 
|==== 

最简单的配置如下: 


.... 
Orchsym Studio.provenance.repository.implementation=org.apache.Orchsym Studio.provenance.EncryptedWriteAheadProvenanceRepository 
Orchsym Studio.provenance.repository.debug.frequency=100 
Orchsym Studio.provenance.repository.encryption.key.provider.implementation=org.apache.Orchsym Studio.security.kms.StaticKeyProvider 
Orchsym Studio.provenance.repository.encryption.key.provider.location= 
Orchsym Studio.provenance.repository.encryption.key.id=Key1 
Orchsym Studio.provenance.repository.encryption.key=0123456789ABCDEFFEDCBA98765432100123456789ABCDEFFEDCBA9876543210 
.... 



=== 组件状态存储库 

组件状态存储库包含用户界面中"组件状态历史记录”工具的信息.这些 
属性控制着该工具的工作方式. 

缓冲区.大小和快照.频率协同工作以确定要保留的历史数据量.例如， 
配置两天的历史数据，每5分钟发生一次数据点快照，您将配置 
快照.频率为"5分钟”和缓冲区.大小为"576”.为了进一步解释此示例每60分钟 
，该时间段有12(60/5)个快照窗口. 保持这些数据48小时(12 *48)最终你的缓冲区大小 
为576. 

|==== 
|*Property*|*描述* 
|Orchsym Studio.components.status.repository.implementation|组件状态存储库实现. 默认值为 `org.apache.Orchsym Studio.controller.status.history.VolatileComponentStatusRepository` 不应该改变. 
|Orchsym Studio.components.status.repository.buffer.size|指定组件状态存储库的缓冲区大小. 默认值为 `1440`. 
|Orchsym Studio.components.status.snapshot.frequency|此值指示显示组件快照的频率' 状态历史. 默认值为 `1 min`. 
|==== 


[[site_to_site_properties]] 
=== 站点到站点属性 

这些属性控制在数据流中配置远程进程组时，此Orchsym Studio实例如何与远程Orchsym Studio实例通信. 
远程进程组可以从RAW和HTTP中选择传输协议. 以。命名的属性 _Orchsym Studio.remote.input.socket.*_ 是RAW传输协议特定的. 同样的， _Orchsym Studio.remote.input.http.*_ 是HTTP传输协议特定的属性. 

|==== 
|*Property*|*描述* 
|Orchsym Studio.remote.input.host|将提供给客户端以连接到此Orchsym Studio实例以进行站点到站点通信的主机名. 默认情况下，它是来自InetAddress的值.的getLocalHost().的gethostname(). 在类UNIX操作系统上，这通常是来自的输出 `hostname` 命令. 
|Orchsym Studio.remote.input.secure|这表明此Orchsym Studio实例与远程Orchsym Studio实例之间的通信是否应该是安全的. 默认情况下，它设置为 `false`. 要使安全的站点到站点工作，请将属性设置为 `true`.   还必须配置许多其他安全属性(如下). 
|Orchsym Studio.remote.input.socket.port|用于站点到站点通信的远程输入套接字端口. 默认情况下，它是空白的，但它必须具有值才能使用RAW套接字作为站点到站点的传输协议. 
|Orchsym Studio.remote.input.http.enabled|指定是否应在此主机上启用HTTP站点到站点.  默认情况下，它设置为 `true`. + 
站点到站点客户端是使用HTTP还是HTTPS取决于 `Orchsym Studio.remote.input.secure`. 如果设置为 `true`，然后请求作为HTTPS发送到 `Orchsym Studio.web.https.port`. 如果设置为 `false`，HTTP请求被发送到 `Orchsym Studio.web.http.port`. 
|Orchsym Studio.remote.input.http.transaction.ttl|指定事务在服务器上保持活动状态的时间.  默认情况下，它设置为 `30 secs`. + 
如果站点到站点客户端在此段时间之后尚未继续执行下一个操作，则会从远程Orchsym Studio实例中丢弃该事务. 例如，当客户端创建事务但不发送或接收流文件时，或者客户端发送或接收流文件但未确认该事务时. 
|Orchsym Studio.remote.contents.cache.expiration|指定Orchsym Studio在通过站点到站点进行通信时应缓存有关远程Orchsym Studio实例的信息的时间. 默认情况下，Orchsym Studio会缓存 + 
来自远程系统的响应 `30 secs`. 这允许Orchsym Studio避免不断地向远程系统发出HTTP请求，这在Orchsym Studio的这个实例中尤为重要 + 
有许多远程进程组实例. 
|==== 

[[site_to_site_reverse_proxy_properties]] 
=== 反向代理的站点到站点路由属性 

站点到站点需要客户端和远程Orchsym Studio节点之间的对等通信. Ë.G. 如果远程Orchsym Studio集群有3个节点，Orchsym Studio0，Orchsym Studio1和Orchsym Studio2，那么客户端请求必须可以到达每个远程节点. 

如果Orchsym Studio群集计划通过互联网或公司防火墙从/向站点到站点客户端接收/传输数据，则可以在Orchsym Studio群集节点前部署反向代理服务器，作为将客户端请求路由到的网关上游Orchsym Studio节点，以减少必须暴露的服务器和端口的数量. 

在这种环境中，同一网络中的站点到站点客户端也可以访问相同的Orchsym Studio群集. 将流文件发送到自身以在Orchsym Studio群集节点之间进行负载分配可以是典型示例. 在这种情况下，客户端请求应该直接路由到节点，而不通过反向代理. 

为了支持此类部署，远程Orchsym Studio群集需要根据客户端请求上下文动态公开其站点到站点端点. 以下属性配置对等方应如何向客户端公开. 路由定义由4个属性组成，'when'，'hostname'，'port'和'secure'，按协议分组' 和'名字'. 可以配置多个路由定义. '协议' 表示站点到站点传输协议，即.Ë. 原始或http. 

|==== 
|*Property*|*描述* 
|Orchsym Studio.remote.route.{protocol}.{name}.when|布尔值，'true' 或'假'. 控制是否应使用此名称的路由定义. 
|Orchsym Studio.remote.route.{protocol}.{name}.hostname|指定将引入站点到站点客户端以进行进一步通信的主机名. 
|Orchsym Studio.remote.route.{protocol}.{name}.port|指定将引入站点到站点客户端以进行进一步通信的端口号. 
|Orchsym Studio.remote.route.{protocol}.{name}.secure|布尔值，'true' 或'假'. 指定是否应通过安全协议访问远程对等方. 默认为'false'. 
|==== 

以上所有路由属性都可以使用Orchsym Studio表达式语言从请求上下文计算目标对等项描述. 可用变量是: 

|=== 
|*Variable name*|*描述* 
|s2s.{source\|目标}.hostname |请求来源的主机名和原始目标. 
|s2s.{source\|目标}.port |与上面相同，用于端口. 源端口可能没有用，因为它只是一个客户端TCP端口. 
|s2s.{source\|目标}.安全|与上述相同，是否安全. 
|s2s.protocol|正在使用的站点到站点协议的名称，RAW或HTTP. 
|s2s.request|当前请求类型的名称，SiteToSiteDetail或Peers. 有关详细信息，请参阅下面的站点到站点协议序列. 
|HTTP request headers|HTTP请求标头值可以通过其名称引用. 
|=== 

==== 站点到站点协议序列 

正确配置这些属性需要对站点到站点协议序列有一些了解. 

1. 客户端通过向指定的远程URL发送HTTP(S)请求来获取远程集群站点到站点信息，从而启动站点到站点协议. 具体来说，到'/ Orchsym Studio-api / site-to-site'. 此请求称为"SiteToSiteDetail”. 
2. 远程Orchsym Studio节点响应其输入和输出端口，以及RAW和TCP传输协议的TCP端口号. 
3. 客户端使用＃2返回的TCP端口号发送另一个请求以获取远程对等方. 根据此请求，原始套接字通信用于RAW传输协议，而HTTP继续使用HTTP(S). 此请求称为"同行”. 
4. 远程Orchsym Studio节点响应包含主机名，端口，安全性和工作负载的可用远程对等体列表，例如排队的FlowFiles数量. 从这一点开始，在客户端和远程Orchsym Studio节点之间进行进一步的通信. 
五. 客户端根据工作负载信息决定从哪个对等方传输数据. 
6. 客户端向远程Orchsym Studio节点发送创建事务的请求. 
7. 远程Orchsym Studio节点接受该事务. 
8. 数据被发送到目标对等体. 可以批量发送多个数据包. 
9. 当没有更多数据要发送或达到批量限制时，通过计算发送数据的CRC32哈希来确认两端的事务. 
10. 该交易在两端都有承诺. 

==== 反向代理配置 

大多数反向代理软件都实现HTTP和TCP代理模式. 对于Orchsym Studio RAW站点到站点协议，需要HTTP和TCP代理配置，并且至少需要打开2个端口. Orchsym Studio HTTP站点到站点协议可以将反向代理所需的开放端口数量最小化为1. 

在反向代理中设置正确的HTTP标头对于Orchsym Studio正常工作至关重要，不仅可以路由请求，还可以授权客户端请求. 有关详细信息，另请参阅<<proxy_configuration>>. 

可以在反向代理服务器上应用两种类型的请求到Orchsym Studio节点映射技术. 一个是'节点的服务器名称' 另一个是'节点的端口号'. 

使用"服务器名称到节点”，可以使用相同的端口根据请求的服务器名称将请求路由到不同的上游Orchsym Studio节点(e.G. Orchsym Studio0.例.com，Orchsym Studio1.例.COM). 应将主机名解析配置为将不同的主机名映射到相同的反向代理地址，这可以通过添加/ etc / hosts文件或DNS服务器条目来完成. 此外，如果反向代理的客户端使用HTTPS，则反向代理服务器证书应具有通配符公用名或SAN，以便由不同的主机名访问. 

某些反向代理技术不支持服务器名称路由规则，在这种情况下，请使用"端口号到节点”' 技术. '节点的端口号' 映射要求Orchsym Studio集群的反向代理处的N开放端口由N个节点组成. 

有关实际配置，请参阅以下示例. 

==== 站点到站点和反向代理示例 

以下是一些示例反向代理和Orchsym Studio设置，以说明配置文件的外观. 

下图中的Client1表示无法直接访问Orchsym Studio节点的客户端，它通过反向代理进行访问，而Client2可以直接访问. 

在此示例中，Nginx用作反向代理. 

===== 例1:RAW - 服务器名称到节点映射 

image:s2s-rproxy-servername.svg["Server name to Node mapping"] 

1. Client1启动站点到站点协议，请求被路由到上游Orchsym Studio节点之一. Orchsym Studio节点计算RAW的站点到站点端口. 通过路由规则'example1' 在Orchsym Studio.如下所示的属性，返回端口10443. 
2. Client1要求对手'Orchsym Studio.例.com:10443'，请求被路由到'Orchsym Studio0:8081'. Orchsym Studio节点通过'example1计算可用的对等体' 路由规则，'Orchsym Studio0:8081' 转换为'Orchsym Studio0.例.com:10443'，Orchsym Studio1和Orchsym Studio2也是如此. 结果，'Orchsym Studio0.例.com:10443'，'Orchsym Studio1.例.COM:10443' 和'Orchsym Studio2.例.COM:10443' 退回. 
3. Client1决定使用'Orchsym Studio2.例.COM:10443' 进一步沟通. 
4. 另一方面，Client2有两个用于站点到站点引导URI的URI，并使用其中一个启动协议. 'example1' 路由与此请求不匹配，并返回端口8081. 
五. Client2向'Orchsym Studio1:​​8081'的同行询问. 'example1' 不匹配，所以原来'Orchsym Studio0:8081'，'Orchsym Studio1:​​8081' 和'Orchsym Studio2:8081' 按原样归还. 
6. Client2决定使用'Orchsym Studio2:8081' 进一步沟通. 

路由规则'example1' 在Orchsym Studio中定义.属性(所有节点具有相同的路由配置): 

.... 
# S2S Routing for RAW, using server name to node 
Orchsym Studio.remote.route.raw.example1.when=\ 
${X-ProxyHost:equals('Orchsym Studio.example.com'):or(\ 
${s2s.source.hostname:equals('Orchsym Studio.example.com'):or(\ 
${s2s.source.hostname:equals('192.168.99.100')})})} 
Orchsym Studio.remote.route.raw.example1.hostname=${s2s.target.hostname}.example.com 
Orchsym Studio.remote.route.raw.example1.port=10443 
Orchsym Studio.remote.route.raw.example1.secure=true 
.... 



nginx的.CONF 

.... 
http { 

    upstream Orchsym Studio { 
        server Orchsym Studio0:8443; 
        server Orchsym Studio1:8443; 
        server Orchsym Studio2:8443; 
    } 

    # Use dnsmasq so that hostnames such as 'Orchsym Studio0' can be resolved by /etc/hosts 
    resolver 127.0.0.1; 

    server { 
        listen 443 ssl; 
        server_name Orchsym Studio.example.com; 
        ssl_certificate /etc/nginx/nginx.crt; 
        ssl_certificate_key /etc/nginx/nginx.key; 

        proxy_ssl_certificate /etc/nginx/nginx.crt; 
        proxy_ssl_certificate_key /etc/nginx/nginx.key; 
        proxy_ssl_trusted_certificate /etc/nginx/Orchsym Studio-cert.pem; 

        location / { 
            proxy_pass https://Orchsym Studio; 
            proxy_set_header X-ProxyScheme https; 
            proxy_set_header X-ProxyHost nginx.example.com; 
            proxy_set_header X-ProxyPort 17590; 
            proxy_set_header X-ProxyContextPath /; 
            proxy_set_header X-ProxiedEntitiesChain $ssl_client_s_dn; 
        } 
    } 
} 

stream { 

    map $ssl_preread_server_name $Orchsym Studio { 
        Orchsym Studio0.example.com Orchsym Studio0; 
        Orchsym Studio1.example.com Orchsym Studio1; 
        Orchsym Studio2.example.com Orchsym Studio2; 
        default Orchsym Studio0; 
    } 

    resolver 127.0.0.1; 

    server { 
        listen 10443; 
        proxy_pass $Orchsym Studio:8081; 
    } 
} 
.... 


===== 例2:RAW - 端口号到节点映射 

image:s2s-rproxy-portnumber.svg["Port number to Node mapping"] 

'example2' 路由使用'equals和'ifElse将原始主机名(Orchsym Studio0,1和2)映射到不同的代理端口(10443,10444和10445)' 表达式. 

Orchsym Studio.属性(所有节点具有相同的路由配置) 

.... 
# S2S Routing for RAW, using port number to node 
Orchsym Studio.remote.route.raw.example2.when=\ 
${X-ProxyHost:equals('Orchsym Studio.example.com'):or(\ 
${s2s.source.hostname:equals('Orchsym Studio.example.com'):or(\ 
${s2s.source.hostname:equals('192.168.99.100')})})} 
Orchsym Studio.remote.route.raw.example2.hostname=Orchsym Studio.example.com 
Orchsym Studio.remote.route.raw.example2.port=\ 
${s2s.target.hostname:equals('Orchsym Studio0'):ifElse('10443',\ 
${s2s.target.hostname:equals('Orchsym Studio1'):ifElse('10444',\ 
${s2s.target.hostname:equals('Orchsym Studio2'):ifElse('10445',\ 
'undefined')})})} 
Orchsym Studio.remote.route.raw.example2.secure=true 
.... 


nginx的.CONF 

.... 
http { 
    # Same as example 1. 
} 

stream { 

    map $ssl_preread_server_name $Orchsym Studio { 
        Orchsym Studio0.example.com Orchsym Studio0; 
        Orchsym Studio1.example.com Orchsym Studio1; 
        Orchsym Studio2.example.com Orchsym Studio2; 
        default Orchsym Studio0; 
    } 

    resolver 127.0.0.1; 

    server { 
        listen 10443; 
        proxy_pass Orchsym Studio0:8081; 
    } 
    server { 
        listen 10444; 
        proxy_pass Orchsym Studio1:8081; 
    } 
    server { 
        listen 10445; 
        proxy_pass Orchsym Studio2:8081; 
    } 
} 
.... 


===== 示例3:HTTP - 服务器名称到节点映射 

image:s2s-rproxy-http.svg["Server name to Node mapping"] 

Orchsym Studio.属性(所有节点具有相同的路由配置) 

.... 
# S2S Routing for HTTP 
Orchsym Studio.remote.route.http.example3.when=${X-ProxyHost:contains('.example.com')} 
Orchsym Studio.remote.route.http.example3.hostname=${s2s.target.hostname}.example.com 
Orchsym Studio.remote.route.http.example3.port=443 
Orchsym Studio.remote.route.http.example3.secure=true 
.... 


nginx的.CONF 

.... 
http { 
    upstream Orchsym Studio_cluster { 
        server Orchsym Studio0:8443; 
        server Orchsym Studio1:8443; 
        server Orchsym Studio2:8443; 
    } 

    # If target node is not specified, use one from cluster. 
    map $http_host $Orchsym Studio { 
        Orchsym Studio0.example.com:443 "Orchsym Studio0:8443"; 
        Orchsym Studio1.example.com:443 "Orchsym Studio1:8443"; 
        Orchsym Studio2.example.com:443 "Orchsym Studio2:8443"; 
        default "Orchsym Studio_cluster"; 
    } 

    resolver 127.0.0.1; 

    server { 
        listen 443 ssl; 
        server_name ~^(.+\.example\.com)$; 
        ssl_certificate /etc/nginx/nginx.crt; 
        ssl_certificate_key /etc/nginx/nginx.key; 

        proxy_ssl_certificate /etc/nginx/nginx.crt; 
        proxy_ssl_certificate_key /etc/nginx/nginx.key; 
        proxy_ssl_trusted_certificate /etc/nginx/Orchsym Studio-cert.pem; 

        location / { 
            proxy_pass https://$Orchsym Studio; 
            proxy_set_header X-ProxyScheme https; 
            proxy_set_header X-ProxyHost $1; 
            proxy_set_header X-ProxyPort 443; 
            proxy_set_header X-ProxyContextPath /; 
            proxy_set_header X-ProxiedEntitiesChain $ssl_client_s_dn; 
        } 
    } 
} 
.... 



=== Web属性 

这些属性与基于Web的用户界面有关. 

|==== 
|*Property*|*描述* 
|Orchsym Studio.web.war.directory|这是web war目录的位置. 默认值为 `./lib`. 
|Orchsym Studio.web.http.host|HTTP主机. 默认为空白. 
|Orchsym Studio.web.http.port|HTTP端口. 默认值为 `8080`. 
|Orchsym Studio.web.http.port.forwarding|将传入的HTTP请求转发到的端口 `Orchsym Studio.web.http.host`. 此属性旨在与"端口转发”一起使用，当Orchsym Studio必须由非root用户启动以获得更好的安全性时，需要通过低端口访问以通过防火墙. 例如，要在端口80上通过HTTP协议公开Orchsym Studio，但实际上在端口8080上侦听，则需要配置操作系统级端口转发，例如 `iptables` (Linux / Unix)或 `pfctl` (OS X)将请求从80重定向到8080. 然后设置 `Orchsym Studio.web.http.port` 作为8080，和 `Orchsym Studio.web.http.port.forwarding` 为80. 默认为空白. 
|Orchsym Studio.web.http.network.interface*|Orchsym Studio应为HTTP请求绑定的网络接口的名称. 默认为空白. + 
+ 
*注意*:可以使用指定多个网络接口 *_Orchsym Studio.web.http.network.interface._* 带有唯一后缀的前缀和作为值的单独网络接口名称. + 
+ 
例如，要提供两个额外的网络接口，用户还可以使用以下键指定其他属性: + 
+ 
Orchsym Studio.卷筒纸.HTTP.网络.接口.的eth0 = eth0的 + 
Orchsym Studio.卷筒纸.HTTP.网络.接口.ETH1 = ETH1 + 
+ 
提供三个总网络接口，包括  `Orchsym Studio.web.http.network.interface.default`. 
|Orchsym Studio.web.https.host|HTTPS主机. 默认为空白. 
|Orchsym Studio.web.https.port|HTTPS端口. 默认为空白. 配置Orchsym Studio以安全运行时，应配置此端口. 
|Orchsym Studio.web.https.port.forwarding|与...一样 `Orchsym Studio.web.http.port.forwarding`，但使用HTTPS进行安全通信. 默认为空白. 
|Orchsym Studio.web.https.network.interface*|Orchsym Studio应为HTTPS请求绑定的网络接口的名称. 默认为空白. + 
+ 
*注意*:可以使用指定多个网络接口 *_Orchsym Studio.web.https.network.interface._* 带有唯一后缀的前缀和作为值的单独网络接口名称. + 
+ 
例如，要提供两个额外的网络接口，用户还可以使用以下键指定其他属性: + 
+ 
Orchsym Studio.卷筒纸.HTTPS.网络.接口.的eth0 = eth0的 + 
Orchsym Studio.卷筒纸.HTTPS.网络.接口.ETH1 = ETH1 + 
+ 
提供三个总网络接口，包括  `Orchsym Studio.web.https.network.interface.default`. 
|Orchsym Studio.web.jetty.working.directory|Jetty工作目录的位置. 默认值为 `./work/jetty`. 
|Orchsym Studio.web.jetty.threads|Jetty线程的数量. 默认值为 `200`. 
|Orchsym Studio.web.max.header.size|请求和响应标头允许的最大大小. 默认值为16 KB. 
|Orchsym Studio.web.proxy.host|以逗号分隔的允许的HTTP主机标头值列表，以便在Orchsym Studio安全运行时考虑，并将接收对其他主机的请求[:port] 比它必然. 
例如，在Docker容器中运行或在代理后面运行(例如，.G. localhost:18443，proxyhost:443).默认情况下，此值为空，表示Orchsym Studio应仅允许发送给
主机的请求 [:port] Orchsym Studio必然会受到影响. 
|Orchsym Studio.web.proxy.context.path|要考虑的允许HTTP X-ProxyContextPath或X-Forwarded-Context标头值的逗号分隔列表.默认情况下，此值为 
空，表示拒绝包含代理上下文路径的所有请求. 配置此属性将允许此列表中包含代理路径的请求. 
|==== 

=== 安全属性 

这些属性适用于Orchsym Studio中的各种安全功能.
本管理员指南的"安全配置”部分详细介绍了其中许多属性 . 

|==== 
|*Property*|*描述* 
|Orchsym Studio.sensitive.props.key|这是用于加密组件中配置的任何敏感属性值的密码. 默认情况下，它为空，但系统管理员应为其提供值. 它可以是任意长度的字符串，但建议的最小长度为10个字符. 请注意，一旦设置了此密码并且配置了一个或多个敏感组件属性，则不应更改此密码. 
|Orchsym Studio.sensitive.props.algorithm|用于加密敏感属性的算法. 默认值为 `PBEWITHMD5AND256BITAES-CBC-OPENSSL`. 
|Orchsym Studio.sensitive.props.provider|敏感的财产提供者. 默认值为 `BC`. 
|Orchsym Studio.sensitive.props.additional.keys|逗号分隔的属性列表 `Orchsym Studio.properties` 加密除默认敏感属性外(参见<<encrypt-config_tool>>). 
|Orchsym Studio.security.keystore*|密钥库的完整路径和名称. 默认为空白. 
|Orchsym Studio.security.keystoreType|密钥库类型. 默认为空白. 
|Orchsym Studio.security.keystorePasswd|密钥库密码. 默认为空白. 
|Orchsym Studio.security.keyPasswd|密钥密码. 默认为空白. 
|Orchsym Studio.security.truststore*|信任库的完整路径和名称. 默认为空白. 
|Orchsym Studio.security.truststoreType|信任库类型. 默认为空白. 
|Orchsym Studio.security.truststorePasswd|信任库密码. 默认为空白. 
|Orchsym Studio.security.needClientAuth|这表示是否在群集协议中进行客户端身份验证. 默认为空白. 
|Orchsym Studio.security.user.authorizer|指定授权程序中配置的授权程序.要使用的xml文件.  默认情况下，它设置为 `file-provider`. 
|Orchsym Studio.security.user.login.identity.provider|这表示要使用的登录标识提供程序类型.默认值为空，可以从
指定文件中的提供程序设置为标识符 `Orchsym Studio.login.identity.provider.configuration.file`. 设置此属性将触发Orchsym Studio以支持用户名/密码身份验证. 
|Orchsym Studio.security.ocsp.responder.url|这是在线证书状态协议(OCSP)响应程序的URL(如果正在使用). 默认为空白. 
|Orchsym Studio.security.ocsp.responder.certificate|这是OCSP响应者证书的位置(如果正在使用). 默认为空白. 
|==== 

=== 身份映射属性 

这些属性可用于规范用户身份.  实施后，由不同身份提供商(证书，LDAP，Kerberos)进行身份验证的身份在Orchsym Studio内部处理相同.  因此，避免了重复的用户，并且每个用户只需要设置一次特定于用户的配置(例如授权). 

以下示例演示了如何从证书和Kerberos的主体中规范化DN: 


---- 
Orchsym Studio.security.identity.mapping.pattern.dn=^CN=(.*?), OU=(.*?), O=(.*?), L=(.*?), ST=(.*?), C=(.*?)$ 
Orchsym Studio.security.identity.mapping.value.dn=$1@$2 
Orchsym Studio.security.identity.mapping.transform.dn=NONE 
Orchsym Studio.security.identity.mapping.pattern.kerb=^(.*?)/instance@(.*?)$ 
Orchsym Studio.security.identity.mapping.value.kerb=$1@$2 
Orchsym Studio.security.identity.mapping.transform.kerb=NONE 
---- 


每个属性的最后一段是用于将模式与替换值相关联的标识符.  当用户向Orchsym Studio发出请求时，将检查其身份以查看它是否与字典顺序中的每个模式匹配.  对于匹配的第一个，替换中指定的替换 `Orchsym Studio.security.identity.mapping.value.xxxx` 财产被使用. 所以登录用 `CN=localhost, OU=Orchsym Studio, O=Apache, L=Santa Monica, ST=CA, C=US` 匹配上面的DN映射模式和DN映射值 `$1@$2` 被申请;被应用.  用户标准化为 `localhost@Orchsym Studio`. 

除了映射之外，可以应用变换. 支持的版本是NONE(未应用转换)，LOWER(标识小写)和UPPER(标识大写). 如果未指定，则默认值为NONE. 

NOTE: 这些映射还应用于"初始管理员标识”，"群集节点标识”以及授权程序中的任何旧版用户.xml文件以及从LDAP导入的用户(请参阅<<authorizers-setup>>). 

组名也可以映射. 以下示例将接受现有的组名称，但会将其小写. 与外部授权人一起使用时，这可能会有所帮助. 


---- 
Orchsym Studio.security.group.mapping.pattern.anygroup=^(.*)$ 
Orchsym Studio.security.group.mapping.value.anygroup=$1 
Orchsym Studio.security.group.mapping.transform.anygroup=LOWER 
---- 


NOTE: 这些映射适用于授权程序中引用的任何旧组.xml以及从LDAP导入的组. 

=== 群集公共属性 

设置Orchsym Studio群集时，应在所有节点上以相同方式配置这些属性. 

|==== 
|*Property*|*描述* 
|Orchsym Studio.cluster.protocol.heartbeat.interval|节点应向群集协调器发出心跳的时间间隔. 默认值为 `5 sec`. 
|Orchsym Studio.cluster.protocol.is.secure|这表明群集通信是否安全. 默认值为 `false`. 
|==== 

=== 群集节点属性 

为群集节点配置这些属性. 

|==== 
|*Property*|*描述* 
|Orchsym Studio.cluster.is.node|将此设置为 `true` 如果实例是群集中的节点. 默认值为 `false`. 
|Orchsym Studio.cluster.node.address|节点的完全限定地址. 默认为空白. 
|Orchsym Studio.cluster.node.protocol.port|节点的协议端口. 默认为空白. 
|Orchsym Studio.cluster.node.protocol.threads|应该用于与
群集中的其他节点通信的线程数 . 此属性默认为 `10`，但对于大型集群，此值可能需要更大. 
|Orchsym Studio.cluster.node.protocol.max.threads|应该用于与群集中其他节点通信的最大线程数. 此属性默认为 `50`. 
|Orchsym Studio.cluster.node.event.history.size|更改群集中节点的状态时，将生成一个事件
，并可在"群集”页面中查看该事件 . 此值指示每个节点在内存中保留的事件数. 默认值为 `25`. 
|Orchsym Studio.cluster.node.connection.timeout|连接到群集中的另一个节点时，指定此节点在考虑
连接失败之前应等待的时间 . 默认值为 `5 secs`. 
|Orchsym Studio.cluster.node.read.timeout|与群集中的另一个节点通信时，指定此
节点在考虑与节点通信失败之前应等待多长时间从远程节点接收信息 . 默认值为 `5 secs`. 
|Orchsym Studio.cluster.firewall.file|节点防火墙文件的位置.这是一个文件，可用于列出允许连接
到群集的所有节点 . 它提供了额外的安全层. 默认情况下，此值为空，表示不使用防火墙文件. 
|Orchsym Studio.cluster.flow.election.max.wait.time|指定在选择Flow作为"正确”流之前等待的时间量. 如果已投票的节点数等于该指定的数量 `Orchsym Studio.cluster.flow.election.max.candidates` 财产，集群不会等这么久. 默认值为 `5 mins`. 请注意，第一次投票后，时间就会开始. 
|Orchsym Studio.cluster.flow.election.max.candidates|指定群集中所需的节点数，以便提前选择流. 这允许群集中的节点避免在开始处理之前等待很长时间，如果我们至少达到群集中的此数量的节点. 
|==== 

[[claim_management]] 
=== 声明管理 

每当请求更改数据流时，重要的是 
Orchsym Studio群集中的所有节点保持同步. 为了实现这一点，Orchsym Studio采用了两阶段提交.首先将请求 
复制到群集中的所有节点，只是询问是否允许该请求.然后，每个节点确定 
它是否允许该请求，如果是，则对正在修改的组件发出"声明”.可以将此声明 
视为请求者拥有的互斥锁.一旦所有节点都对是否
允许请求进行了投票， 发起请求的节点必须决定是否完成请求.如果任何节点投票 
'否' 然后取消请求并取消声明，并将错误消息发送回用户.但是，如果节点 
都投票'是' 然后请求完成.在这种分布式环境中，
在投票发生之后和请求完成之前，发出原始请求的节点可能 会失败.这将使 
组件无限期地锁定，以便不再对组件进行更改.为了避免这种情况，索赔 
将在一段时间后超时. 这些属性确定如何管理这些锁. 

|==== 
|*Property*|*描述* 
|Orchsym Studio.cluster.request.replication.claim.timeout|指定在考虑锁定已过期之前等待的时间' 并自动 
解锁. 
|==== 


=== ZooKeeper属性 

Orchsym Studio依赖于Apache ZooKeeper来确定集群中
哪个节点应该扮演主节点的角色 以及哪个节点应该扮演集群协调器的角色.必须配置这些属性才能使Orchsym Studio 
加入群集. 

|==== 
|*Property*|*描述* 
|Orchsym Studio.zookeeper.connect.string|连接到Apache ZooKeeper所需的连接字符串.这是一个以逗号分隔
的hostname:port对列表 . 例如， `localhost:2181,localhost:2182,localhost:2183`.这应该包含
ZooKeeper仲裁中所有ZooKeeper 实例的列表 . 必须指定此属性才能加入群集，并且没有默认值. 
|Orchsym Studio.zookeeper.connect.timeout|在考虑连接失败之前连接到ZooKeeper需要等待多长时间. 默认值为 `3 secs`. 
|Orchsym Studio.zookeeper.session.timeout|在会话过期之前丢失与ZooKeeper的连接后等待多长时间. 默认值为 `3 secs`. 
|Orchsym Studio.zookeeper.root.node|应该在ZooKeeper中使用的根ZNode.ZooKeeper提供了一个类似目录的结构 
来存储数据. 每个'目录' 在这种结构中称为ZNode.这表示
应该用于存储数据的根ZNode或"目录” . 默认值为 `/root`.这对于正确设置很重要，因为
Orchsym Studio实例尝试加入的集群 取决于它连接到哪个ZooKeeper实例以及
指定的ZooKeeper根节点 . 
|==== 

[[kerberos_properties]] 
=== Kerberos属性 

|==== 
|*Property*|*描述* 
|Orchsym Studio.kerberos.krb5.file*|krb5文件的位置(如果使用). 默认为空白.此时，
    每个Orchsym Studio实例只允许指定一个krb5文件 ，因此此属性在此处配置为支持SPNEGO和服务主体，而不是在单个组件中. 
    如有必要，krb5文件可以支持多个领域. 
    例: `/etc/krb5.conf` 
|Orchsym Studio.kerberos.service.principal*|Orchsym Studio Kerberos服务主体的名称(如果使用). 默认为空白. 请注意，此属性适用于Orchsym Studio作为客户端其他系统进行身份验证. 
   例: `Orchsym Studio/Orchsym Studio.example.com` 要么 `Orchsym Studio/Orchsym Studio.example.com@EXAMPLE.COM` 
|Orchsym Studio.kerberos.service.keytab.location*|Orchsym Studio Kerberos密钥表的文件路径(如果使用). 默认为空白. 请注意，此属性适用于Orchsym Studio作为客户端其他系统进行身份验证. 
  例: `/etc/Orchsym Studio.keytab` 
|Orchsym Studio.kerberos.spnego.principal*|Orchsym Studio Kerberos服务主体的名称(如果使用). 默认为空白. 请注意，此属性用于验证Orchsym Studio用户. 
   例: `HTTP/Orchsym Studio.example.com` 要么 `HTTP/Orchsym Studio.example.com@EXAMPLE.COM` 
|Orchsym Studio.kerberos.spnego.keytab.location*|Orchsym Studio Kerberos密钥表的文件路径(如果使用). 默认为空白. 请注意，此属性用于验证Orchsym Studio用户. 
  例: `/etc/http-Orchsym Studio.keytab` 
|Orchsym Studio.kerberos.spengo.authentication.expiration*|成功使用Kerberos用户身份验证的到期持续时间(如果使用). 默认值为 `12 hours`. 
|==== 

[[custom_properties]] 
=== 自定义属性 

要配置与Orchsym Studio表达式语言一起使用的自定义属性: 

* 创建自定义属性. 确保这件事: 
** 每个自定义属性都包含一个不同的属性值，因此它不会被现有的环境属性，系统属性或FlowFile属性覆盖. 
** 群集环境中的每个节点都配置有相同的自定义属性. 
* 更新 `Orchsym Studio.variable.registry.properties` 与自定义属性文件的位置: 

|==== 
|*Property*|*描述* 
|Orchsym Studio.variable.registry.properties|这是一个逗号分隔的一个或多个自定义属性文件的文件位置路径列表. 
|==== 

* 重新启动Orchsym Studio实例以获取要更新的更新. 

也可以在Orchsym Studio UI中配置自定义属性.  请参阅<<用户指南.有关详细信息，请参阅"用户指南”中的adoc＃Variables_Window，Variables Window>>部分. 

[WARNING] 
.升级 
============ 
配置上面标有星号的属性时要小心(*). 要使升级过程更容易，建议将默认配置更改为主根安装目录之外的位置. 通过这种方式，这些项目可以通过升级保留在其配置的位置，并且Orchsym Studio可以找到所有存储库和配置文件，并在旧版本停止并且新版本启动后立即从中断处继续. 此外，管理员可以重复使用它 _Orchsym Studio.properties_ 文件和任何其他配置文件，而不必在每次升级时重新配置它们. 如前所述，检查中的任何变化都很重要 _Orchsym Studio.properties_ 升级时新版本的文件，并确保它们反映在 _Orchsym Studio.properties_ 您使用的文件. 
============ 
