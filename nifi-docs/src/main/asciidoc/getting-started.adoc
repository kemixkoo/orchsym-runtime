// 
// Licensed to the Apache Software Foundation (ASF) under one or more 
// contributor license agreements.  See the NOTICE file distributed with 
// this work for additional information regarding copyright ownership. 
// The ASF licenses this file to You under the Apache License, Version 2.0 
// (the "License"); you may not use this file except in compliance with 
// the License.  You may obtain a copy of the License at 
// 
//     http://www.apache.org/licenses/LICENSE-2.0 
// 
// Unless required by applicable law or agreed to in writing, software 
// distributed under the License is distributed on an "AS IS" BASIS, 
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
// See the License for the specific language governing permissions and 
// limitations under the License. 
// 
= Orchsym Studio使用指南 
Orchsym Studio团队<orchsym@baishancloud.com> 
:homepage: https://www.baishancloud.com/ 
:linkattrs: 


== 本指南适合谁？

本指南适用于需要在Orchsym Studio中有限度地使用或仅完成特定任务的用户。本指南旨在为用户提供所需的基础信息，以便了解如何使用Orchsym Studio，从而快速轻松地构建强大而灵活的数据流。

因为本指南中的某些信息仅适用于初次使用的用户，而其他信息则可能适用于那些使用过Orchsym Studio的人，所以本指南分为几个不同的部分，读者可能觉得某些部分没用，请随意跳转到最适合您的部分。

本指南假设用户已经基本了解Orchsym Studio是什么。相关的基本知识可以在link:overview.html[总览]文档里查阅。




== 本指南中使用的术语 

为了讨论Orchsym Studio，读者应该熟悉一些关键术语。我们将在此概括解释这些特定的Orchsym Studio术语。


*流文件*: 每一片“用户数据”（例如，用户带入Orchsym Studio进行处理和分发的数据）都可归结为流文件。流文件由两部分组成：属性和内容。内容是用户数据本身。属性是与用户数据关联的键值对。 

*组件*: 组件是Orchsym Studio的一种元件，负责创建，发送，接收，转换，路由，拆分，合并和处理流文件。它是Orchsym Studio用户可用于构建其数据流的最重要的构建块。


== 安装和部署Orchsym Studio 

请联系蜂巢运维部署团队实施安装和部署。

如果需要了解Orchsym Studio的高级配置信息（例如，配置安全性，数据存储配置或运行Orchsym Studio的端口），请参阅link:administration-guide.html[管理手册]。 


== 启动Orchsym Studio 

安装Orchsym Studio后，可以使用适合您操作系统的机制启动它。

=== 对于Windows用户 

对于Windows用户，请导航到安装Orchsym Studio的根文件夹。在此文件夹中有一个名为的子文件夹 `bin`。 导航到此子文件夹，然后双击 `run-orchsym.bat` 文件. 

这将启动Orchsym Studio并让它在前台运行。要关闭Orchsym Studio，请选择已启动的窗口，然后在按住C的同时按住Ctrl键。


=== 对于Linux / Mac OS X用户 

对于Linux和OS X用户，使用终端窗口导航到安装Orchsym Studio的根目录。要在前台运行Orchsym Studio，请运行 `bin/orchsym.sh run`。这将使应用程序持续运行，直到用户按下Ctrl-C，届时，它将执行应用程序的关闭。

要在后台运行Orchsym Studio，请运行 `bin/orchsym.sh start`。这将启动应用程序以开始运行。要检查状态并查看Orchsym Studio当前是否正在运行，请执行该命令 `bin/orchsym.sh status`。可以通过执行命令 `bin/orchsym.sh stop` 关闭Orchsym Studio。 


=== 安装为服务

目前仅支持Linux和Mac OS X用户安装Orchsym Studio作为服务。要将应用程序作为服务安装，请导航到"终端”窗口中的安装目录并执行该命令 `bin/orchsym.sh install` 使用默认名称安装服务。要为服务指定自定义名称，请使用可选的第二个参数(该服务的名称)执行该命令。例如，要将Orchsym Studio安装为服务 `dataflow`，请使用命令 `bin/orchsym.sh install dataflow`。

安装后，可以使用适当的命令启动和停止服务，例如 `sudo service orchsym start` 和 `sudo service orchsym stop`。此外，可以通过检查运行状态 `sudo service orchsym status` 。 



== 我已经启动了Orchsym Studio，接下来怎么办？ 

现在Orchsym Studio已经启动，我们可以调出用户界面(UI)来创建和监控我们的数据流。要开始使用，请打开Web浏览器并导航到  link:http://localhost:8080/[`http://localhost:8080/`^]。可以通过编辑 `conf` 目录下的 `orchsym.properties` 来更改端口，默认端口是8080。 

这将打开用户界面，此时这是一个用于编排数据流的空白画布: 

image:new-flow.png["New Flow"] 

用户界面有多种工具可用于创建和管理您的第一个数据流: 

image:studio-toolbar-components.png["Toolbar Components"] 

全局菜单包含以下选项: 

image:global-menu.png["Global Menu"] 


=== 添加组件 

我们现在可以通过在画布中添加组件来开始创建数据流。为此，请从屏幕的右方选择并拖动组件到画布的中间(类似纸的背景)并将其放在那里。

image:add-processor.png["Add Processor"] 

有很多组件可供选择。我们可以通过在对话框右上角的"所有组件”框中输入组件名称进行过滤。我们也可以进入每个大类里面搜索和查找对应组件。

比如我们搜索出GetFile组件并拖入画布。

=== 配置组件 

现在我们已经添加了的GetFile组件，我们可以在组件上通过右键然后选择 `配置` 菜单项。弹出的对话框允许我们配置许多不同的选择，请参阅link:user-guide.html[用户手册]了解更多配置，在本指南中，我们将重点关注"属性”选项卡。一旦属性选项卡被选中，一组属性列表将显示出来。可用的属性取决于组件的类型，并且每种类型的属性列表通常都不同。粗体属性是必需属性。在配置完所有必需属性之前，无法启动组件。为GetFile配置的最重要的属性是文件的目录。如果我们将目录名称设置为 `./data-in`，这将导致组件开始提取主目录下的`data-in` 子目录中的任何数据。我们可以选择为此组件配置多个不同的属性。如果不确定特定属性的作用，我们可以将鼠标悬停在属性名旁边的"帮助”图标上(image:iconInfo.png["Help"]) 来获取提示信息。此外，将鼠标悬停在"帮助”图标上时显示的工具提示将提供该属性的默认值(如果存在)，属性是否支持表达式语言(请参阅下面的 <<ExpressionLanguage>>部分)，以及该属性配置的可选值。

要使此属性生效，请创建一个名为的目录 `data-in` 在Orchsym Studio主目录中然后单击 `Ok` 按钮关闭对话框。 


=== 连接组件 

每个组件都有一组可以发送数据的“关联”。组件完成流文件的处理后，会将其传输到其中一个关联。这允许用户根据处理的结果配置如何操作流文件。例如，许多组件定义了两个关联: `success` 和 `failure`。这样用户就能够为组件成功处理数据和无法处理数据的情况配置不同的路由，当然，用户也可以根据情况，简单地将两个关联（成功和失败）都配置到相同的路由。

现在我们已经添加并配置了我们的GetFile组件并应用了配置，我们可以在组件的左上角看到 一个警告图标（image:iconAlert.png[Alert]）表示组件未处于有效状态。将鼠标悬停在此图标上即可看到 `success` 关联尚未确定。这只是意味着我们没有告诉Orchsym Studio如何处理组件转移到的数据 `success` 关联。

为了解决这个问题，让我们按照上面的相同步骤添加另一个可以连接GetFile组件的组件。但是这一次，我们只需log流文件的一些属性。为此，我们将添加一个LogAttributes组件。

我们现在可以将GetFile组件的输出发送到LogAttribute组件。使用鼠标和连接图标将鼠标悬停在GetFile组件上，（image:iconConnection.png[Connection]）将出现在组件的中间。我们可以将此图标从GetFile组件拖到LogAttribute组件。这时弹出一个对话框，用于选择我们要为此连接包含哪些关联。因为GetFile只有一个关联， `success`，系统会自动为我们选中。

单击"设置”选项卡，可以看到提供了一些用于配置此连接行为方式的选项: 

image:connection-settings.png[Connection Settings] 

如果我们愿意，我们可以给Connection起一个名字。否则，连接名将基于所选的关联自动创建。我们还可以设置数据的到期时间。默认情况下，它设置为"0秒”，表示数据不应过期。但是，我们可以更改该值，以便当此Connection中的数据达到特定时长时，它将自动删除(并且将创建相应的溯源过期事件)。 

背压阈值允许我们指定在不再安排源组件运行之前允许队列的完整程度。这使我们能够处理一个组件生成数据比下一个组件消耗该数据更快的情况。如果在整个过程中为每个连接配置了背压，则将数据带入系统的组件最终将经历背压并停止引入新数据，以便我们的系统恢复。

最后，在右侧有优先顺序。这允许我们控制如何排序此队列中的数据。我们可以将优先级从"可用的优先级排序器”列表拖到"选定的优先级排序器”列表中，以激活优先级。如果激活了多个优先级排序器，系统将对它们进行评估，首先根据第一个优先级排序器评估，如果根据第一个优先级排序器确定两个流文件优先级相同，则将使用第二个优先级排序器。

我们只需点击 `添加` 即可将Connection添加到我们的图表中。我们现在应该看到警报图标已更改为已停止图标（image:iconStop.png[Stopped]）。但是，LogAttribute组件现在无效，因为它 `success` 的关联与任何事情都没有联系。让我们通过发信号通知路由过来的数据来解决这个问题。也就是说告诉Orchsym Studio考虑流文件通过LogAttribute的`success`后应该“自动终止”并“删除”数据。为此，我们需要配置LogAttribute组件。在“设置”选项卡的右侧，我们可以选中“自动终止关联”下面的 `success`前面的复选框。点击 `OK` 将关闭对话框并显示两个组件现在都已停止。


=== 启动和停止组件 

此时，我们的图表上有两个组件，但没有任何事情发生。为了启动组件，我们可以单独单击每个组件，然后右键单击并选择 `开始` 菜单项。或者，我们可以选择第一个组件，然后在选择其他组件的同时按住Shift键以选择多个。然后，我们可以右键单击并选择 `开始` 菜单项。或者，我们可以选择组件，然后单击"操作”调板中的"开始”图标。

一旦启动，组件左上角的图标将从停止的图标变为正在运行的图标。然后我们可以通过使用操作面板中的停止图标或者右键菜单的 `停止` 选项来停止组件。

组件启动后，我们无法再配置它。但是，当我们右键单击组件时，我们可以选择查看其当前配置。为了配置组件，我们必须首先停止组件并等待可能正在执行的任何任务完成。当前正在执行的任务数显示在组件的右上角附近，但如果当前没有任务，则不会显示任何内容。


=== 其他元件 

用户可以拖放到图表上的工具还包括可用于构建数据流的其他几个元件。这些元件包括输入端口和输出端口，漏斗，模块和远程模块。由于本文档的预期范围，我们不会在此讨论这些元素，用户可以在link:user-guide.html[用户手册]中的link:user-guide.html#building-dataflow[创建一个dataflow] 中找到相关信息。



== 可用的组件 

为了创建有效的数据流，用户必须了解可用的组件类型。Orchsym Studio包含许多不同的组件。这些组件提供了从众多不同系统中提取数据，路由，转换，处理，拆分和聚合数据，以及将数据分发到多个系统的功能。

这里我们将重点介绍一些最常用的组件：

=== 数据转换 
- *CompressContent*: 压缩或解压缩内容
- *ConvertCharacterSet*: 将用于编码内容的字符集从一个字符集转换为另一个字符集
- *EncryptContent*: 加密或解密内容
- *ReplaceText*: 使用正则表达式修改文本内容
- *TransformXML*: 将XSLT转换应用于XML内容
- *JoltTransformJSON*: 应用JOLT规范来转换JSON内容

=== 路由和调解 
- *ControlRate*: 限制某部分数据流的速率
- *DetectDuplicate*: 根据一些用户定义的标准监视重复的流文件。通常与HashContent一起使用
- *DistributeLoad*: 通过仅将一部分数据分发到用户定义的关联来实现负载均衡或样本抽取
- *MonitorActivity*: 当用户定义的时间段超时而没有任何数据通过流中的特定点时发送通知。(可选)在数据流恢复时发送通知. 
- *RouteOnAttribute*: 根据流文件包含的属性路由流文件。
- *ScanAttribute*: 扫描流文件上用户定义的属性集，检查是否有任何属性与用户定义的字典中找到的术语匹配。
- *RouteOnContent*: 搜索流文件的内容以查看它是否与任何用户定义的正则表达式匹配。如果是，则流文件将被路由到已配置的关联上。
- *ScanContent*: 搜索流文件的内容，以查找用户定义的字典中存在的术语，并根据这些术语的存在与否来路由。字典可以包含文本条目或二进制条目。
- *ValidateXml*: 针对XML Schema验证XML内容；根据流文件内容是否有效来路由流文件。 

=== 数据库访问 
- *ConvertJSONToSQL*: 将JSON文档转换为SQL INSERT或UPDATE命令，然后可以将其传递给PutSQL组件
- *ExecuteSQL*: 执行用户定义的SQL SELECT命令，将结果写入Avro格式的流文件
- *PutSQL*: 通过执行流文件内容定义的SQL DDM语句来更新数据库
- *SelectHiveQL*: 对Apache Hive数据库执行用户定义的HiveQL SELECT命令，将结果写入Avro或CSV格式的流文件
- *PutHiveQL*: 通过执行流文件内容定义的HiveQL DDM语句来更新Hive数据库

[[AttributeExtraction]] 
=== 属性提取 
- *EvaluateJsonPath*: 用户提供JSONPath表达式(类似于XPath，用于XML解析/提取)，然后根据JSON内容评估这些表达式 ，以替换流文件内容或将值提取到用户命名的属性中。 
- *EvaluateXPath*: 用户提供XPath表达式，然后根据XML内容评估这些表达式，以替换流文件内容或将值提取到用户命名的属性中。
- *EvaluateXQuery*: 用户提供XQuery查询，然后根据XML内容评估此查询，以替换流文件内容或将值提取到用户命名的属性中。
- *ExtractText*: 用户提供一个或多个正则表达式，然后根据流文件的文本内容对其进行评估，然后将提取的值添加到用户命名的属性中。
- *HashAttribute*: 对用户定义的现有属性列表的串联执行散列函数。
- *HashContent*: 对流文件的内容执行散列函数，并将散列值添加为Attribute。
- *IdentifyMimeType*: 评估流文件的内容，以确定流文件封装的文件类型。此组件能够检测许多不同的MIME类型，例如图像，文字组件文档，文本和压缩格式等等。
- *UpdateAttribute*: 向流文件添加或更新任意数量的用户定义属性。这对于添加静态配置的值以及使用表达式语言动态地派生属性值非常有用。该组件还提供"高级用户界面”，允许用户根据用户提供的规则有条件地更新属性。

=== 系统交互 
- *ExecuteProcess*: 运行用户定义的操作系统命令。进程的StdOut被重定向，以便写入StdOut的内容成为出站流文件的内容。此组件是源组件 - 它的输出预计会生成一个新的流文件，系统调用预计不会收到任何输入。为了向进程提供输入，请使用ExecuteStreamCommand组件。

- *ExecuteStreamCommand*: 运行用户定义的操作系统命令。流文件的内容可选地流式传输到进程的StdIn。写入StdOut的内容将成为出站流文件的内容。此组件不能用作源组件 - 必须输入传入的流文件才能执行其工作。要使用源组件执行相同类型的功能，请参阅ExecuteProcess组件。

=== 数据摄取 
- *GetFile*: 将文件的内容从本地磁盘(或网络连接的磁盘)流式传输到Orchsym Studio，然后删除原始文件。此组件应将文件从一个位置移动到另一个位置，而不是用于复制数据。
- *GetFTP*: 通过FTP将远程文件的内容下载到Orchsym Studio中，然后删除原始文件。此组件将数据从一个位置移动到另一个位置，而不是用于复制数据。
- *GetSFTP*: 通过SFTP将远程文件的内容下载到Orchsym Studio中，然后删除原始文件。此组件将数据从一个位置移动 到另一个位置，而不是用于复制数据。
- *GetJMSQueue*: 从JMS队列下载消息，并根据JMS消息的内容创建流文件。可选地，JMS属性也可以作为属性复制。
- *GetJMSTopic*: 从JMS主题下载消息，并根据JMS消息的内容创建流文件。可选地，JMS属性也可以作为属性复制。此组件支持持久订阅和非持久订阅。
- *GetHTTP*: 下载远程HTTP的内容- 或基于HTTPS的URL进入Orchsym Studio。该组件将记住ETag和Last-Modified日期，以确保不会持续摄取数据。
- *ListenHTTP*: 启动HTTP(或HTTPS)服务器并侦听传入连接。对于任何传入的POST请求，请求的内容将作为流文件写出，并返回200响应。
- *ListenUDP*: 侦听传入的UDP数据包并为每个数据包或每个数据包创建一个流文件(取决于配置)并将流文件发送到 `success` 关联。
- *GetHDFS*: 监视HDFS中用户指定的目录。每当新文件进入HDFS时，它都会被复制到Orchsym Studio并从HDFS中删除。此组件应将文件从一个位置移动到另一个位置，而不是用于复制数据。
如果在群集中运行，预计此组件也仅在主节点上运行。要从HDFS复制数据并使其保持原状，或者从群集中的多个节点流式传输数据，请参阅ListHDFS组件。
- *ListHDFS* / *FetchHDFS*: ListHDFS监视HDFS中用户指定的目录并发出一个流文件，其中包含遇到的每个文件的文件名。然后，它通过分布式缓存在整个Orchsym Studio集群中保持此状态。这些流文件然后可以在整个群集中散开并发送到FetchHDFS组件，后者负责获取这些文件的实际内容并发出包含从HDFS获取的内容的流文件。
- *FetchS3Object*: 从Amazon Web Services(AWS)简单存储服务(S3)获取对象的内容。出站流文件包含从S3接收的内容。
- *GetKafka*: 从Apache Kafka获取消息，特别是0.8.x版本。消息可以作为每个消息的流文件发出，也可以使用用户指定的分隔符进行批处理。
- *GetMongo*: 对MongoDB执行用户指定的查询，并将内容写入新的流文件。
- *GetTwitter*: 允许用户注册过滤器以收听Twitter “garden hose”或企业端点，为收到的每条推文创建一个流文件。

=== 数据出口/发送数据 
- *PutEmail*: 向配置的收件人发送电子邮件。流文件的内容可选择作为附件发送。
- *PUTFILE*: 将流文件的内容写入本地(或网络连接)文件系统上的目录。
- *PutFTP*: 将流文件的内容复制到远程FTP服务器。
- *PutSFTP*: 将流文件的内容复制到远程SFTP服务器。
- *PutJMS*: 将流文件的内容作为JMS消息发送到JMS代理，可选择根据属性添加JMS属性。
- *PutSQL*: 将流文件的内容作为SQL DDL语句(INSERT，UPDATE或DELETE)执行。流文件的内容必须是有效的SQL语句。属性可以用作参数，以便流文件的内容可以是参数化的SQL语句，以避免SQL注入攻击。
- *PutKafka*: 将流文件的内容作为消息发送到Apache Kafka，特别是0.8.x版本。流文件可以作为单个消息或分隔符发送，例如可以指定换行符，以便为单个流文件发送许多消息。
- *PutMongo*: 将流文件的内容作为INSERT或UPDATE发送到Mongo。

=== 拆分和整合 
- *SplitText*: SplitText接收单个流文件，其内容是文本的，并根据配置的行数将其拆分为1个或多个流文件。例如，可以将组件配置为将流文件拆分为多个流文件，每个流文件只有一行。
- *SplitJson*: 允许用户将包含数组或许多子对象的JSON对象拆分为每个JSON元素的流文件。
- *SplitXml*: 允许用户将XML消息拆分为多个流文件，每个流文件包含原始段。这通常在多个XML元素与"wrapper”元素连接在一起时使用。然后，此组件允许将这些元素拆分为单独的XML元素。
- *UnpackContent*: 解压缩不同类型的存档格式，例如ZIP和TAR。然后，归档中的每个文件都作为单个流文件传输。
- *MergeContent*: 此组件负责将许多流文件合并到一个流文件中。可以通过将其内容与可选的头，尾和分隔符连接在一起，或者通过指定存档格式(如ZIP或TAR)来合并流文件。流文件可以基于公共属性进行合并，或者如果它们已被其他拆分过程拆分，则可以进行类似“碎片整理”工作。用户可以指定每个bin的最小和最大容量。流文件会根据元素的数量或内容的总大小以及超时时间（可选），等待到装满或者有超时发生。
- *SegmentContent*: 根据某些已配置的数据大小将流文件划分为可能的许多较小的流文件。这里不对任何类型的分隔符执行拆分，而是仅基于字节偏移执行拆分。这是在传输流文件之前使用的，以便通过并行发送许多不同的部分来提供更低的延迟。另一方面，MergeContent组件可以使用碎片整理模式重新组装这些流文件。
- *SplitContent*: 将单个流文件拆分为可能的许多流文件，类似于SegmentContent。但是，使用SplitContent时，不会对根据字节边界值执行拆分，而是根据指定的字节序列拆分内容。

=== HTTP 
- *GetHTTP*: 下载远程HTTP的内容- 或基于HTTPS的URL进入Orchsym Studio.组件将记住ETag和Last-Modified日期，以确保不会持续摄取数据。
- *ListenHTTP*: 启动HTTP(或HTTPS)服务器并侦听传入连接。对于任何传入的POST请求，请求的内容将作为流文件写出，并返回200响应。
- *InvokeHTTP*: 执行用户配置的HTTP请求。此组件比GetHTTP和PostHTTP更通用，但需要更多配置。此组件不能用作源组件，并且需要具有传入的流文件才能被触发以执行其任务。
- *PostHTTP*: 执行HTTP POST请求，将流文件的内容作为消息正文发送。这通常与ListenHTTP结合使用，以便在无法使用站点到站点的情况下在两个不同的Orchsym Studio实例之间传输数据（例如，当节点无法直接访问并且能够通过HTTP进行通信时代理）。*注意*: 除了现有的RAW套接字传输之外，HTTP可用作link:user-guide.html#site-to-site[Site-to-Site]传输协议，它还支持HTTP代理。建议使用HTTP Site-to-Site，因为它更具可扩展性，并且可以使用输入/输出端口提供双向数据传输，并具有更好的用户身份验证和授权。
- *HandleHttpRequest* / *HandleHttpResponse*: HandleHttpRequest组件是一个源组件，与ListenHTTP类似，启动嵌入式HTTP(S)服务器。但是它不会向客户端发送响应。HTTP请求的Body和Servlet parameters, headers等内容和属性会作为流文件的属性一起输出。HandleHttpResponse能够在流文件完成处理后将响应发送回客户端。他们可以彼此结合使用，以允许用户在Orchsym Studio中可视化地创建Web服务。这对于非基于Web的协议添加一个前端或者围绕已经由Orchsym Studio执行的某些功能添加简单的Web服务特别有用，例如数据格式的转换。

=== AWS 
- *FetchS3Object*: 获取存储在Amazon Simple Storage Service中的对象的内容(S3)。然后，将从S3检索的内容将写入流文件的内容。
- *PutS3Object*: 使用配置的凭据，密钥和bucket名称将流文件的内容写入Amazon S3对象。
- *PutSNS*: 将流文件的内容作为通知发送到Amazon Simple Notification Service(SNS)。
- *GetSQS*: 从Amazon Simple Queuing Service(SQS)中提取消息，并将消息内容写入流文件的内容。
- *PutSQS*: 将流文件的内容作为消息发送到Amazon Simple Queuing Service(SQS)。
- *DeleteSQS*: 从Amazon Simple Queuing Service(SQS)中删除消息。这可以与GetSQS一起使用，以便从SQS接收消息，对其执行一些处理，然后只有在成功完成处理后才从队列中删除该对象。


== 使用属性 
每个流文件都使用多个属性创建，这些属性将在流文件的生命周期内发生变化。流文件的概念非常强大，并提供三个主要优点。首先，它允许用户在流中做出路由决策，以便满足某些条件的流文件可以与其他流文件做不同地处理。这是使用RouteOnAttribute和类似的组件完成的。

其次，使用属性可以使组件的配置依赖于数据本身。例如，PutFile组件能够使用属性来知道每个流文件的存储位置，而每个流文件的目录和文件名属性可能不同。

最后，属性提供了有关数据的极有价值的上下文。在查看流文件的溯源数据时，这非常有用。这允许用户搜索符合特定条件的溯源数据，并且还允许用户在检查原产地事件的详细信息时查看此上下文。通过这样做，用户就能够获得关于数据处理方式的有价值的见解，只需通过浏览与内容一起的这种上下文即可。 

=== 通用属性 

每个流文件都有一组最基本的属性: 

- *filename*: 可用于将数据存储到本地或远程文件系统的文件名。
- *path*: 可用于将数据存储到本地或远程文件系统的目录的名称。 
- *UUID*: 一个通用唯一标识符，用于区分流文件与系统中的其他流文件。
- *entryDate*: 流文件进入系统的日期和时间（比如被创建）。此属性的值是一个数字，表示自1970年1月1日0点(UTC)以来的毫秒数。 
- *lineageStartDate*: 任何时候克隆，合并或拆分流文件，都会导致创建“子”流文件。随着这些子流文件被克隆，合并或分裂，形成了一系列祖先流文件。此值表示最早的祖先进入系统的日期和时间。另一种思考方式是，此属性表示流文件通过系统的延迟。该值是一个数字，表示1970年1月1日0点(UTC)以来的毫秒数。
- *文件大小*: 此属性表示流文件内容占用的字节数。

请注意 `uuid`， `entryDate`， `lineageStartDate`，和 `fileSize` 属性是系统生成的，无法更改。

=== 提取属性 

Orchsym Studio提供了几种不同的组件，用于从流文件中提取属性。可以在上面的<<AttributeExtraction>>部分中找到用于此目的的常用组件列表。这是构建自定义组件的一个非常常见的用例。编写许多组件是为了理解特定的数据格式并从流文件的内容中提取相关信息，创建属性来保存该信息，以便可以决定如何路由或处理数据。

=== 添加用户定义的属性 

除了具有能够将特定信息片段从流文件内容提取到属性中的组件之外，用户还希望将自定义的属性添加到每个流文件中的特定位置。UpdateAttribute组件专为此目的而设计。
通过单击“属性”选项卡右上角的“+”按钮，用户可以在“配置”对话框中向组件添加新属性。系统会提示用户输入属性的名称和值。对于此UpdateAttribute组件处理的每个流文件，系统将自动为其添加上用户自定义的属性。

该属性的值也可以包含表达式语言。这允许基于其他属性修改或添加属性。例如，如果我们想要将正在处理文件的主机名和日期添加到文件名，我们可以通过添加名称的属性来实现 `filename` 和价值 `${hostname()}-${now():format('yyyy-dd-MM')}-${filename}`。虽然这一开始可能会让人感到困惑，但下面有关<<ExpressionLanguage>>的部分将有助于你理解这些表达式。

除了始终添加一组已定义的属性外，UpdateAttribute组件还具有一个高级UI，允许用户配置一组规则，以便在应用时添加属性。要访问此功能，请在“配置”对话框的“属性”选项卡中单击 `高级` 对话框底部的按钮。这将提供专门为此组件定制的UI，而不是为所有组件提供的简单属性表。在此UI中，用户可以配置规则引擎，实质上是指定必须匹配的规则，以便将已配置的属性添加到流文件。

=== 属性路由 

Orchsym Studio最强大的功能之一是能够根据属性路由流文件。执行此操作的主要机制是RouteOnAttribute组件。此组件与UpdateAttribute一样，通过添加用户定义的属性进行配置。通过单击组件配置对话框中“属性”选项卡右上角的“+”按钮，可以添加任意数量的属性。

每个流文件的属性将与配置的属性进行比较，以确定流文件是否满足指定的条件。每个属性的值应该是一个表达式语言表达式并返回一个布尔值。有关表达式语言的更多信息，请参阅下面的<<ExpressionLanguage>>部分。

在评估针对流文件的属性提供的表达式语言表达式之后，组件根据选择的路由策略确定如何路由流文件。最常见的策略是“Route to Property name”策略。选择此策略后，组件将为配置的每个属性公开关联。如果流文件的属性满足给定的表达式，则流文件的副本将路由到相应的关联。例如，如果我们有一个名为“begin-with-r” 的新属性和值“${filename:startsWith(\'r')}”，那么任何文件名以字母“r”开头的流文件将被路由到该关联，所有其他流文件将被路由到“unmatched”。 


[[ExpressionLanguage]] 
=== 表达式语言/使用属性 

当我们从流文件内容中提取属性或者添加添加用户自定定义属性时，除非我们有一些我们可以使用它们的机制，否则它们不会操作。Orchsym Studio表达式语言允许我们在配置流时访问和操作流文件属性值。并非所有组件属性都允许使用表达式语言，但很多都可以为了确定属性是否支持表达式语言，用户可以将鼠标悬停在"组件配置”对话框的"属性”选项卡里的"帮助”图标上（ image:iconInfo.png["Help"]）。这将提供一个工具提示，显示属性的描述，默认值(如果有)以及属性是否支持表达式语言。

对于支持表达式语言的属性，可以通过在开始标签 `${` 和结束标签 `}` 里面添加表达式来使用。表达式可以像属性名一样简单。例如，参考 `uuid`属性，我们可以简单地使用该值 `${uuid}`。如果属性名称不是以单个单词开头，或者包含除数字，字母，句点 (.)或下划线(_)，属性名称需要加上单引号。例如，`${My Attribute Name}` 会无效，但是 `${'My Attribute Name'}` 将引用属性 `My Attribute Name`。

除了引用属性值之外，我们还可以对这些属性执行许多功能和比较。例如，如果我们要检查是否 `filename` 属性包含字母“r” (不区分大小写)，我们可以使用 `${filename:toLower():contains('r')}` 表达式来做到这一点 。 请注意，函数由冒号分隔。我们可以将任意数量的函数放在一起，以构建更复杂的表达式。在这里需要注意重要的一点是虽然我们调用了 `filename:toLower()`，但这不会改变 `filename` 的属性，它只是为我们提供了一个新的值去使用。

我们也可以在另一个表达式中嵌入一个表达式。例如，如果我们想比较它的值 `attr1` 属性值的 `attr2` 属性，我们可以使用以下表达式执行此操作: `${attr1:equals( ${attr2} )}`。

表达式语言包含许多不同的函数，可用于执行路由和操作属性所需的任务。存在用于解析和操作字符串，比较字符串和数值，操纵和替换值以及比较值的函数。对可用的不同功能的完整解释超出了本文档的范围，但是link:expression-language-guide.html[Expression Language Guide] 为每个功能提供了更多的细节。

此外，此表达式语言指南内置于应用程序中，以便用户可以轻松查看哪些功能可用，并在键入时查看其文档。设置支持表达式语言的属性的值时，如果光标位于表达式语言的开始和结束标记内，请按Ctrl键 + 空格将提供所有可用功能的弹出窗口，并提供自动完成功能。单击或使用键盘导航到弹出窗口中列出的某行，将显示提示信息，描述该功能的作用，它所期望的参数以及函数的返回类型。



== 表达式语言中的自定义属性 

除了使用流文件属性外，还可以为表达式语言的使用定义自定义属性。添加自定义属性为处理和配置数据流提供了额外的灵活性。例如，您可以自定义连接，服务器和服务属性。创建自定义属性后，您可以在在‘orchsym.properties’文件中的 `orchsym.variable.registry.properties` 域中指定。更新‘orchsym.properties’文件后并重新启动Orchsym Studio，您可以根据需要使用自定义属性。


== 使用模板 

当我们使用组件在Orchsym Studio中构建越来越复杂的数据流时，我们经常会发现我们将相同的组件序列串在一起以执行某些任务。这可能变得乏味且低效。为解决这个问题Orchsym Studio提供了模板概念。模板可以被认为是可重用的子流。要创建模板，请按照下列步骤操作: 

- 选择要包含在模板中的组件。我们可以通过单击第一个组件，然后按住Shift键同时选择其他组件(以包括这些组件之间的连接)，或者通过按住Shift键同时拖动画布上所需组件周围的框。
- 在操作面板中选择“创建模板”图标（image:iconNewTemplate.png[New Template Icon]）。
- 提供模板的名称和可选的描述。 
- 点击 `创建` 按键。 

一旦我们创建了一个模板，我们就可以将它用作流程中的构建块，就像组件一样。为此，我们将单击并拖动模板图标（image:iconTemplate.png[Template]）从组件工具栏到我们的画布上。然后，我们可以选择要添加到画布的模板，然后 单击 `添加` 按钮。

最后，我们可以使用“Ochsym模板”对话框来管理模板。要访问此对话框，请从全局菜单中选择模板。在这里我们可以看到存在哪些模板并过滤模板以找到感兴趣的模板。在表单的右侧是一个图标，用于将模板导出或下载为XML文件。然后可以将其提供给其他人，以便他们可以使用您的模板。

要将模板导入Orchsym Studio实例，请从操作面板中选择“上载模板”图标（image:iconUploadTemplate.png[Upload Template]），单击"搜索”图标并导航到计算机上的文件。然后单击 `上传模板` 按键。模板现在将显示在您的表格中，您可以将其拖动到画布上。就像您创建的任何其他模板一样。

使用模板时需要记住一些重要的注意事项: 

- 任何标识为敏感属性的属性(例如在组件中配置的密码)都不会保存到模板中。每次将模板添加到画布时，都必须重新填充这些敏感属性值。
- 如果模板中包含的组件引用Controller Service，则Controller Service也将添加到模板中。这意味着每次将模板添加到图表时，它都会创建一个Controller Service的副本。


== 监控Orchsym Studio 

当数据流经Orchsym Studio中的数据流时，了解系统的运行情况非常重要，这有利于评估您是否需要更多资源以及评估当前资源的运行状况。Orchsym Studio提供了一系列监控系统的机制。

=== 状态栏

Orchsym Studio屏幕底部有一个状态栏。它包含一些关于Orchsym Studio当前健康状况的重要统计数据。活动线程数可以指示Orchsym Studio当前的工作情况，排队统计数据表示当前在整个流中排队的流文件数量，以及这些流文件的总大小。

如果Orchsym Studio实例位于群集中，我们还会在状态栏处看到一个指示器，告诉我们群集中有多少节点以及当前连接的节点数量。在这种情况下，活动线程数和队列大小表示当前连接的所有节点的总和。

=== 组件统计

画布上的每个组件，模块和远程模块都提供了有关组件处理了多少数据的若干统计信息。这些统计信息提供有关在过去五分钟内处理了多少数据的信息。这是一个滚动窗口，允许我们查看组件消耗的流文件数量，以及组件发出的流文件数量。

组件之间的连接还会显示当前排队的项目数。

查看这些指标的历史值也很有用，如果是集群，不同节点如何相互比较也可能很有价值。为了查看此信息，我们可以右键单击组件并选择 `历史状态` 菜单项。系统会弹出一个状态图，该图表涵盖自Orchsym Studio启动以来的时间，最多24小时的历史状态。用户可以更改properties属性文件中的配置，增加或减少此处显示的时间量。 

在此对话框的右上角有一个下拉列表，允许用户选择要查看的指标。底部的图表允许用户选择图表的较小部分进行放大. 


=== 公告 

除了每个组件提供的统计信息之外，用户还想知道是否出现任何问题。虽然我们可以监视日志中的任何内容，但在屏幕上弹出通知会更方便。如果一个组件将某些内容记录为警告或错误，我们将在组件的右上角看到“公告指示器”。此指示器看起来像一个便笺，将在事件发生后显示五分钟。将鼠标悬停在公告上会提供有关所发生情况的信息，以便用户无需筛选日志消息即可找到它。如果在群集中，公告还将指示群集中的哪个节点发布了公告。我们还可以在组件的“配置” 对话框的“设置”选项卡中更改公告的日志级别。 

如果系统框架发布一个公告，我们还会在屏幕右上方突出显示公告提示。在全局菜单中是“公告板”选项。单击此选项将我们带到公告板，在这里我们可以看到Orchsym Studio实例中出现的所有公告，并可以根据组件，消息等进行过滤。


== 数据溯源 

Orchsym Studio保存其提取的每个数据的非常精细的细节。当数据通过系统处理并被转换，路由，拆分，聚合和分发到其他端点时，这些信息都存储在Orchsym Studio的溯源仓库中。 为了搜索和查看此信息，我们可以从全局菜单中选择数据溯源。这将为我们提供一个表格，列出我们搜索过的溯源事件: 

image:provenance-table.png[Provenance Table] 

最初，此表填充了最近发生的1,000个Provenance事件(尽管事件发生后可能需要几秒钟才能处理信息)。在这个对话框中，有一个 `Search` 允许用户搜索特定组件发生的事件的按钮，按文件名或UUID搜索特定的流文件，或其他几个字段。`studio.properties` file提供了配置哪些属性被索引或可搜索的功能。此外，属性文件还允许您选择将要编制索引的特定流文件属性。因此，您可以选择哪些属性对您的特定数据流很重要，并使这些属性可搜索。

[[EventDetails]] 
=== 事件详细信息 
一旦我们执行了搜索，我们的表格将仅列出与搜索条件匹配的事件。在这里，我们可以选择信息图标（image:iconDetails.png[Details Icon]）在表格的左侧查看该事件的详细信息: 

image:event-details.png[Event Details] 

从这里，我们可以确切地看到该事件发生的时间，事件影响的流文件，哪个元件（比如组件等））执行的事件， 
事件花了多长时间，以及事件发生时数据在Orchsym Studio中的总时间（总延迟）。 

下一个选项卡提供了事件发生时流文件上存在的所有属性的列表:

image:event-attributes.png[Event Attributes] 

从这里，我们可以看到事件发生时流文件上存在的所有属性，以及这些属性的先前值。这允许我们知道哪些属性因此事件而发生变化以及它们如何变化。此外，在右侧角是一个复选框，允许用户仅查看那些已更改的属性。如果流文件只有少量属性，这可能不是特别有用 ，但当流文件有数百个属性时可能非常有用。

这非常重要，因为它允许用户理解流文件处理的确切上下文。这对理解“为什么”流文件会被这么处理是非常有帮助的，特别是在使用表达式语言配置组件时。

最后，我们有内容选项卡:

image:event-content.png[Event Content] 

此选项卡向我们提供有关存储流文件内容的内容存储库位置的信息。如果事件修改了流文件的内容，我们将看到‘之前的内容’ （输入）和‘之后’ （输出）内容声明。
我们可以选择下载内容或者查看内容（如果数据格式是Orchsym Studio能理解的数据格式）。

此外，还有一个“重放” 允许用户将流文件重新插入到流中的按钮，并从事件发生的时间点重新处理它。这提供了一个非常强大的机制，因为我们能够实时修改流程，重新处理流文件，然后查看结果。如果它们不符合预期，我们可以再次修改流程，并再次重新处理流文件。我们能够执行流程的这种迭代开发，直到它完全按照预期处理数据。

=== 谱系图 

除了查看溯源事件的详细信息外，我们还可以通过单击谱系图标（image:iconLineage.png[Lineage]）查看所涉及的流文件的谱系视图。

这为我们提供了一个图形表示，说明了在遍历系统时该数据发生了什么: 

image:lineage-graph-annotated.png[Lineage Graph] 

从这里，我们可以右键单击所代表的任何事件，然后单击 `View Details` 菜单项看<<EventDetails>>。此图形表示向我们准确显示了数据发生的事件。有一些“特殊”事件类型需要注意：如果我们看到JOIN，FORK或CLONE事件，我们可以右键单击并选择“查找父亲”或“展开”。这允许我们查看父流文件和创建的子流文件的谱系。

左下角的滑块允许我们查看这些事件发生的时间。通过左右滑动，我们可以看到哪些事件将延迟引入系统，以便我们非常好地了解系统中可能需要提供更多资源的位置，例如组件的并发任务数量。或者它可能揭示一些问题，例如，发现大多数延迟是由JOIN事件引入的，说明系统在等待更多的流文件连接在一起等。在任何一种情况下，能够轻松查看其发生的位置是一项非常强大的功能，可帮助用户了解企业的​​运营方式。


