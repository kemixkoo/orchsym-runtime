// 
// Licensed to the Apache Software Foundation (ASF) under one or more 
// contributor license agreements.  See the NOTICE file distributed with 
// this work for additional information regarding copyright ownership. 
// The ASF licenses this file to You under the Apache License, Version 2.0 
// (the "License"); you may not use this file except in compliance with 
// the License.  You may obtain a copy of the License at 
// 
//     http://www.apache.org/licenses/LICENSE-2.0 
// 
// Unless required by applicable law or agreed to in writing, software 
// distributed under the License is distributed on an "AS IS" BASIS, 
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
// See the License for the specific language governing permissions and 
// limitations under the License. 
// 
= Orchsym Studio用户指南
Orchsym Studio团队<orchsym@baishancloud.com> 
:homepage: https://www.baishancloud.com/ 
:linkattrs: 

== 简介 
Orchsym Studio是基于流程编程概念（flow-based）的数据流系统。它支持强大且可扩展的指示图式的数据路由，转换和系统中介逻辑。Orchsym Studio具有基于Web的用户界面，用于设计，控制，反馈和监控数据流。它在服务质量的几个方面具有高度可配置性，例如容错与保证交付，低延迟与高吞吐量以及基于优先级的排队。Orchsym Studio为所有数据，包括接收，分叉，加入，克隆，修改，发送和丢弃（达到其配置的结束状态时），据提供细粒度的溯源功能。

见 link:administration-guide.html[System Administrator’s Guide] 有关系统要求，安装和配置的信息。安装Orchsym Studio后，使用支持的Web浏览器查看UI。 


== 浏览器支持 
[options="header"] 
|====================== 
|浏览器  |版本 
|Chrome   |当前版本和当前版本 - 1 
|FireFox  |当前版本和当前版本 - 1 
|Edge     |当前版本和当前版本 - 1 
|Safari   |当前版本和当前版本 - 1 
|====================== 

当前版本和当前版本 - 1表示UI支持该浏览器的当前稳定版本和前一个版本。例如，如果当前稳定版本是45.X，然后官方支持的版本将是45.X和44.X. 

对于Safari来说，它更频繁地发布主要版本，当前版本和当前版本 - 1只代表两个最新版本. 

支持的浏览器版本由UI使用的功能及其使用的依赖项来决定。UI功能的开发和测试都会基于当前支持的浏览器上。浏览器不兼容的任何问题都应报告给Orchsym Studio团队。 

=== 不支持的浏览器 

虽然UI可能在不受支持的浏览器中成功运行，但它没有针对它们进行主动测试。此外，UI被设计为桌面体验，目前在移动浏览器中不受支持。 

=== 在可变大小的浏览器中查看UI 
在大多数环境中，所有UI都在浏览器中可见。但是，UI具有响应式设计，允许您根据需要在较小尺寸的浏览器或平板电脑环境中滚动屏幕. 

在浏览器宽度小于800像素且高度小于600像素的环境中，UI的某些部分可能不可用。 

[template="glossary", id="terminology"] 
== 术语 
*DataFlow Manager*: DataFlow Manager(DFM)是一个Orchsym Studio用户，具有添加，删除和修改Orchsym Studio数据流组件的权限。 

*FlowFile*: FlowFile代表Orchsym Studio中的单个数据。FlowFile由两个元素组成: FlowFile属性和FlowFile内容。内容是FlowFile表示的数据。属性是提供有关数据的信息或上下文的特征; 它们由键值对组成。所有FlowFiles都具有以下标准属性: 

- *UUID*: FlowFile的唯一标识符 
- *filename*: 人类可读的文件名，可在将数据存储到磁盘或外部服务时使用 
- *path*: 分层结构的值，可以在将数据存储到磁盘或外部服务时使用，以便数据不存储在单个目录中 

*组件*: 组件是Orchsym Studio组件，用于侦听传入的数据; 从外部来源提取数据; 
将数据发布到外部来源; 并从FlowFiles中路由，转换或提取信息. 

*关系*: 每个组件都为其定义了零个或多个关系. 命名这些关系以指示处理FlowFile的结果. 
组件处理完FlowFile后，它会将FlowFile路由(或"传输”)到其中一个关系. 
然后，DFM可以将这些关系中的每一个连接到其他组件，以指定
每个潜在处理结果下FlowFile应该在 哪里下一步. 

*连接*: DFM通过将组件从Orchsym Studio工具栏的"组件”部分拖动到画布
，然后通过Connections将组件连接在一起来创建自动数据流 . 每个连接由一个或多个关系组成. 
对于绘制的每个Connection，DFM可以确定应该为Connection使用哪些关系. 
这允许数据基于其处理结果以不同方式路由. 每个连接都包含一个FlowFile队列. 
将FlowFile传输到特定关系时，会将其添加到属于关联Connection的队列中. 

*控制器服务*: Controller Services是扩展点，在用户界面中由DFM添加和配置后，将在Orchsym Studio启动时启动，并提供供其他组件(如组件或其他控制器服务)使用的信息. 多个组件使用的常见Controller服务是StandardSSLContextService. 它提供了一次配置密钥库和/或信任库属性的能力，并在整个应用程序中重用该配置. 我们的想法是，控制器服务不是在每个可能需要它的组件中配置这些信息，而是根据需要为任何组件提供它。. 

*报告任务*: 报告任务在后台运行，以提供有关Orchsym Studio实例中发生情况的统计报告. DFM根据需要在用户界面中添加和配置报告任务. 常见的报告任务包括ControllerStatusReportingTask，MonitorDiskUsage报告任务，MonitorMemory报告任务和StandardGangliaReporter. 

*漏斗*: 漏斗是一个Orchsym Studio组件，用于将来自多个Connections的数据组合到一个Connection中. 

*流程组*: 当数据流变得复杂时，在更高，更抽象的层面上推断数据流通常是有益的. 
Orchsym Studio允许将多个组件(如组件)组合到一个过程组中. 
然后，Orchsym Studio用户界面使DFM可以轻松地将多个流程组连接到逻辑数据流中， 
并允许DFM进入流程组以查看和操作流程组中的组件. 

*港口*: 使用一个或多个进程组构建的数据流需要一种方法将进程组连接到其他数据流组件. 
这是通过使用Ports实现的. DFM可以向进程组添加任意数量的输入端口和输出端口，并相应地命名这些端口. 

*远程进程组*: 正如数据传入和传出进程组一样，有时需要将数据从一个Orchsym Studio实例传输到另一个实例. 
虽然Orchsym Studio提供了许多不同的机制来将数据从一个系统传输到另一个系统，
但是如果将数据传输到另一个Orchsym Studio实例，远程进程组通常是最简单的方法 。. 

*公告*: Orchsym Studio用户界面提供了大量有关应用程序当前状态的监视和反馈. 
除了滚动统计信息和为每个组件提供的当​​前状态之外，组件还能够报告公告. 
每当组件报告公告时，该组件上都会显示公告图标. 系统级公告显示在页面顶部附近的状态栏上. 
使用鼠标悬停在该图标上将提供一个工具提示，显示公告的时间和严重性(调试，信息，警告，错误)以及公告 
的消息. 
也可以在全局菜单中的公告板页面中查看和过滤所有组件的公告. 

*模板*: 通常，数据流由许多可以重用的子流组成.Orchsym Studio允许DFM选择数据流的一部分 
(或整个数据流)并创建模板. 此模板具有名称，然后可以像其他组件一样拖动到画布上. 
结果，可以将若干组件组合在一起以形成更大的构建块，从该构建块创建数据流. 
这些模板也可以导出为XML并导入另一个Orchsym Studio实例，从而允许共享这些构建块. 

*流.XML.GZ*: DFM放入Orchsym Studio用户界面画布的所有内容都实时写入一个称为流的文件.XML.GZ. 默认情况下，此文件位于Orchsym Studio / conf目录中. 
在画布上进行的任何更改都会自动保存到此文件中，而无需用户单击"保存”按钮. 
此外，Orchsym Studio在更新时会自动在归档目录中创建此文件的备份副本. 
您可以使用这些归档文件来回滚流配置. 为此，请停止Orchsym Studio，更换流量.XML.使用所需的备份副本gz，然后重新启动Orchsym Studio. 
在群集环境中，停止整个Orchsym Studio群集，替换流量.XML.gz其中一个节点，然后重新启动节点. 移除流量.XML.来自其他节点的gz. 
确认节点启动为单节点群集后，启动其他节点. 替换的流配置将在群集中同步. 
流的名称和位置.XML.gz和自动存档行为是可配置的. 见 link:administration-guide.html＃核心性能-BR[System Administrator’s Guide] 了解更多详情. 



[[User_Interface]] 
== Orchsym Studio用户界面 

Orchsym Studio用户界面提供了创建自动数据流的机制，以及可视化， 
编辑，监控和管理这些数据流的机制.UI可以分为几个部分， 
每个部分负责应用程序的不同功能.本节提供
应用程序的屏幕截图， 并突出显示UI的不同部分.每个部分将
在本文档后面进一步详细讨论 . 

启动应用程序后，用户可以通过转到默认地址导航到UI 
`http://<hostname>:8080/Orchsym Studio` 在Web浏览器中.默认情况下没有配置权限，因此任何人都 
可以查看和修改数据流. 有关保护系统的信息，请参阅 link:administration-guide.html[System Administrator’s Guide]. 

当DFM首次导航到UI时，会提供一个空白画布，可在其上构建数据流: 

image::Orchsym Studio-toolbar-components.png["Orchsym Studio Components Toolbar"] 

组件工具栏跨越屏幕的左上角.它包含可以拖动到 
画布上以构建数据流的组件. 在<<building-dataflow>>中更详细地描述了每个组件. 

状态栏位于组件工具栏下.状态栏提供有关
流中当前活动的线程数， 流中当前存在的数据量，
每种状态下画布上存在的远程进程组数 (传输，未传输)，有多少的信息每个状态
(停止，运行，无效，禁用)画布上都存在组件 ，每个状态(最新，
本地修改，过时，本地修改和失效，同步失败)画布上存在多少个版本化的进程组 所有这些信息
最后刷新的时间戳 .此外，如果Orchsym Studio实例是群集的，则状态栏会显示
群集中有多少节点以及当前连接的节点数 . 

操作面板位于屏幕的左侧.它由
DFM用于管理流的按钮 以及管理用户访问
和配置系统属性的管理员组成 ，例如应向应用程序提供多少系统资源. 

在画布的右侧是搜索和全局菜单.您可以使用"搜索”在
画布上轻松查找组件， 并可以按组件名称，类型，标识符，配置属性及其值进行搜索.全局菜单 
包含允许您操作画布上现有组件的选项: 

image::global-menu.png[Orchsym Studio Global Menu] 

此外，UI还具有一些功能，可让您轻松浏览画布.您可以使用" 
导航选项板”在画布周围平移，以及放大和缩小.数据流的"鸟眼视图”提供了数据流的高级 
视图，并允许您平移大部分数据流.您还可以
在屏幕底部找到面包屑 .当您导航进出流程组时，面包屑会显示流程中 
的深度，以及您为达到此深度而输入的每个流程组.
面包屑中列出的每个进程组 都是一个链接，可以将您带回到流中的该级别. 

image::Orchsym Studio-navigation.png["Orchsym Studio Navigation"] 

[[UI-with-multi-tenant-authorization]] 
== 使用多租户授权访问UI多 
租户授权允许多组用户(租户)命令，控制和观察数据流的不同部分， 
具有不同级别的授权.当经过身份验证的用户尝试查看或修改Orchsym Studio资源时，系统会检查
用户是否 具有执行该操作的权限.这些权限由可以应用于系统范围或单个
组件的策略定义 .从数据流管理器的角度来看，这意味着一旦您有权访问Orchsym Studio画布，
您可以看到并可以使用一系列功能 ，具体取决于分配给您的权限. 

可用的全局访问策略是: 
[options="header"] 
|====================== 
|Policy  |特权 
|view the UI   |允许用户查看UI 
|access the controller  |允许用户查看和修改控制器，包括报告任务，控制器服务和群集中的节点 
|query provenance     |允许用户提交出处搜索并请求甚至沿袭 
|access restricted components     |假设其他权限足够，允许用户创建/修改受限制的组件.受限 
组件可以指示需要哪些特定权限.可以为特定限制授予权限，也可以在不受限制的情况下授予 
权限. 如果授予权限而不受限制，则用户可以创建/修改所有受限制的组件. 
|access all policies   |允许用户查看和修改所有组件的策略 
|access users/groups   |允许用户查看和修改用户和用户组 
|retrieve site-to-site details | 允许其他Orchsym Studio实例检索站点到站点的详细信息 
|view system diagnostics  |允许用户查看系统诊断 
|proxy user requests  |允许代理计算机代表其他人发送请求 
|access counters  |允许用户查看和修改计数器 
|====================== 

可用的组件级访问策略包括: 

[options="header"] 
|====================== 
|Policy  |特权 
|view the component   |允许用户查看组件配置详细信息 
|modify the component  |允许用户修改组件配置详细信息 
|view the data     |允许用户通过出站连接中的出处数据和流文件队列查看此组件的元数据和内容 
|modify the data   |允许用户在出站连接中清空流文件队列并提交重播 
|view the policies |允许用户查看可以查看和修改组件的用户列表 
|modify the policies  |允许用户修改可以查看和修改组件的用户列表 
|retrieve data via site-to-site  |允许端口从Orchsym Studio实例接收数据 
|send data via site-to-site  |允许端口从Orchsym Studio实例发送数据 
|====================== 

如果您无法查看或修改Orchsym Studio资源，请与系统管理员联系，或者参阅中的配置用户和访问策略 
link:administration-guide.html[System Administrator’s Guide] 了解更多信息. 

[[logging-in]] 
== 登录 

如果Orchsym Studio配置为安全运行，用户将能够请求访问DataFlow.有关配置Orchsym Studio 
安全运行的信息 ，请参阅link:administration-guide.html[System Administrator’s Guide].如果Orchsym Studio支持匿名访问，则会为用户提供相应的访问权限 
，并提供登录选项. 

单击"登录”' 链接将打开登录页面.如果用户使用他们的用户名/密码登录，他们将会看到 
一个表单.如果Orchsym Studio未配置为支持匿名访问且用户使用其用户名/密码登录，则会
立即将 其发送到登录表单，绕过画布. 

image::login.png["Log In"] 


[[building-dataflow]] 
== 构建DataFlow 

DFM能够使用Orchsym Studio UI构建自动数据流.只需将组件从工具栏拖到画布， 
配置组件以满足特定需求，并将
组件连接 在一起. 


=== 向画布添加组件 

上面的"用户界面”部分概述了UI的不同部分，并指出了"组件工具栏”. 
本节将查看该工具栏中的每个组件: 

image::components.png["Components"] 

[[processor]] 
image:iconProcessor.png["Processor", width=32] 
*组件*:组件是最常用的组件，因为它负责数据入口，出口，路由和 
操作. 有许多不同类型的组件.实际上，这是Orchsym Studio中非常常见的扩展点， 
这意味着许多供应商可以实现自己的组件来执行其用例所需的任何功能。. 
将组件拖动到画布上时，会向用户显示一个对话框，以选择要使用的组件类型: 

image::add-processor.png["Add Processor Dialog"] 

在右上角，用户可以根据组件类型或与组件关联的标签过滤列表. 
组件开发人员可以将标签添加到其组件中.这些标签在此对话框中用于过滤，并 
显示在标签云的左侧.使用特定标记存在的组件越多，标记
在标记云中显示的越大 . 单击云中的标记会将可用的组件过滤为仅包含该标记的组件.如果
选择了多个 标记，则仅显示包含所有这些标记的组件.例如，如果我们只想显示那些 
允许我们摄取文件的组件，我们可以选择两者 `files` 标签和 `ingest` 标签: 

image::add-processor-with-tag-cloud.png["Add Processor with Tag Cloud"] 

受限制的组件将标有a 
image:restricted.png["Restricted"] 
他们名字旁边的图标.这些组件 
可用于执行操作员通过Orchsym Studio REST API / UI提供的任意未经过验证的代码，或者可用于
使用Orchsym Studio OS凭据获取 或更改Orchsym Studio主机系统上的数据.这些组件可由其他授权的Orchsym Studio 
用户使用，超出应用程序的预期用途，升级权限，或者可能暴露有关Orchsym Studio进程
或主机系统内部的数据 .所有这些功能都应被视为特权，管理员应了解这些功能，并 
为可信用户的子集明确启用它们. 在允许用户创建和修改受限制的组件之前，必须授予他们访问权限. 徘徊在 image:restricted.png["Restricted"] 
图标将显示受限制组件所需的特定权限.
无论限制如何，都可以分配权限 . 在这种情况下，用户可以访问所有受限制的组件.或者，可以
为用户 分配对特定限制的访问权限.如果用户已被授予访问组件所需的所有限制的
权限，则他们将具有对该组件的访问权限，否则将 获得足够的权限.有关更多信息，请参阅 
<<UI-with-multi-tenant-authorization>>和<<Restricted_Components_在_Versioned_流程>>. 

单击 `Add` 按钮或双击组件类型将选定的组件添加到画布中
删除它的 位置. 

NOTE: 对于添加到画布的任何组件，可以使用鼠标选择它并将其移动到画布上的任何位置. 
此外，可以通过按住Shift键并选择每个项目或按住
Shift键并在所需组件周围拖动选择框，一次选择多个项目 . 

将组件拖到画布上后，可以通过右键单击组件并
从上下文菜单中选择一个选项来与其进行交互。 . 根据分配给您的权限，上下文菜单中可用的选项会有所不同. 

image::Orchsym Studio-processor-menu.png["Processor Menu"] 

虽然上下文菜单中的选项有所不同，但是当您具有使用组件的完全权限时，通常可以使用以下选项: 

- *配置*:此选项允许用户建立或更改组件的配置(请参阅<<配置_a_组件>>). 

NOTE: 对于组件，端口，远程进程组，连接和标签，可以通过双击所需组件来打开配置对话框. 

- *开始* 要么 *停止*:此选项允许用户启动或停止组件; 该选项可以是Start或Stop，具体取决于组件的当前状态. 
- *启用* 要么 *禁用*:此选项允许用户启用或启用组件; 该选项将为"启用”或"禁用”，具体取决于组件的当前状态. 
- *查看数据来源*:此选项显示Orchsym Studio Data Provenance表，其中包含有关通过该组件路由的FlowFiles的数据源事件的信息(请参阅<<data_provenance>>). 
- *查看状态历史记录*:此选项打开组件统计信息随时间的图形表示. 
- *查看用法*:此选项将用户带到组件的使用文档. 
- *查看连接 - >上游*:此选项允许用户查看并"跳转”到进入组件的上游连接. 当组件连接进出其他进程组时，这尤其有用. 
- *查看连接 - >下游*:此选项允许用户查看并"跳转”到组件外的下游连接. 当组件连接进出其他进程组时，这尤其有用. 
- *中心在视野中*:此选项将画布的视图置于给定的Processor上. 
- *换颜色*:此选项允许用户更改组件的颜色，这可以使大流量的可视化管理更容易. 
- *创建模板*:此选项允许用户从所选组件创建模板. 
- *复制*:此选项将所选组件的副本放在剪贴板上，以便可以通过右键单击画布并选择粘贴将其粘贴到画布上的其他位置. 复制/粘贴操作也可以使用按键Ctrl-C(Command-C)和Ctrl-V(Command-V)完成. 
- *删除*:此选项允许DFM从画布中删除组件. 



[[input_port]] 
image:iconInputPort.png["Input Port", width=32] 
*输入端口*:输入端口提供将数据传输到进程组的机制.将输入端口拖动 
到画布上时，将提示DFM命名端口. 进程组中的所有端口必须具有唯一的名称. 

所有组件仅存在于进程组中.当用户最初导航到Orchsym Studio页面时，用户被放置 
在根进程组中.如果将输入端口拖动到根进程组，则输入端口提供了一种机制 
，通过<<站点到站点，站点到站点>>从远程Orchsym Studio实例接收数据.在这种情况下，
如果Orchsym Studio配置为安全运行，则可以将输入端口配置 为限制对适当用户的访问.有关配置Orchsym Studio 
安全运行的信息 ，请参阅 
link:administration-guide.html[System Administrator’s Guide]. 



[[output_port]] 
image:iconOutputPort.png["Output Port", width=32] 
*输出端口*:输出端口提供了一种机制，用于将数据从进程组传输到进程组外部
的目标 . 将输出端口拖动到画布上时，将提示DFM命名端口.
进程组中的所有端口 必须具有唯一的名称. 

如果将输出端口拖动到根进程组，则输出端口提供了一种机制，用于
通过<<站点到站点，站点到站点>> 将数据发送到 远程Orchsym Studio实例. 在这种情况下，端口充当队列.当
Orchsym Studio的远程实例 从端口提取数据时，该数据将从传入的Connections的队列中删除.如果Orchsym Studio配置 
为安全运行，则可以将输出端口配置为限制对适当用户的访问.有关配置
Orchsym Studio安全运行的信息 ，请参阅 
link:administration-guide.html[System Administrator’s Guide]. 


[[process_group]] 
image:iconProcessGroup.png["Process Group", width=32] 
*流程组*:进程组可用于对一组组件进行逻辑分组，以便更容易理解
和维护数据流 . 将进程组拖动到画布上时，将提示DFM命名进程组.
同一父组中的所有进程 组必须具有唯一的名称. 然后，进程组将嵌套在该父组中. 

将进程组拖到画布上后，可以通过右键单击进程组并从
上下文菜单中选择一个选项来与其进行交互。 .根据分配给您的权限，上下文菜单中可用的选项会有所不同. 

image::Orchsym Studio-process-group-menu.png["Process Group Menu"] 

虽然上下文菜单中的选项有所不同，但是当您具有使用进程组的完全权限时，通常可以使用以下选项: 

- *配置*:此选项允许用户建立或更改进程组的配置. 
- *变量*:此选项允许用户在Orchsym Studio UI中创建或配置变量. 
- *输入群组*:此选项允许用户进入进程组. 

NOTE: 也可以双击进程组输入它. 

- *开始*:此选项允许用户启动进程组. 
- *停止*:此选项允许用户停止进程组. 
- *查看状态历史记录*:此选项打开过程组随时间变化的统计信息的图形表示. 
- *查看连接 - >上游*:此选项允许用户查看并"跳转”到进程组中的上游连接. 
- *查看连接 - >下游*:此选项允许用户查看并"跳转”到进程组外的下游连接. 
- *中心在视野中*:此选项将画布视图置于给定Process Group的中心. 
- *组*:此选项允许用户创建一个新的Process Group，其中包含选定的Process Group和画布上选择的任何其他组件. 
- *创建模板*:此选项允许用户从选定的进程组创建模板. 
- *复制*:此选项将所选进程组的副本放在剪贴板上，以便可以通过右键单击画布并选择粘贴将其粘贴到画布上的其他位置. 复制/粘贴操作也可以使用按键Ctrl-C(Command-C)和Ctrl-V(Command-V)完成. 
- *删除*:此选项允许DFM删除进程组. 



[[remote_process_group]] 
image:iconRemoteProcessGroup.png["Remote Process Group", width=32] 
*远程进程组*:远程进程组的显示和行为类似于进程组.但是，远程进程组(RPG) 
引用了Orchsym Studio的远程实例.将RPG拖动到画布上时，不会提示输入名称，而是提示DFM 
输入远程Orchsym Studio实例的URL.如果远程Orchsym Studio是群集实例，则应使用 
的URL是该群集中任何Orchsym Studio实例的URL.当数据
通过RPG 传输到Orchsym Studio的群集实例时 ，RPG将首先连接到远程实例，其URL配置为确定群集中的哪些节点以及 
每个节点的繁忙程度. 然后，此信息用于对推送到每个节点的数据进行负载平衡.
然后定期询问远程实例， 以确定有关从群集中删除或添加到群集的任何节点的信息，并 
根据每个节点的负载重新计算负载平衡. 有关详细信息，请参阅"站点到站点，站点到站点”部分. 

将远程进程组拖到画布上后，可以通过右键单击远程进程组并从
上下文菜单中选择一个选项来与其进行交互。 . 根据分配给您的权限，上下文菜单中可用的选项会有所不同. 

image::Orchsym Studio-rpg-menu.png["Remote Process Group Menu"] 

虽然上下文菜单中的选项有所不同，但是当您具有使用远程进程组的完全权限时，通常可以使用以下选项: 

- *配置*:此选项允许用户建立或更改远程进程组的配置. 
- *启用传输*:激活Orchsym Studio实例之间的数据传输(请参阅<<远程_Group_传动>>). 
- *禁用传输*:禁用Orchsym Studio实例之间的数据传输. 
- *查看状态历史记录*:此选项打开远程过程组随时间变化的统计信息的图形表示. 
- *查看连接 - >上游*:此选项允许用户查看和"跳转到”进入远程进程组的上游连接. 
- *查看连接 - >下游*:此选项允许用户查看和"跳转”到远程进程组外的下游连接. 
- *刷新远程*:此选项刷新远程Orchsym Studio实例的状态视图. 
- *组*:此选项允许用户创建包含所选远程进程组和在画布上选择的任何其他组件的新进程组. 
- *管理远程端口*:此选项允许用户查看远程进程组连接到的远程Orchsym Studio实例上存在的输入端口和/或输出端口. 请注意，如果站点到站点配置是安全的，则只能看到已访问连接Orchsym Studio的端口. 
- *中心在视野中*:此选项将画布视图置于给定的远程进程组中. 
- *去*:此选项在浏览器的新选项卡中打开远程Orchsym Studio实例的视图. 请注意，如果站点到站点配置是安全的，则用户必须能够访问远程Orchsym Studio实例才能查看它. 
- *组*:此选项允许用户创建包含所选远程进程组的进程组. 
- *创建模板*:此选项允许用户从选定的远程进程组创建模板. 
- *复制*:此选项将所选进程组的副本放在剪贴板上，以便可以通过右键单击画布并选择粘贴将其粘贴到画布上的其他位置. 复制/粘贴操作也可以使用按键Ctrl-C(Command-C)和Ctrl-V(Command-V)完成. 
- *删除*:此选项允许DFM从画布中删除远程进程组. 



[[funnel]] 
image:iconFunnel.png["Funnel"] 
*漏斗*:漏斗用于将来自多个Connections的数据组合到单个Connection中. 这有两个好处. 
首先，如果使用相同的目标创建了许多连接，则如果这些连接
必须跨越大空间，则画布可能会变得混乱 .通过将这些连接汇集到一个连接中，可以
绘制该单个连接 以跨越该大空间. 其次，可以使用FlowFile优先级配置器配置Connections.来自
多个Connections的数据 可以汇集到一个Connection中，从而能够对该
一个Connection 上的所有数据进行优先级排序 ，而不是单独确定每个Connection上的数据的优先级。. 


[[template]] 
image:iconTemplate.png["Template"] 
*模板*:DFM可以从流的各个部分创建模板，也可以从其他
数据流导入模板 . 这些模板提供了更大的构建块，可以快速创建复杂的流程.将模板 
拖动到画布上时，DFM会提供一个对话框，用于选择要添加到画布的模板: 

image::instantiate-template.png["Instantiate Template Dialog"] 

单击下拉框可显示所有可用模板.使用说明创建的任何模板都会显示一个问号 
图标，表示有更多信息. 使用鼠标将鼠标悬停在图标上将显示以下说明: 

image::instantiate-template-description.png["Instantiate Template Dialog"] 



[[label]] 
image:iconLabel.png["Label"] 
*标签*:标签用于为数据流的各个部分提供文档.将Label放到画布上时， 
会使用默认大小创建它. 然后可以通过拖动右下角的手柄来调整Label的大小. 
标签在最初创建时没有文本.可以通过右键单击Label并
选择来添加Label的文本 `Configure` 


[[component-versioning]] 
=== 组件版本 
您可以访问有关组件，Controller Services和Reporting Tasks版本的信息. 
当您在具有运行
不同版本组件的多个Orchsym Studio实例的集群环境中工作时，或者如果您已升级到较新版本的组件时，此功能尤其有用 ."添加组件”，" 
添加控制器服务”和"添加报告任务”对话框包括标识组件版本的列，以及 
组件的名称，创建组件的组织或组以及包含
组件的NAR捆绑包 . 

image::add-processor-version-example.png["Add Processor Version Example"] 

画布上显示的每个组件也包含此信息. 

image::processor-version-information-example.png["Processor Version Information Example"] 

==== 排序和筛选组件 
添加组件时，可以根据原始源对版本号或筛选器进行排序. 

要基于版本进行排序，请单击版本列以按升序或降序版本顺序显示. 

要根据源组进行筛选，请单击"添加组件”对话框左上角的"源”下拉列表， 
然后选择要查看的组. 

image::add-processor-version-sort-filter.png["Add Processor Version Sort and Filter"] 

==== 更改组件版本 
要更改组件版本，请执行以下步骤. 

1. 右键单击画布上的组件以显示配置选项. 
2. 选择更改版本. 
+ 
image::processor-change-version.png["Processor Change Version"] 
3. 在"组件版本”对话框中，从"版本”下拉菜单中选择要运行的版本. 
+ 
image::component-version-dialog.png["Component Version"] 

==== 了解版本依赖关系 
在配置组件时，还可以查看有关版本依赖关系的信息. 

. 右键单击组件，然后选择"配置”以显示组件的"配置”对话框. 
. 单击"属性”选项卡. 
. 单击信息图标以查看任何版本依赖关系信息. 

image::configure-processor-with-version-information.png["Configuration Version Requirements"] 

在以下示例中，MyProcessor版本1.使用控制器服务StandardMyService版本1正确配置0.0: 

image::processor-cs-version-match.png["Processor and Controller Service Version Match"] 

如果MyProcessor的版本更改为不兼容的版本(MyProcessor 2.0)，验证错误将显示在组件上: 

image::processor-cs-version-mismatch-warnings.png["Processor and Controller Service Version Mismatch Warnings"] 

并且由于服务不再有效，因此组件的控制器服务配置中将显示错误消息: 

image::processor-cs-version-mismatch-config.png["Processor and Controller Service Version Mismatch Property"] 



[[Configuring_a_Processor]] 
=== 配置组件 

要配置组件，请右键单击组件并选择 `Configure` 上下文菜单中的选项. 或者，只需双击组件即可.打开配置对话框
，其中包含四个 不同的选项卡，每个选项卡将在下面讨论.完成组件的配置后，可以
单击以应用 更改 `Apply` 单击按钮或取消所有更改 `Cancel` 按键. 

请注意，组件启动后，为组件显示的上下文菜单不再具有 `Configure` 
选项，但有一个 `View Configuration` 选项.所述组件同时组件配置不能改变 
运行.必须首先停止组件并等待其所有活动任务完成，然后
再次配置 组件. 

请注意，不支持输入某些控制字符，并在输入时自动过滤掉.
任何配置中都不会保留以下字符和任何 未配对的Unicode代理点代码点: 

[#x0]， [#x1]， [#x2]， [#x3]， [#x4]， [#x5]， [#x6]， [#x7]， [#x8]， [#xB]， [#xC]， [#xE]， [#xF]， [#x10]， [#x11]， [#x12]， [#x13]， [#x14]， [#x15]， [#x16]， [#x17]， [#x18]， [#x19]， [#x1A]， [#x1B]， [#x1C]， [#x1D]， [#x1E]， [#x1F]， [#xFFFE]， [#xFFFF] 

==== 设置选项 

卡组件配置对话框中的第一个选项卡是设置选项卡: 

image::settings-tab.png["Settings Tab"] 

此选项卡包含几个不同的配置项. 首先，它允许DFM更改组件的名称. 
默认情况下，组件的名称与组件类型相同.组件名称旁边是一个复选框，指示 
组件是否已启用. 将组件添加到画布后，将启用它.如果 
组件已禁用，则无法启动.禁用状态用于指示当启动一组组件时， 
例如当DFM启动整个进程组时，应排除此(已禁用)组件. 

在Name配置下方，将显示Processor的唯一标识符以及Processor的类型和NAR包. 这些值无法修改. 

接下来是两个用于配置"惩罚持续时间”的对话框' 和'产量持续时间'.在处理
一段数据(FlowFile)的正常过程中 ，可能会发生一个事件，指示此时无法处理
数据，但 数据可能在以后处理. 发生这种情况时，组件可以选择Penalize FlowFile.这将 
阻止FlowFile在一段时间内被处理.例如，如果组件要将数据推 
送到远程服务，但远程服务已经有一个与组件
指定的文件名同名的文件 ，则组件可能会惩罚FlowFile. '处罚期限' 允许DFM指定
FlowFile应该受到多长时间的 惩罚. 默认值为30秒. 

类似地，组件可以确定存在某种情况，使得组件不再能够进行任何进展， 
而不管其正在处理的数据.例如，如果组件要将数据推送到远程服务并且该 
服务没有响应，则组件无法取得任何进展.结果，组件应该"产生”，这将 
阻止组件被安排运行一段时间.通过设置
'产量持续时间' 来指定 该时间段. 默认值为1秒. 

"设置”选项卡左侧的最后一个可配置选项是"公告”级别.每当组件写入 
其日志时，组件也将生成公告.此设置指示应
在用户界面中显示的最低级别的公告 .默认情况下，公告级别设置为WARN，这意味着它将显示所有警告和错误级别 
公告. 

"设置”选项卡的右侧包含"自动终止关系”' 部分.
此处列出了组件定义的每个关系 及其描述.为了使组件被视为有效且 
能够运行，组件定义的每个关系必须连接到下游组件或自动终止. 
如果关系是自动终止的，则将从流中删除任何路由到该关系的FlowFile，并将 
其处理视为完成. 已连接到下游组件的任何关系都无法自动终止. 
必须首先从使用它的任何Connection中删除关系.此外，对于选择
自动终止的任何关系， 如果将关系添加到连接，将清除(关闭)自动终止状态. 




==== "计划”选项 

卡"组件配置”对话框中的第二个选项卡是"计划”选项卡: 

image::scheduling-tab.png["Scheduling Tab"] 

第一个配置选项是调度策略. 调度组件有三种可能的选项: 

*定时器驱动*:这是默认模式. 组件将安排定期运行.
运行组件的时间间隔 由"运行时间表”定义' 选项(见下文). 

*事件驱动*:选择此模式时，将触发组件以由事件运行，并且当FlowFiles进入连接
此组件的Connections时发生该事件 . 此模式目前被认为是实验性的，并非所有组件都支持.
选择此模式后 ，"运行计划”' 选项不可配置，因为组件未被触发定期运行，而是 
        作为事件的结果.此外，这是"并发任务” 
选项可以设置为0 的唯一模式 .在这种情况下，线程数仅受
管理员配置的事件驱动线程池的大小限制 . 

*CRON驱动*:当使用CRON驱动的调度模式时，组件被安排定期运行，类似于 
定时器驱动的调度模式.然而，CRON驱动模式以
增加配置的复杂性为代价提供了显着更大的灵活性 .CRON驱动的调度值是由六个必需字段和一个
可选字段组成的字符串 ，每个字段由空格分隔. 这些字段是: 

[cols="1,1", options="header"] 
|=== 
|字段 
|有效值 


|秒 
| 0-59 

|分钟 
| 0-59 

|小时 
| 0-23 

|日期 
| 1-31 

|月 
| 1-12或JAN-DEC 

|星期几 
| 1-7或SUN-SAT 

|年(可选) 
|空，1970-2099 
|=== 

您通常通过以下方式之一指定值: 

* *数*:指定一个或多个有效值. 您可以使用逗号分隔列表输入多个值. 
* *范围*:使用<number> - <number>语法指定范围. 
* *增量*:使用<start value> / <increment>语法指定增量. 例如，在"分钟”字段中，0/15表示分钟0,15,30和45. 

您还应该知道几个有效的特殊字符: 

* * -- 表示所有值对该字段都有效. 
* ？ -- 表示未指定任何特定值. 此特殊字符在"星期几”和"星期几”字段中有效. 
* 大号 -- 您可以将L附加到星期几值中的一个，以指定该月中该日的最后一次出现.对于 
例如，1L表示月份的最后一个星期日. 

例如: 

* 字符串 `0 0 13 * * ?` 表示您希望将组件安排在每天下午1:00运行. 
* 字符串 `0 20 14 ? * MON-FRI` 表示您希望将组件安排在每周一至周五下午2:20运行. 
* 字符串 `0 15 10 ? * 6L 2011-2017` 表示您希望将组件安排在2011年至2017年的每个月的最后一个星期五上午10:15运行. 

有关其他信息和示例，请参阅 link:http://www.quartz-scheduler.org/documentation/quartz-2.x/tutorials/crontrigger.html[Chron Trigger Tutorial^] 在Quartz文档中. 

接下来，Scheduling选项卡提供名为'Concurrent Tasks'的配置选项.这可以控制组件
将使用的线程数 . 换句话说，它控制此组件应同时处理多少个FlowFiles.增加 
此值通常会使组件在相同的时间内处理更多数据.但是，它通过使用
其他组件无法使用的系统 资源来实现此目的. 这基本上提供了组件的相对权重 -- 它控制 
应该将多少系统资源分配给此组件而不是其他组件.该字段适用于 
大多数组件. 但是，某些类型的组件只能使用单个"并发”任务进行调度. 

'运行计划' 规定组件应安排运行的频率.此字段的有效值取决于所选的 
调度策略(参见上文). 如果使用事件驱动的调度策略，则此字段不可用.使用定时器驱动的 
调度策略时，该值是由数字后跟时间单位指定的持续时间. 例如， `1 second` 要么 `5 mins`. 
默认值为 `0 sec` 表示组件应尽可能经常运行，只要它有要处理的数据.
对于0的任何持续时间都是如此 ，无论时间单位如何(i.Ë.， `0 sec`， `0 mins`， `0 days`).有关
适用于CRON驱动的调度策略的值的说明 ，请参阅CRON驱动的调度策略本身的说明. 

配置为群集时，将提供执行设置.此设置用于确定将
安排组件执行哪些节点 . 选择"所有节点”' 将导致在集群中的每个节点上调度此组件.选择 
"主节点”' 将导致此组件仅在主节点上进行调度.  已为"主节点”配置的组件' 执行由组件图标旁边的"P”标识: 

image::primary-node-processor.png["Primary Node Processor"] 

快速识别"主节点”' 组件，"P”图标也显示在"摘要”页面的"组件”选项卡中: 

image::primary-node-processors-summary.png["Primary Node Processors in Summary Page"] 

"调度”选项卡的右侧包含一个用于选择"运行持续时间”的滑块.这可以控制组件
每次触发时应安排 运行的时间. 在滑块的左侧，标记为"较低延迟' 而右侧 
标有"更高吞吐量”.组件完成运行后，必须更新存储库才能将FlowFiles传输到 
下一个Connection.更新存储库的成本很高，因此在更新存储库之前可以立即完成 
的工作量越多，组件可以处理的工作量就越多(吞吐量越高).但是，这意味着
在上一个Process更新此存储库之前，下一个Processor无法开始处理 这些FlowFiles.因此，延迟会更长(
从头到尾处理FlowFile 所需的时间 会更长).因此，滑块提供了一个频谱，DFM可以从中选择支持 
较低延迟或较高吞吐量. 


==== "属性”选项卡 

"属性”选项卡提供了一种配置特定于组件的行为. 没有默认属性.每种类型的组件 
必须定义哪些属性对其用例有意义. 下面，我们看到RouteOnAttribute Processor的Properties选项卡: 

image::properties-tab.png["Properties Tab"] 

默认情况下，此组件只有一个属性:"路由策略”. 默认值为"路由到属性名称”.
此属性的名称旁边 是一个小问号符号( 
image:iconInfo.png["Question Mark"] 
). 在整个用户界面的其他位置可以看到此帮助符号，它表示可以获得更多信息. 
使用鼠标将鼠标悬停在此符号上将提供有关属性和默认值的其他详细信息，以及 
为该属性设置的历史值. 

单击属性的值将允许DFM更改该值.根据属性允许的值， 
向用户提供一个下拉列表，从中选择一个值或给出一个文本区域来键入值: 

image::edit-property-dropdown.png["Edit Property with Dropdown"] 

选项卡的右上角是一个用于添加新属性的按钮.单击此按钮将为DFM提供一个对话框，用于 
输入新属性的名称和值. 并非所有组件都允许用户定义的属性.在不允许它们
的组件中， 组件在应用用户定义属性时变为无效. 但是，RouteOnAttribute允许用户定义的属性. 
实际上，在用户添加属性之前，此组件无效. 

image:edit-property-textarea.png["Edit Property with Text Area"] 

请注意，添加用户定义的属性后，该行的右侧将出现一个图标( 
image:iconDelete.png["Delete Icon"] 
). 单击它将从组件中删除用户定义的属性. 

某些组件还内置了高级用户界面(UI). 例如，UpdateAttribute组件具有高级UI. 要访问高级用户界面，请单击 `Advanced` 出现在"配置组件”窗口底部的按钮. 只有具有高级UI的组件才具有此按钮. 

某些组件具有引用其他组件的属性，例如Controller Services，这些组件也需要进行配置. 例如，GetHTTP组件具有SSLContextService属性，该属性引用StandardSSLContextService控制器服务. 当DFM想要配置此属性但尚未创建和配置控制器服务时，他们可以选择在现场创建服务，如下图所示. 有关配置Controller Services的更多信息，请参阅<<Controller_Services>>部分. 

image:create-service-ssl-context.png["Create Service"] 

==== 注释选项 

卡组件配置对话框中的最后一个选项卡是注释选项卡.此选项卡仅为用户提供一个区域，以包含 
适用于此组件的任何注释. 使用"注释”选项卡是可选的: 

image::comments-tab.png["Comments Tab"] 


=== 其他帮助 

您可以通过右键单击组件并选择"使用情况”来访问有关每个组件使用情况的其他文档' 从上下文菜单中. 或者，从UI右上角的"全局菜单”中选择"帮助”，以显示包含所有文档的"帮助”页面，包括可用的所有组件的使用文档. 单击所需的组件以查看使用文档. 

[[Using_Custom_Properties]] 
=== 将自定义属性与表达式语言一起 
使用您可以使用Orchsym Studio表达式语言来引用FlowFile属性，将它们与其他值进行比较，并在创建和配置数据流时操纵它们的值. 有关表达式语言的更多信息，请参阅 link:expression-language-guide.html[Expression Language Guide]. 

除了在Express 
Language中使用FlowFile属性，系统属性和环境属性之外 ，您还可以定义表达式语言使用的自定义属性.定义自定义属性 
可以更灵活地处理和处理数据流.您还可
以为连接，服务器和服务属性创建自定义 属性，以便更轻松地配置数据流. 

Orchsym Studio属性具有分辨率优先级，在创建自定义属性时应注意这些优先级:â€œ 

* 特定于组件的属性 
* FlowFile属性 - 
* FlowFile属性 - 
* 来自变量注册表:â€ 
** 用户定义的属性(自定义属性) 
** 系统属性 - 
**操作系统环境变量 

在创建自定义属性时，请确保每个自定义属性包含不同的属性值， 
以便现有环境属性，系统属性或FlowFile属性不会覆盖它. 

有两种方法可以使用和管理自定义属性: 

* 在Orchsym Studio UI中通过Variables窗口 
* 通过'Orchsym Studio引用自定义属性.属性 

[[Variables_Window]] 
==== 变量窗口 

变量可以在Orchsym Studio UI中创建和配置.  变量可以在支持表达式语言的任何字段中使用.  Orchsym Studio自动获取在UI中创建的新变量或修改变量. 

要访问"变量”窗口，请右键单击未选中任何内容的画布: 

image::variables-context_menu-rpg.png["Variables in Context Menu for RPG"] 

从上下文菜单中选择"变量”: 

image::variables_window_empty.png["Empty Variables Window"] 

选择进程组时，右键单击"上下文菜单”中也可以使用"变量”: 

image::variables-context_menu-pg.png["Variables in Context Menu for PG"] 

===== 创建变量 

在"变量”窗口中，单击"+”按钮以创建新变量.  添加名称: 

image::variable-name.png["Variable Name Creation"] 

和一个值: 

image::variable-value.png["Variable Value Creation"] 

选择"应用”: 

image::new_variable-apply.png["New Variable Applied"] 

执行更新变量的步骤(识别受影响的组件，停止受影响的组件等.).  例如，Referencing Processors部分现在列出了"PutFile-Root”组件.  在列表中选择组件的名称将导航到画布上的该组件.  看看组件的属性， `${putfile_dir}` 由Directory属性引用: 

image::variable-putfile-property.png["Processor Property Using Variable"] 

===== 变量范围 

变量的作用域由它们定义的过程组确定，并且可供该级别及以下定义的任何组件使用(i.Ë. 任何后代组件). 

后代组中的变量会覆盖父组中的值.  更具体地说，如果是变量 `x` 在根组中声明并在进程组内声明，进程组内的组件将使用值 `x` 在流程组中定义. 

例如，除了 `putfile_dir` variable that exists at the root process group, assume another `putfile_dir` 变量是在流程组A中创建的.  如果进程组A中的某个组件引用 `putfile_dir`, both variables will be listed, but the `putfile_dir` 从根组中将有一个删除线表明正在被覆盖: 

image::variable-overridden.png["Variable Overridden"] 

只能为其创建的进程组修改变量，该变量列在"变量”窗口的顶部.  要修改在不同进程组中定义的变量，请在该变量的行中选择"箭头”图标: 

image::variable_window-goto.png["Variable Go To"] 

这将导航到该进程组的Variables窗口: 

image::variable_window-rpg.png["Variables Window for RPG"] 

===== 变量权限 

变量权限仅基于相应进程组上配置的权限. 

例如，如果用户无权查看进程组，则无法查看该进程组的"变量”窗口: 

image::variable_insufficient-permissions.png["Insufficient Permissions to View Variables"] 

如果用户有权查看流程组但无权访问"修改流程组”，则可以查看变量但不能修改变量. 

有关如何管理组件权限的信息，请参阅<<administration-guide."系统管理员指南”中的adoc＃access-policies，访问策略>>部分. 

===== 引用控制器服务 

除了引用组件之外，"变量”窗口还显示"引用控制器服务”: 

image::variables-window_controller-services.png["Referencing Controller Services"] 

选择控制器服务的名称将导航到"配置”窗口中的该控制器服务: 

image::variable_nav-controller_services.png["Controller Service Using Variable"] 

===== 未经授权的引用组件 

当未向引用变量的组件提供查看或修改权限时，组件的UUID将显示在"变量”窗口中: 

image::variables-window_unauthorized.png["Unauthorized Referencing Components"] 

在上面的例子中，变量 `property1` 由"user1”无法查看的组件引用: 

image::variable-unauthorized-ref-processor-canvas.png["Unauthorized Referencing Processor"] 

==== 通过Orchsym Studio引用自定义属性.properties 
标识一组或多组键/值对，并将它们提供给系统管理员. 

添加新的自定义属性后，请确保 `Orchsym Studio.variable.registry.properties` 
在'Orchsym Studio.性能' 使用自定义属性位置更新文件. 

NOTE: 必须重新启动Orchsym Studio才能获取这些更新. 

有关更多信息，请参阅<<管理指南.adoc＃custom_properties，"系统管理员指南”中的"自定义属性”部分. 

[[Controller_Services]] 
=== Controller Services 

Controller Services是报告任务，组件和其他服务可用于配置或任务执行的共享服务. 

IMPORTANT: 控制器级别定义的控制器服务仅限于报告任务和其中定义的其他服务. 必须在将使用它们的根进程组或子进程组的配置中定义数据流中组件使用的控制器服务. 

NOTE: 如果您的Orchsym Studio实例受到保护，您查看和添加Controller Services的能力取决于分配给您的权限. 如果您无权访问一个或多个Controller Services，则无法在UI中查看或访问它. 可以在全局或特定于Controller Service的基础上分配访问权限(有关更多信息，请参阅<<UI-with-multi-tenant-authorization>>). 

[[Controller_Services_for_Reporting_Tasks]] 
==== 为报告任务添加控制器服务要为报告任务 

添加控制器服务，请从全局菜单中选择控制器设置. 

image:controller-settings-selection.png["Global Menu - Controller Settings"] 

这将显示"Orchsym Studio设置”窗口. 该窗口有四个选项卡:常规，报告任务控制器服务，报告任务和注册表客户端. "常规”选项卡提供实例的总体最大线程数的设置. 

image:settings-general-tab.png["Controller Settings General Tab"] 

"常规”选项卡右侧是"报告任务控制器服务”选项卡. 在此选项卡中，DFM可以单击右上角的"+”按钮以创建新的Controller Service. 

image:controller-services-tab.png["Controller Services Tab"] 

"添加控制器服务”窗口打开. 此窗口类似于"添加组件”窗口. 它提供了右侧可用的Controller Services列表和标签云，显示了左侧用于Controller Services的最常见类别标签. DFM可以单击标签云中的任何标签，以便将Controller Services列表缩小到适合所需类别的那些. DFM还可以使用窗口右上角的"过滤器”字段来搜索所需的控制器服务，或使用左上角的"源”下拉列表按创建它们的组筛选列表. 从列表中选择Controller Service后，DFM可以在下面看到该服务的描述. 选择所需的控制器服务并单击"添加”，或者只需双击要添加的服务名称即可. 

image:add-controller-service-window.png["Add Controller Service Window"] 

添加控制器服务后，可以通过单击
最右侧列中的"配置”按钮进行配置 . 此列中的其他按钮包括启用，删除和访问策略. 

image:controller-services-configure-buttons.png["Controller Services Buttons"] 

您可以通过单击左侧列中的"使用和警报”按钮来获取有关Controller Services的信息. 

image:controller-services-info-buttons.png["Controller Services Information Buttons"] 

当DFM单击"配置”按钮时，将打开"配置控制器服务”窗口. 它有三个选项卡:设置，属性和注释. 此窗口类似于"配置组件”窗口. "设置”选项卡为DFM提供了一个位置，以便为Controller Service提供唯一的名称(如果需要). 它还列出了服务的UUID，类型，捆绑和支持信息，并提供了引用该服务的其他组件(报告任务或其他控制器服务)的列表. 

image:configure-controller-service-settings.png["Configure Controller Service Settings"] 

"属性”选项卡列出了适用于特定控制器服务的各种属性. 与配置组件一样，DFM可以将鼠标悬停在问号图标上以查看有关每个属性的更多信息. 

image:configure-controller-service-properties.png["Configure Controller Service Properties"] 

"注释”选项卡只是一个开放文本字段，其中DFM可能包含有关服务的注释. 配置Controller Service后，单击"应用”按钮以应用配置并关闭窗口，或单击"取消”按钮取消更改并关闭窗口. 


[[Controller_Services_for_Dataflows]] 
==== 为数据流添加控制器服务要为数据流 

添加控制器服务，可以右键单击"进程组”并选择"配置”，或单击"操作”选项板中的"配置”。. 

image:process-group-configuration-options.png["Process Group Configuration Options"] 

当您在画布上未选择任何操作选项板上单击"配置”时，将为根进程组添加控制器服务. 然后，该控制器服务可用于数据流中的所有嵌套进程组.  在画布上选择"进程组”，然后从"操作选项板”或"进程组”上下文菜单中单击"配置”时，该服务将可用于该进程组及其下面定义的所有组件和控制器服务。. 

image:process-group-controller-services-scope.png["Process Group Controller Services Scope"] 

使用以下步骤添加Controller Service: 

1. 单击"配置”，可以从"操作选项板”或"进程组”上下文菜单中单击"配置”.  这将显示进程组"配置”窗口.  该窗口有两个选项卡:常规和控制器服务. "常规”选项卡用于与有关进程组的常规信息有关的设置. 例如，如果配置根进程组，DFM可以为整个数据流提供唯一的名称，以及描述流的注释(注意:此信息对于远程连接到此实例的任何其他Orchsym Studio实例可见(使用远程进程组，a.ķ.一个.，站点到站点)). 
+ 
image::process-group-configuration-window.png["Process Group Configuration Window"] 
2. 从"进程组配置”页面中，选择"控制器服务”选项卡. 
3. 单击"+”按钮以显示"添加控制器服务”对话框. 
4. 选择所需的Controller Service，然后单击"添加”. 
五. 单击"配置”图标执行任何必要的Controller Service配置任务(image:iconConfigure.png["Configure"])在右栏中. 


[[Enabling_Disabling_Controller_Services]] 
==== 启用/禁用控制器服务配置控制器服务 

后，必须启用它才能运行. 使用"启用”按钮执行此操作(image:iconEnable.png["Enable Button"])在"控制器服务”选项卡的最右侧列中. 为了修改现有/正在运行的控制器服务，DFM需要停止/禁用它(以及所有引用报告任务和控制器服务). 使用"禁用”按钮执行此操作(image:iconDisable.png["Disable Button"]). DFM可以在禁用相关控制器服务时停止/禁用它们，而不必搜寻该控制器服务引用的每个组件。. 启用控制器服务时，DFM可以选择启动/启用控制器服务和所有引用组件，或者仅启动/启用控制器服务本身. 

image:enable-controller-service-scope.png["Enable Controller Service Scope"] 

[[Reporting_Tasks]] 
=== 报告任务 

报告任务在后台运行，以提供有关Orchsym Studio实例中发生情况的统计报告. DFM添加和配置报告任务，类似于Controller Services的过程.  要添加报告任务，请从全局菜单中选择控制器设置. 

image:controller-settings-selection.png["Global Menu - Controller Settings"] 

这将显示"Orchsym Studio设置”窗口. 选择"报告任务”选项卡，然后单击右上角的"+”按钮以创建新的"报告任务”. 

image:reporting-tasks-tab.png["Reporting Tasks Tab"] 

将打开"添加报告任务”窗口. 此窗口类似于"添加组件”窗口. 它提供了右侧可用报告任务的列表和标签云，显示了用于报告任务的最常见类别标签，位于左侧. DFM可以单击标签云中的任何标签，以便将报告任务列表缩小到适合所需类别的那些. DFM还可以使用窗口右上角的"过滤器”字段来搜索所需的"报告任务”，或使用左上角的"源”下拉列表按创建它们的组筛选列表. 从列表中选择报告任务后，DFM可以在下面看到该任务的描述. 选择所需的报告任务，然后单击"添加”，或者只需双击要添加的服务名称即可. 

image:add-reporting-task-window.png["Add Reporting Task Window"] 

添加报告任务后，DFM可以通过单击最右侧列中的"编辑”按钮对其进行配置. 此列中的其他按钮包括启动，删除，状态和访问策略. 

image:reporting-tasks-edit-buttons.png["Reporting Tasks Edit Buttons"] 

您可以通过单击左侧列中的"查看详细信息”，"使用情况”和"警报”按钮来获取有关报告任务的信息. 

image:reporting-tasks-info-buttons.png["Reporting Tasks Information Buttons"] 

当DFM单击"编辑”按钮时，将打开"配置报告任务”窗口. 它有三个选项卡:设置，属性和注释. 此窗口类似于"配置组件”窗口. "设置”选项卡为DFM提供了一个位置，以便为报告任务提供唯一名称(如果需要). 它还列出了任务的UUID，Type和Bundle信息，并提供了任务的Scheduling Strategy和Run Schedule的设置(类似于组件中的相同设置). DFM可以将鼠标悬停在问号图标上以查看有关每个设置的更多信息. 

image:configure-reporting-task-settings.png["Configure Reporting Task Settings"] 

"属性”选项卡列出了可为任务配置的各种属性. DFM可以将鼠标悬停在问号图标上以查看有关每个属性的更多信息. 

image:configure-reporting-task-properties.png["Configure Reporting Task Properties"] 

"注释”选项卡只是一个开放文本字段，其中DFM可能包含有关任务的注释. 配置报告任务后，单击"应用”按钮以应用配置并关闭窗口，或单击"取消”按钮取消更改并关闭窗口. 

如果要运行"报告任务”，请单击"开始”按钮(image:iconStart.png["Start Button"]). 


[[Connecting_Components]] 
=== 连接组件 

将组件和其他组件添加到画布并进行配置后，下一步是将它们
相互连接 ，以便Orchsym Studio知道在处理完每个FlowFile后如何处理它们.这是通过
在每个组件之间创建连接来实现的 . 当用户将鼠标悬停在组件中心上方时，会出现一个新的"连接”图标( 
image:addConnect.png["Connection Bubble"] 
)出现: 

image:processor-connection-bubble.png["Processor with Connection Bubble"] 

用户将连接气泡从一个组件拖动到另一个组件，直到第二个组件突出显示.当用户 
释放鼠标时，"创建连接”' 出现对话框. 该对话框包含两个选项卡:'详细信息' 和'设置'.它们 
将在下面详细讨论. 请注意，可以绘制连接，以便它在同一组件上循环.
如果DFM希望组件在失败关系时尝试重新处理FlowFiles，这将 非常有用.要创建此类型的循环 
连接，只需将连接气泡拖离，然后再返回到同一组件，直到它突出显示.然后释放鼠标 
和相同的'创建连接' 出现对话框. 

==== 详细信息选项 

卡'创建连接的详细信息选项卡' dialog提供有关源和目标组件的信息，包括组件名称， 
组件类型和组件所在的进程组: 

image::create-connection.png["Create Connection"] 

此外，此选项卡还提供了选择此Connection中应包含哪些关系的功能.
必须至少选择一个 关系. 如果只有一个关系可用，则会自动选择它. 

NOTE: 如果使用相同的关系添加多个Connections，则将
自动"克隆” 路由到该关系的任何FlowFile ，并将副本发送到每个Connections. 

==== 设置 

"设置”选项卡提供配置连接名称，FlowFile到期，背压阈值和 
优先级的功能: 

image:connection-settings.png["Connection Settings"] 

连接名称是可选的.如果未指定，则为Connection显示的名称将是
Connection的活动关系的名称 . 

===== FlowFile Expiration 
FlowFile到期是一个概念，通过该概念，可以自动从流中自动删除无法及时处理的数据. 
例如，当预计数据量超过可以发送到远程站点的卷时，这很有用. 
在这种情况下，到期可以与优先级排序器一起使用，以确保
首先处理最高优先级的数据 ，然后可以删除在特定时间段(例如，一小时)内无法处理的任何内容. 到期时间基于数据进入Orchsym Studio实例的时间. 换句话说，如果给定连接上的文件到期时间设置为"1小时”，并且已经在Orchsym Studio实例中一小时的文件到达该连接，则它将过期.默认 
值为 `0 sec` 表示数据永不过期. 当文件过期时不是'0秒' 设置好后，连接标签上会出现一个小时钟图标，因此当查看画布上的流时，DFM可以一目了然地看到它. 

image:file_expiration_clock.png["File Expiration Indicator"] 

===== 背压
Orchsym Studio为背压 提供两种配置元件.这些阈值表示
在不再计划运行作为Connection源的组件之前，应允许在队列中存在多少数据 . 
这允许系统避免数据溢出. 提供的第一个选项是"背压对象阈值”." 
这是在应用背压之前可以在队列中的FlowFiles的数量.第二个配置选项 
是"背压数据大小阈值”."这指定了在
应用反压之前应排队的最大数据量(大小) . 通过输入数字后跟数据大小来配置此值(`B` 对于字节， `KB` 对于 
千字节， `MB` 对于兆字节， `GB` 对于千兆字节，或 `TB` 对于太字节). 

NOTE: 默认情况下，添加的每个新连接都将具有10,000个对象的默认背压对象阈值和1 GB的背压数据大小阈值. 
可以通过修改中的相应属性来更改这些默认值 `Orchsym Studio.properties` 文件. 

启用背压时，连接标签上会出现小进度条，因此在查看画布上的流时，DFM可以一目了然地看到它.  进度条根据队列百分比更改颜色:绿色(0-60％)，黄色(61-85％)和红色(86-100％). 

image:back_pressure_indicators.png["Back Pressure Indicator Bars"] 

将鼠标悬停在条形图上会显示确切的百分比. 

image:back_pressure_indicator_hover.png["Back Pressure Indicator Hover Text"] 

队列完全填满后，Connection将以红色突出显示. 

image:back_pressure_full.png["Back Pressure Queue Full"] 

===== 优先级 
选项卡的右侧提供了对队列中数据进行优先级排序的功能，以便
首先处理更高优先级的数据 . 优先级可以从顶部('可用的优先级排序器')​​拖到底部('选择的优先级排序器'). 
可以选择多个优先级排序器. 优先级排序器位于"所选优先级排序器”的顶部' 列表是最高 
优先级.如果两个FlowFiles根据此优先级排序器具有相同的值，则第二个优先级排序器将确定
首先处理哪个 FlowFile，依此类推.如果不再需要优先级排序器，则可以从"选定的
优先级排序器”中拖动它 ' 列出'可用的优先顺序' 名单. 

可以使用以下优先顺序: 

- *FirstInFirstOutPrioritizer*:给定两个FlowFiles，首先处理到达连接的FlowFiles. 
- *NewestFlowFileFirstPrioritizer*:给定两个FlowFiles，将首先处理数据流中最新的FlowFiles. 
- *OldestFlowFileFirstPrioritizer*:给定两个FlowFiles，将首先处理数据流中最旧的FlowFiles. '这是在没有选择优先级的情况下使用的默认方案'. 
- *PriorityAttributePrioritizer*:给定两个具有"优先级”属性的FlowFile，将首先处理具有最高优先级值的FlowFiles. 请注意，应该使用UpdateAttribute组件将"priority”属性添加到FlowFiles，然后才能到达具有此优先级设置的连接. "priority”属性的值可以是字母数字，其中"a”的优先级高于"z”，"1”的优先级高于"9”，例如. 

===== 更改配置和上下文菜单选项 
在两个组件之间建立连接后，可以更改连接的配置，并且可以将连接移动到新目标; 但是，必须先停止连接任一侧的组件，然后才能进行配置或目标更改. 

image:Orchsym Studio-connection.png["Connection"] 


要更改连接的配置或以其他方式与连接交互，请右键单击连接以打开连接上下文菜单. 

image:Orchsym Studio-connection-menu.png["Connection Menu"] 

可以使用以下选项: 

- *配置*:此选项允许用户更改连接的配置. 
- *查看状态历史记录*:此选项打开连接的统计信息随时间的图形表示. 
- *列表队列*:此选项列出可能正在等待处理的FlowFiles队列. 
- *转到来源*:如果画布上连接的源组件和目标组件之间存在较长距离，则此选项很有用. 通过单击此选项，画布视图将跳转到连接源. 
- *去目的地*:与"转到源”选项类似，此选项将视图更改为画布上的目标组件，如果两个连接组件之间的距离较长，则此选项可能很有用. 
- *带到前面*:如果其他内容(例如另一个连接)与其重叠，则此选项将连接带到画布的前端. 
- *空队列*:此选项允许DFM清除可能正在等待处理的FlowFiles队列. 当DFM不关心从队列中删除数据时，此选项在测试期间尤其有用. 选择此选项后，用户必须确认是否要删除队列中的数据. 
- *删除*:此选项允许DFM删除两个组件之间的连接. 请注意，必须先停止连接两侧的组件，并且连接必须为空才能删除. 

==== 弯曲连接 

要将弯曲点(或弯头)添加到现有连接，只需双击要将弯曲点放在的位置的连接. 然后，您可以使用鼠标抓住弯曲点并拖动它，以便以所需的方式弯曲连接. 您可以根据需要添加任意数量的弯曲点. 您还可以使用鼠标将连接上的标签拖动并移动到任何现有折弯点. 要删除折弯点，只需再次双击即可. 

image:Orchsym Studio-connection-bend-points.png["Connection Bend Points"] 


=== 组件验证

在尝试启动组件 之前，确保组件的配置有效非常重要. 
状态指示器显示在组件的左上角.如果组件无效，指示器 
将显示黄色警告指示器，并带有感叹号，表示存在问题: 

image::invalid-processor.png["Invalid Processor"] 

在这种情况下，使用鼠标悬停在指示器图标上将提供工具提示，显示
组件的所有验证 错误.一旦解决了所有验证错误，状态指示器将变为 
Stop图标，表示组件有效并准备启动但当前未运行: 

image::valid-processor.png["Valid Processor"] 



[[site-to-site]] 
=== 站点到站点 

当从一个Orchsym Studio实例向另一个实例发送数据时，可以使用许多不同的协议.
但是，首选 协议是Orchsym Studio站点到站点协议.站点到站点可以轻松安全高效地将数据传输到
一个Orchsym Studio实例中的节点或从一个Orchsym Studio实例中的节点 或数据生成应用程序传输到另一个Orchsym Studio实例或其他消费应用程序中的节点. 

使用站点到站点提供以下好处: 

* 易于配置 
** 输入远程Orchsym Studio实例的URL后，将自动发现可用端口(端点)并在下拉列表中提供 

* 安全 
** 站点到站点可选地使用证书来加密数据并提供身份验证和授权.可以将每个端口配置 
   为仅允许特定用户，并且只有那些用户才能看到该端口甚至存在.有关配置证书的信息， 
   请参阅 
link:administration-guide.html＃安全配置[Security Configuration] 部分 
link:administration-guide.html[System Administrator’s Guide]. 

* 可扩展 
** 随着远程群集中的节点发生更改，将自动检测这些更改，并在群集中的所有节点上扩展数据. 

* 高效 
**站点到站点允许一次发送批量的FlowFiles，以避免建立连接和
   在对等点之间进行多次往返请求的开销 . 

* 可靠 
**校验和由发送方和接收方自动生成，并在数据传输后进行比较， 
   以确保没有发生损坏. 如果校验和不匹配，则只会取消交易并再次尝试. 

* 自动加载平衡 
**当节点联机或退出远程群集，或节点的负载变得更重或更轻时，
   将自动调整定向到该节点的数据量 . 

* FlowFiles维护属性 
**当通过此协议传输FlowFile时，所有FlowFile的属性都会随之 
   自动传输.这在许多情况下都是非常有利的，因为
   由一个Orchsym Studio实例确定的所有上下文和丰富 与数据一起传播，使数据易于路由并允许用户 
   轻松检查数据. 

* 适应性强 
** 随着新技术和新想法的出现，处理站点到站点通信的协议能够随之改变.当与
   远程Orchsym Studio实例建立连接时 ，将执行握手以协商将使用哪种协议和协议版本. 
   这允许添加新功能，同时仍保持与所有旧实例的向后兼容性.此外，如果
   在协议中发现漏洞 或缺陷，它允许更新版本的Orchsym Studio禁止通过受损版本的协议进行通信. 

站点到站点是在两个Orchsym Studio实例之间传输数据的协议. 两端可以是独立的Orchsym Studio或Orchsym Studio集群. 在本节中，Orchsym Studio实例启动通信被调用 _Site-to-Site client Orchsym Studio instance_ 另一端为 _Site-to-Site server Orchsym Studio instance_ 澄清每个Orchsym Studio实例所需的配置. 

Orchsym Studio实例可以是站点到站点协议的客户端和服务器，但是，它只能是特定站点到站点通信中的客户端或服务器. 例如，如果有三个Orchsym Studio实例A，B和C.. A将数据推送到B，B从C中提取数据. _A -- push -> B <- pull -- C_. 那么B不仅仅是一个 _server_ 在A和B之间的沟通中，也是一个 _client_ 在B和C中. 

了解哪个Orchsym Studio实例将是客户端或服务器以设计数据流并相应地配置每个实例非常重要. 以下是基于数据流方向在哪一方运行的组件的摘要: 

- 推:客户端 _sends_ 数据到远程进程组，即服务器 _receives_ 它带有一个输入端口 

- 拉:一个客户 _receives_ 来自远程进程组的数据，即服务器 _sends_ 数据通过输出端口 

==== 配置站点到站点客户端Orchsym Studio实例 

[[Site-to-Site_Remote_Process_Group]] 
*远程进程组*:要通过站点到站点与远程Orchsym Studio实例通信，只需拖动<<遥控器即可_process_group，Remote Process Group>>在画布上 
输入远程Orchsym Studio实例的URL(有关远程进程组组件的更多信息，请参阅 
<<Remote_Group_传输，远程过程组传输>>本指南的部分.)URL与
用于转到该实例的用户界面的URL相同 .此时，您可以将连接拖拽到远程进程组或从远程进程组 
拖拽连接的方式与将组件连接到组件或本地进程组的方式相同.拖动连接时，您将有 
机会选择要连接的端口.请注意，远程进程组最多可能需要一分钟才能确定 
可用的端口. 

如果从远程进程组开始拖动连接，则显示的端口将是远程组的输出端口， 
因为这表示您将从远程实例中提取数据.如果连接在远程进程组上结束， 
则显示的端口将是远程组的输入端口，因为这意味着您将数据推送到远程实例. 

NOTE: 如果远程实例配置为使用安全数据传输，您将只看到您有权
与之通信的端口 . 有关配置Orchsym Studio安全运行的信息，请参阅 
link:administration-guide.html[System Administrator’s Guide]. 

[[Site-to-Site_Transport_Protocol]] 
*传输协议*:在远程进程组创建或配置对话框中，您可以选择用于站点到站点通信的传输协议，如下所示 image: 

image:configure-remote-process-group.png["Configure Remote Process Group"] 

默认情况下，它设置为 _RAW_ 它使用专用端口使用原始套接字通信. _HTTP_ 如果远程
Orchsym Studio实例位于仅允许通过HTTP(S)协议进行访问或仅可从特定HTTP代理服务器访问的受限网络中，则传输协议特别有用 . 
对于通过HTTP代理服务器进行访问，支持BASIC和DIGEST身份验证. 

*本地网络接口*:在某些情况下，可能需要优先选择一个网络接口而不是另一个网络接口.例如，如果存在有线接口和无线 
接口，则有线接口可能是优选的. 可以通过在此框中指定要使用的网络接口的名称来配置.如果
输入的 值无效，则远程进程组将无效，并且在解决此问题之前不会与其他Orchsym Studio实例通信. 

==== 配置站点到站点服务器Orchsym Studio实例 

*检索站点到站点详细信息*:如果您的Orchsym Studio安全运行，为了让另一个Orchsym Studio实例从您的实例中检索信息，需要将其添加到Global Access"检索站点到站点详细信息”策略.  这将允许另一个实例查询您的实例以获取详细信息，例如名称，描述，可用对等体(群集时的节点)，统计信息，OS端口信息以及可用的输入和输出端口. 在安全实例中使用输入和输出端口需要额外的策略配置，如下所述. 

[[Site-to-Site_Input_Port]] 
*输入端口*:为了允许另一个Orchsym Studio实例将数据推送到本地实例，您只需将<<input_port，Input Port>>拖到画布的Root Process Group上. 输入端口名称后，它将添加到您的流程中. 您现在可以右键单击"输入端口”并选择"配置”以调整用于端口的名称和并发任务数. 

如果将站点到站点配置为安全运行，则需要管理端口的"通过站点到站点接收数据”组件访问策略. 只有已添加到策略的用户才能与端口通信. 

[[Site-to-Site_Output_Port]] 
*输出端口*:与输入端口类似，DataFlow Manager可以选择将<<output_port，Output Port>>添加到根进程组. 输出端口允许授权的Orchsym Studio实例远程连接到您的实例并从输出端口提取数据. 配置输出端口和管理端口的访问策略将再次允许DFM控制允许的并发任务数，以及授权哪些用户从正在配置的实例中提取数据. 

除了Orchsym Studio的其他实例之外，一些其他应用程序可能使用站点到站点客户端来将数据推送到Orchsym Studio实例或从Orchsym Studio实例接收数据. 例如，Orchsym Studio提供Apache Storm spout和Apache Spark Receiver，它们能够从Orchsym Studio的根组输出端口提取数据. 

有关如何在Orchsym Studio实例上启用和配置站点到站点的信息，请参阅 
link:administration-guide.html＃现场_to_site_properties[Site-to-Site Properties] 部分 
link:administration-guide.html[System Administrator’s Guide]. 

有关如何配置访问策略的信息，请参阅 
link:administration-guide.html＃访问策略[Access Properties] 部分 
link:administration-guide.html[System Administrator’s Guide]. 


=== 示例数据流 

本节介绍了构建数据流所需的步骤. 现在，把它们放在一起.以下示例数据流 
仅包含两个组件:GenerateFlowFile和LogAttribute.这些组件通常用于测试，但它们也可用于 
构建快速流程以用于演示目的，并查看Orchsym Studio的运行情况. 

将GenerateFlowFile和LogAttribute组件拖到画布并连接它们(使用上面提供的指南)后，按如下所示进行配置: 

* 生成FlowFile 
** 在"调度”选项卡上，将"运行计划”设置为:5秒.请注意，GenerateFlowFile组件可以非常快速地创建许多FlowFiles; 这就是为什么设置运行计划很重要，这样这个流程就不会让Orchsym Studio运行的系统不堪重负. 
** 在"属性”选项卡上，将"文件大小”设置为:10 kb 

* 日志属性 
** 在"设置”选项卡上的"自动终止关系”下，选中"成功”旁边的复选框. 这将在此组件成功处理后终止FlowFiles. 
** 同样在"设置”选项卡上，将"公告”级别设置为"信息”. 这样，当数据流运行时，此组件将显示公告图标(请参阅<<processor_anatomy>>)，用户可以使用鼠标将鼠标悬停在其上，以查看组件正在记录的属性. 

数据流应如下所示: 

image::simple-flow.png["Simple Flow"] 


现在请参阅以下有关如何启动和停止数据流的部分. 当数据流运行时，请务必记下每个组件正面显示的统计信息(请参阅<<processor_anatomy>>). 



== DataFlow的命令和控制 

当组件添加到Orchsym Studio画布时，它处于Stopped状态.为了使组件 
被触发，必须启动组件. 一旦启动，组件可以随时停止.从"已 
停止”状态，可以配置，启动或禁用该组件. 

=== 启动组件 

要启动组件，必须满足以下条件: 

- 组件的配置必须有效. 

- 组件的所有已定义关系必须连接到另一个组件或自动终止. 

- 必须停止该组件. 

- 必须启用该组件. 

- 该组件必须没有活动任务. 有关活动任务的更多信息，请参阅"剖析” ..." 
<<监控>>下的部分(<<组件_anatomy>>, <<process_组_anatomy>>, <<remote_group_anatomy>>). 

可以通过选择要启动的所有组件然后单击"开始”按钮来启动组件( 
image:buttonStart.png["Start"] 
)在 
Operate Palette中或右键单击单个组件并从上下文菜单中选择Start. 

如果启动进程组，则将启动该进程组中的所有组件(包括子进程组) 
，但无效或禁用的组件除外. 

一旦启动，组件的状态指示器将变为播放符号( 
image:iconRun.png["Run"] 
). 


=== 停止组件 

组件可以在运行时停止.右键单击组件 
并从上下文菜单中单击"停止”，或者选择组件并单击"停止”按钮( 
image:buttonStop.png["Stop"] 
)在操作调色板中. 

如果进程组停止，所有的过程组(包括子进程组)中的构件 
将被停止. 

一旦停止，组件的状态指示器将变为停止符号( 
image:iconStop.png["Stop"] 
). 

停止组件不会中断其当前正在运行的任务.相反，它会停止安排
要执行的新任务 .活动任务的数量显示在组件的右上角(有关
详细信息，请参阅<<processor_anatomy>> ). 

=== 启用/禁用组件 

启用组件后，即可启动组件.例如，用户可以选择在组件
仍然是正在组装的数据流的一部分时禁用组件 .通常，如果不打算运行组件，
则禁用该组件 ，而不是将其置于"已停止”状态.这有助于区分
故意不运行的组件 和可能暂时停止的组件(例如，更改组件的 
配置)，并且无意中从未重新启动. 

当需要重新启用组件时，可以通过选择组件并 
单击"启用”按钮来启用它( 
image:buttonEnable.png["Enable"] 
)在操作调色板中. 仅当禁用所选组件时，此选项才可用. 
或者，可以通过选中" 
组件配置”对话框的"设置”选项卡中的"已启用”选项旁边的复选框或端口的配置对话框来启用组件。 . 

启用后，组件的状态指示器将更改为无效( 
image:iconAlert.png["Invalid"] 
)或停止( 
image:iconStop.png["Stopped"] 
)，取决于组件是否有效. 

然后通过选择组件并单击"禁用”按钮来禁用组件( 
image:buttonDisable.png["Disable"] 
)在操作选项板中，或清除
组件配置对话框的设置选项卡中的"已启用”选项旁边的复选框或端口的配置对话框中的复选框 . 

只能启用和禁用端口和组件. 


[[Remote_Group_Transmission]] 
=== 远程进程组传输 

远程进程组提供了一种向远程
Orchsym Studio 实例发送数据或从中检索数据的机制 .将远程进程组(RPG)添加到画布时，会添加"禁用传输”， 
如图标所示( 
image:iconTransmissionInactive.png["Transmission Disabled"] 
)在左上角.当传输被禁用时，可以通过右键单击 
RPG并单击"启用传输”菜单项来启用它.这将导致有连接的所有端口 
开始传输数据. 这将导致状态指示灯变为"已启用传输”图标( 
image:iconTransmissionActive.png["Transmission Enabled"] 
). 

如果与远程进程组通信时出现问题，则会出现警告指示( 
image:iconAlert.png["Warning"] 
)可能会出现在左上角.使用鼠标将鼠标悬停在此警告指示器上将提供 
有关该问题的更多信息. 

[[Remote_Port_Configuration]] 
==== 单个端口传输 

DFM可能希望仅为
远程进程组内的特定端口启用或禁用传输 .这可以通过右键单击远程进程组 
并选择"远程端口”菜单项来完成.这提供了一个配置对话框，可以从中
配置每个端口 : 

image::remote-group-ports-dialog.png["Remote Process Groups"] 

左侧列出了Orchsym Studio的远程实例允许数据发送到的所有输入端口. 
右侧列出了此实例能够从中提取数据的所有输出端口. 
如果远程实例正在使用安全通信(Orchsym Studio实例的URL以 `https://`， 
而不是 `http://`)，将不
显示远程实例未对此实例提供的任何端口 . 

NOTE: 如果此对话框中未显示预期显示的端口，请确保实例具有适当的 
权限，并且远程进程组的流是最新的.可以通过关闭"端口
配置”对话框并查看"远程进程组”的右下角来检查此问题 .
显示上次刷新流的日期 .如果流程似乎已过时，可以通过右键单击 
远程进程组并选择"刷新流程”来更新它."(见<<遥远_group_解剖学>>了解更多信息). 

每个端口都显示端口名称，后跟其描述，当前配置的并发 
任务数，以及是否将压缩发送到此端口的数据.此信息的左侧是 
用于打开或关闭端口的开关. 那些没有连接到它们的连接的端口显示为灰色: 

image::remote-port-connection-status.png["Remote Port Statuses"] 

开/关开关提供了一种机制，可以
独立地启用和禁用远程进程组中每个端口的传输 .可以
通过单击铅笔图标配置已连接但当前未传输的端口 ( 
image:iconEdit.png["Edit"] 
)在开/关开关下面.单击此图标将允许DFM更改并发任务的数量，以及
在向此端口传输数据时是否 应使用压缩. 



[[navigating]] 
== 在DataFlow中导航 

Orchsym Studio提供了各种用于绕过数据流的机制.<<User_Interface>>部分描述了在Orchsym Studio画布中导航的各种方法; 但是，一旦画布上存在流，就会有其他方法从一个组件到另一个组件. 当流中存在多个进程组时，屏障底部会出现面包屑，提供了在它们之间导航的方法. 此外，要进入当前在画布上可见的进程组，只需双击它，从而"向下钻取”它. Connections还提供了一种在流程中从一个位置跳转到另一个位置的方法. 右键单击连接并选择"转到源”或"转到目标”以跳转到连接的一端或另一端. 这在大型复杂数据流中非常有用，其中连接线可能很长并且跨越画布的大部分区域. 最后，所有组件都提供了在流程中向前或向后跳跃的能力. 右键单击任何组件(例如，.G.，组件，进程组，端口等.)并选择"上游连接”或"下游连接”. 将打开一个对话框窗口，显示用户可以跳转到的可用上游或下游连接. 当尝试沿向后方向跟踪数据流时，这尤其有用.通常很容易从头到尾跟踪数据流的路径，向下钻取到嵌套的流程组; 但是，在另一个方向上跟踪数据流可能更加困难. 

[[component_linking]] 
=== 组件链接 

超链接可用于直接导航到Orchsym Studio画布上的组件. 这在以下情况下特别有用 link:administration-guide.html＃多租户授权[Multi-Tenant Authorization] 已配置. 例如，可以将URL提供给用户，以将其定向到他们具有权限的特定进程组. 

Orchsym Studio实例的默认URL是 `http://<hostname>:8080/Orchsym Studio`，指向根进程组.  在画布上选择组件后，将使用表单中组件的进程组ID和组件ID更新URL `http://<hostname>:8080/Orchsym Studio/?processGroupId=<UUID>&componentIds=<UUIDs>`.  在以下屏幕截图中，进程组PG1中的GenerateFlowFile组件是所选组件: 

image::component-linking-processor.png["Component Linking Processor Example"] 

NOTE: 支持链接到画布上的多个组件，但限制URL的长度不能超过2000个字符. 

[[component_alignment]] 
=== 组件对齐 

Orchsym Studio画布上的组件可以对齐，以更精确地排列数据流. 要执行此操作，请首先选择要对齐的所有组件.  然后右键单击以查看上下文菜单，并根据所需结果选择"垂直对齐”或"水平对齐”. 

==== 垂直对齐 

下面是在画布上垂直对齐组件的示例.  选中/突出显示所有组件后，右键单击: 

image:align-vertically-before.png["Align Vertically Example Before"] 

并选择"垂直对齐”以获得以下结果: 

image:align-vertically-after.png["Align Vertically Example After"] 

==== 水平对齐 

下面是在画布上水平对齐组件的示例.  选中/突出显示所有组件后，右键单击: 

image:align-horizontally-before.png["Align Horizontally Example Before"] 

并选择"水平对齐”以获得以下结果: 

image:align-horizontally-after.png["Align Horizontally Example Before"] 


[[monitoring]] 
== 监控DataFlow 

Orchsym Studio提供了大量有关DataFlow的信息，以便监控其 
健康状况.状态栏提供有关整体系统运行状况的信息 
(请参阅<<User_Interface>>).组件，进程组和远程进程组 
提供有关其操作的细粒度详细信息.连接和进程组提供 
有关其队列中数据量的信息.摘要页面
以表格格式提供有关画布上所有组件的信息 ，还提供系统诊断，其中包括磁盘使用情况， 
CPU利用率以及Java堆和垃圾收集信息.在群集环境中，此
信息可以按节点使用， 也可以作为整个群集中的聚合使用.我们将
在下面探讨每个 监控工件. 


[[processor_anatomy]] 
=== 组件

Orchsym Studio的剖析 提供了有关画布上每个组件的大量信息.下图 
显示了组件的解剖结构: 

image:processor-anatomy.png["Anatomy of a Processor"] 

该图像概述了以下元素: 

- *组件类型*:Orchsym Studio提供多种不同类型的组件，以便
执行各种 任务. 每种类型的组件都旨在执行一项特定任务.组件 
类型(在此示例中为PutFile)描述了此组件执行的任务.在这种情况下， 
组件将FlowFile写入磁盘- 或"将”FlowFile"放入”文件. 

- *公告指标*:当组件记录某个事件已发生时，它会生成一个公告，以通知 
用户界面监视Orchsym Studio的人员.DFM能够
通过更新
组件配置对话框的"设置”选项卡中的"公告级别”字段来配置 应在用户界面中显示的公告 . 默认值为 `WARN`，这意味着只会 
在UI中显示警告和错误.除非此
组件存在公告，否则此图标不存在 .当它出现时，用鼠标悬停在图标上将提供一个工具提示，说明
组件提供的 消息以及公告级别.如果Orchsym Studio的实例是群集的， 
它还将显示发布公告的节点. 公告会在五分钟后自动失效. 

- *状态指标*:显示组件的当前状态. 以下指标是可能的: 
** image:iconRun.png["Running"] 
*运行*:组件当前正在运行. 
** image:iconStop.png["Stopped"] 
*停止*:组件有效并已启用但未运行. 
** image:iconAlert.png["Invalid"] 
*无效*:组件已启用但当前无效且无法启动. 
将鼠标悬停在此图标上将提供工具提示，指示组件无效的原因. 
** image:iconDisable.png["Disabled"] 
*残*:组件未运行，在启用之前无法启动. 
此状态不表示组件是否有效. 

- *组件名称*:这是组件的用户定义名称.默认情况下，Processor的名称 
与Processor Type相同. 在示例中，此值为"复制到/审核”. 

- *活动任务*:此组件当前正在执行的任务数.此数字受
组件配置对话框的"计划”选项卡中的"并发任务”设置的约束 . 
在这里，我们可以看到组件当前正在执行一项任务.如果Orchsym Studio实例是群集的，则 
此值表示当前正在群集中的所有节点上执行的任务数. 

- *5分钟统计*:组件以表格形式显示几个不同的统计信息.这些
统计数据中的每一个都 代表过去五分钟内完成的工作量.如果Orchsym Studio 
实例是群集的，则这些值表示
在过去五分钟内所有节点组合完成了多少工作 . 这些指标是: 

** *在*:组件从其传入连接的队列中提取的数据量. 
此值表示为<count>(<size>)，其中<count>是
从队列中提取的FlowFiles的数量， <size>是这些FlowFiles的总大小' 内容.在此示例中， 
组件已从输入队列中提取了29个FlowFiles，总共14个.16兆字节(MB). 
** *读/写*:组件从磁盘读取并写入
磁盘的FlowFile内容的总大小 . 这提供了有关此组件所需的I / O性能的有用信息. 
某些组件可能只读取数据而不写入任何内容，而有些组件不会读取数据但 
只会写入数据.其他人既不会读取也不会写入数据，而某些组件会读取 
和写入数据. 在这个例子中，我们看到在过去的五分钟内，这个组件读取了4.88 
MB的FlowFile内容并写了4.88 MB也是如此.这是我们所期望的， 
因为这个组件只是将FlowFile的内容复制到磁盘.但请注意，这 
与从输入队列中提取的数据量不同.这是因为
它从输入队列中提取的某些 文件已经存在于输出目录中，并且 
组件配置为在发生这种情况时将FlowFiles路由到失败.因此，对于那些 
已经存在于输出目录中的文件，数据既不会被读取也不会被写入磁盘. 
** *退房*:组件已传输到其出站连接的数据量.这不 
包括组件自行删除的FlowFiles，或者路由到
自动终止的连接的FlowFiles .与上面的"In”指标一样，此值表示为<count>(<size>) 
，其中<count>是已传输到出站Connections的FlowFiles的数量，<size> 
是这些FlowFiles的总大小' 内容.在此示例中，所有关系都配置为 
自动终止，因此不会报告任何FlowFiles已被转出. 
** *任务/时间*:此组件在过去5分钟内被触发运行的次数，以及 
执行这些任务所花费的时间. 时间格式为<hour>:<minute>:<second>.请注意 
，所花费的时间可能超过五分钟，因为许多任务可以并行执行.对于 
例如，如果组件定于60个并发任务运行，并且每个这些任务需要一 
秒钟完成，有可能是所有60个任务将在一秒钟内完成.但是，在这种 
情况下，我们会看到时间指标显示它需要60秒而不是1秒.这个时间可以被 
认为是"系统时间”，或者说另一种方式，这个值是60秒，因为
如果只使用一个并发任务，它就是执行操作所需的 时间. 





[[process_group_anatomy]] 
=== 进程组剖析 

进程组提供了一种机制，用于将组件组合到一个逻辑结构中，以便 
以更高级别更容易理解的方式组织DataFlow。. 
下图突出显示了构成Process Group解剖结构的不同元素: 

image::process-group-anatomy.png["Anatomy of a Process Group"] 

流程组由以下元素组成: 

- *名称*:这是进程组的用户定义名称.将进程组
添加到画布时设置此名称 .稍后可以通过右键单击"进程组”并单击
"配置”菜单选项来更改名称 . 在此示例中，Process Group的名称为"Process Group ABC”." 

- *公告指标*:当进程组的子组件发布公告时，该公告也会传播到 
组件的父进程组，.当任何组件具有活动公告时，将显示此指示符， 
允许用户使用鼠标将鼠标悬停在图标上以查看公告. 

- *活动任务*:此
进程组中的组件当前正在执行的任务数 . 在这里，我们可以看到Process Group当前正在执行两项任务.如果 
Orchsym Studio实例是群集的，则此值表示当前正在
群集中的所有节点上执行的任务数 . 


- *统计*:流程组提供有关过程组在 
过去5分钟内处理的数据量以及当前在流程组中排队的数据量的统计信息.以下元素 
包含流程组的"统计”部分: 
** *排队*:当前在进程组中排队的FlowFiles数. 
此字段表示为<count>(<size>)，其中<count>是
当前在Process Group中排队的FlowFiles的数量， <size>是这些FlowFiles的总大小' 内容.在此示例中， 
Process Group当前有26个FlowFiles排队，总大小为12.7兆字节(MB). 

** *在*:
在过去5分钟内通过其所有输入端口传输到进程组的FlowFiles数 . 该字段表示为<count> / <size> -> <ports>其中<count>是过去5分钟内进入Process Group的FlowFiles数，<size>是这些FlowFiles的总大小' content和<ports>是输入端口的数量. 在此示例中，8个FlowFiles已进入进程组，总大小为800 KB，并且存在两个输入端口. 

** *读/写*:进程组中的组件
已从磁盘读取并写入磁盘的FlowFile内容的总大小 .这提供了有关此
Process Group所需的I / O性能的有用信息 .在此示例中，我们看到在过去五分钟内，此
Process Group中的组件 已读取14.72 MB的FlowFile内容并写了14.8 MB. 

** *退房*:
过去5分钟内通过其输出端口传输出进程组的FlowFiles数 . 该字段表示为<ports> -> <count>(<size>)其中<ports>是输出端口的数量，<count>是过去5分钟内退出Process Group的FlowFiles的数量，<size>是这些FlowFiles的总大小' 内容. 在此示例中，有三个输出端口，16个FlowFiles已退出进程组，其总大小为78.57 KB. 

- *组件计数*:Component Counts元素提供有关
Process Group中存在的每种类型的组件数的信息 . 以下提供了有关每个图标及其含义的信息: 

** image:iconTransmissionActive.png["Transmission Active"] 
*传输端口*:当前配置为将数据传输到远程
Orchsym Studio实例或从远程Orchsym Studio实例提取数据的远程进程组端口数 . 

** image:iconTransmissionInactive.png["Transmission Inactive"] 
*非传输端口*:当前连接到此
进程组中的组件但当前已禁用其传输的远程进程组端口的数量 . 

** image:iconRun.png["Running"] 
*运行组件*:当前在此
进程组中运行的组件，输入端口和输出端口的数量 . 

** image:iconStop.png["Stopped Components"] 
*停止组件*:当前未运行但
有效且已启用的组件，输入端口和输出端口的数量 . 这些组件已准备好启动. 

** image:iconAlert.png["Invalid Components"] 
*无效的组件*:已启用但当前
未处于有效状态的组件，输入端口和输出端口的数量 . 这可能是由于配置错误或缺少关系造成的. 

** image:iconDisable.png["Disabled Components"] 
*残疾人组件*:当前禁用的组件，输入端口和输出端口的数量.这些 
组件可能有效，也可能无效.如果启动了进程组，则这些组件不会导致任何错误， 
但不会启动. 

- *版本状态计数*:Version State Counts元素提供有关Process Group中有多少版本化进程组的信息. 有关更多信息，请参阅<<version_states>>. 

- *注释*:将进程组添加到画布时，将为用户提供指定注释的选项，以提供有关进程组的信息. 稍后可以通过右键单击"进程组”并单击"配置”菜单选项来更改注释. 



[[remote_group_anatomy]] 
=== 远程进程组剖析 

创建DataFlow时，通常需要将数据从一个Orchsym Studio实例传输到另一个实例. 
在这种情况下，Orchsym Studio的远程实例可以被视为进程组.因此，Orchsym Studio 
提供了远程处理组的概念.从用户界面，远程进程组 
看起来类似于进程组.但是，不是显示有关
远程进程组的内部工作 和状态的信息(例如队列大小)，而是提供有关远程
进程组的信息 与此Orchsym Studio实例与远程
实例之间发生的交互有关。 . 

image::remote-group-anatomy.png["Anatomy of a Remote Process Group"] 

上图显示了构成远程进程组的不同元素.在这里，我们提供 
有关所提供信息的图标和详细信息的说明. 

- *传输状态*:传输状态指示当前是否
启用此Orchsym Studio实例与远程实例之间的数据传输 .显示的图标将是 
Transmission Enabled图标( 
image:iconTransmissionActive.png["Transmission Active"] 
)如果任何输入端口或输出端口当前配置为传输或传输 
已禁用图标( 
image:iconTransmissionInactive.png["Transmission Inactive"] 
)如果当前连接的所有输入端口和输出端口都已停止. 

- *远程实例名称*:这是远程实例报告的Orchsym Studio实例的名称. 
首次创建远程进程组时，在获取此信息之前，
将在此处显示远程实例的URL . 

- *远程实例URL*:这是远程进程组指向的远程实例的URL. 
将远程进程组添加到画布并且无法更改时，将输入此URL. 

- *安全指标*:此图标表示与远程Orchsym Studio实例的通信是否 
安全.如果与远程实例的通信是安全的，则将通过"锁定” 
图标指示 ( 
image:iconSecure.png["Secure"] 
). 如果通信不安全，将通过"未锁定”图标指示( 
image:iconNotSecure.png["Not Secure"] 
).如果通信是安全的，则在
远程实例的管理员授予访问权限之前，此Orchsym Studio实例将无法与远程实例通信 .每当将远程进程 
组添加到画布时，这将自动发起请求，以便在
远程实例上创建此Orchsym Studio 实例的用户.在远程实例上的管理员
将用户添加到系统并向用户添加"Orchsym Studio”角色之前，此实例将无法与远程实例通信 . 
如果通信不安全，远程进程组可以从任何人接收数据， 
并且在Orchsym Studio实例之间传输数据时不会对数据进行加密. 

- *5分钟统计*:显示远程进程组的两个统计信息: *发送* 和 *收到*.这两种
格式都是 <count>(<size>)格式，其中<count>是
前五分钟内发送或接收的FlowFiles的数量， <size>是这些FlowFiles的总大小' 内容. 

- *注释*:为远程进程组提供的注释不是由此Orchsym Studio的用户 
添加的注释，而是由远程实例的管理员添加的注释.这些评论表明了Orchsym Studio 
实例的整体目的. 

- *最后更新时间*:从远程实例中提取并
在用户界面中的远程进程组上呈现的信息会 在后台定期刷新.此元素指示
上次刷新的时间 ，或者如果信息在相当长的时间内未刷新，则值将更改为 
指示 _Remote flow not current_.通过右键单击
远程进程组并选择"刷新流程”菜单项，可以触发Orchsym Studio以启动刷新此信息 . 



[[Queue_Interaction]] 
=== 队列交互 

可以在必要时查看连接中排队的FlowFiles. 队列列表通过打开 `List queue` 在 
Connection的上下文菜单中.该列表将根据
配置的优先级返回活动队列中的前100个FlowFiles . 即使源和目标正在运行，也可以执行列表. 

此外，单击"详细信息”图标可查看列表中Flowfile的详细信息( 
image:iconDetails.png["Details"] 
)在最左边的列中.从这里，可以使用FlowFile详细信息和属性以及用于
下载或查看内容的按钮 . 仅在Orchsym Studio时才能查看内容.内容.观众.网址已配置. 
如果Connection的源或目标正在运行，则所需的FlowFile可能 
不再位于活动队列中. 

必要时，还可以删除连接中排队的FlowFiles.
通过以下方式启动FlowFiles的删除 `Empty queue` 在Connection的上下文菜单中.如果源和目标
正在运行，也可以执行此操作 . 


[[Summary_Page]] 
=== 摘要页面 

虽然Orchsym Studio画布对于了解如何布置配置的DataFlow非常有用，但
在尝试识别系统状态时，此视图并不总是最佳 的.为了帮助用户了解DataFlow如何 
在更高级别运行，Orchsym Studio提供了"摘要”页面.此页面位于
用户界面右上角的" 全局菜单”中 . 有关此工具栏位置的详细信息，请参阅<<User_Interface>>部分. 

通过从全局菜单中选择摘要来打开摘要页面. 这将打开"摘要”表对话框: 

image::summary-table.png["Summary Table"] 

此对话框提供有关画布上每个组件的大量信息.下面，我们
在对话框中注释 了不同的元素，以便更容易地讨论对话框. 

image::summary-annotated.png["Summary Table Annotated"] 

"摘要”页面主要由一个表组成，该表提供有关画布上每个组件的信息.此
表上方 是一组五个选项卡，可用于查看不同类型的组件.表 
中提供的信息与为画布上的每个组件提供的信息相同.可以通过
单击列的标题对表中的每个列进行排序 .有关所显示信息类型的更多信息，请参阅
<<组件部分 _anatomy>>, <<process_group_anatomy>>，和<<remote_group_解剖学>>上面. 

"摘要”页面还包含以下元素: 

- *公告指标*:与整个用户界面中的其他位置一样，当存在此图标时，将鼠标悬停在图标上将 
提供有关生成的公告的信息，包括消息，严重性级别，
公告生成的时间 以及(在集群环境)生成公告的节点.与" 
摘要”表中的所有列一样 ，可以
通过单击标题对显示公告的列进行排序 ，以便所有当前存在的公告显示在列表顶部. 

- *细节*:单击"详细信息”图标将为用户提供组件的详细信息.此对话框
与用户右键单击组件并选择"查看配置”菜单项时提供的对话框相同 . 

- *去*:单击此按钮将关闭"摘要”页面，并将用户直接带到Orchsym Studio画布上的组件.这 
可能会更改用户当前所在的进程组.如果已
在新的浏览器选项卡或窗口中打开"摘要”页面(通过单击"弹出”按钮，则此图标不可用 ，如下所述). 

- *状态历史*:单击"状态历史记录”图标将打开一个新对话框，其中显示
为此组件呈现的统计信息的历史视图 . 有关更多信息，请参阅<<Status_History>>部分. 

- *刷新*:"刷新”按钮允许用户刷新显示的信息，而无需关闭对话框并
再次打开它 . 上次刷新信息的时间显示在"刷新”按钮的右侧.
页面上的信息 不会自动刷新. 

- *过滤*:Filter元素允许用户通过键入全部或部分条件(
例如组件类型或组件名称)来过滤Summary表的内容 . 可用的过滤器类型因所选标签而异.例如， 
如果查看"组件”选项卡，则用户可以按名称或类型进行过滤.查看"连接”选项卡时，用户 
可以按源，名称或目标名称进行筛选.
更改文本框的内容时，将自动应用过滤器 .文本框下方是表中表中有多少
条目与过滤器匹配以及表中存在多少条目的指示符 . 

- *弹出*:监视流时，能够在单独的浏览器选项卡或窗口中打开"摘要”表是有帮助的." 
关闭”按钮旁边的" 弹出”按钮将导致在新的浏览器选项卡或窗口中打开整个"摘要”对话框 
(具体取决于浏览器的配置).页面"弹出”后，对话框将在原始
浏览器选项卡/窗口中关闭 . 在新选项卡/窗口中，弹出按钮和"转到”按钮将不再可用. 

- *系统诊断*:"系统诊断”窗口提供有关系统在
系统资源利用率方面的执行情况的信息 .虽然这主要面向管理员，但在此视图
中提供了它，因为它 确实提供了系统摘要.此对话框显示CPU利用率，磁盘空闲程度 
以及特定于Java的度量标准(如内存大小和利用率)以及垃圾收集信息等信息. 




[[Status_History]] 
=== 组件的历史统计信息 

虽然摘要表和画布显示了
过去五分钟内与组件性能相关的数字统计信息 ，但查看历史统计信息通常也很有用。.该信息可 
通过一个组件，选择"状态历史记录”菜单选项上单击鼠标右键或通过单击摘要页的状态历史记录(见<<Summary_Page>> 
了解更多信息). 

存储的历史信息量可在Orchsym Studio属性中配置，但默认为24小时.有关特定 
配置信息，请参阅的组件状态存储库link:administration-guide.html[System Administrator’s Guide]. 
打开"状态历史记录”对话框时，它会提供历史统计信息的图表: 

image::stats-history.png["Status History"] 

对话框的左侧提供有关统计信息所用组件的信息，以及
绘制统计信息的文本 表示形式. 左侧提供以下信息: 

- *ID*:正在显示统计信息的组件的ID. 

- *组ID*:组件所在的进程组的ID. 

- *名称*:正在显示统计信息的组件的名称. 

- *特定于组件的条目*:显示每种不同类型组件的信息.例如，对于组件，
将显示组件 的类型. 对于Connection，将显示源和目标名称和ID. 

- *开始*:图表上显示的最早时间. 

- *结束*:图表上显示的最新时间. 

- *最小/最大/平均值*:显示最小值，最大值和平均值(算术平均值或平均值).
如果选择了任何时间范围，这些值仅基于 所选时间范围.如果Orchsym Studio的这个实例是群集的，
则会为整个群集以及每个单独的节点显示这些值 .在群集环境中，每个节点 
以不同的颜色显示. 这也用作图形的图例，显示图形中显示的每个节点的颜色. 
将鼠标悬停在群集上或图例中的其中一个节点上也会使相应的节点在图形中变为粗体. 


对话框的右侧提供了下表中要呈现的不同类型度量标准的下拉列表. 
顶部图形较大，以便提供更容易阅读的信息呈现.在
这个图的右下角 是一个小手柄( 
image:iconResize.png["Resize"] 
)可以拖动来调整图形的大小.也可以拖动对话框的空白区域 
以移动整个对话框. 

底部图表更短，并提供选择时间范围的能力.在此处选择时间范围将使 
顶部图形仅显示所选的时间范围，但以更详细的方式显示.此外，这将导致
重新计算左侧的 最小值/最大值/平均值.
通过在图形上拖动矩形创建选区后 ，双击所选部分将使选择在
垂直方向上完全展开 (i.Ë.，它将选择此时间范围内的所有值).单击底部图形而不拖动 
将删除选择. 

[[versioning_dataflow]] 
== 对DataFlow 
进行版本控制当Orchsym Studio连接到Orchsym Studio注册表时，可以在进程组级别对数据流进行版本控制.  有关Orchsym Studio注册表使用和配置的更多信息，请参阅文档 link:https://Orchsym Studio.apache.org/docs/Orchsym Studio-registry-docs/index.html[https://Orchsym Studio.apache.org/docs/Orchsym Studio-registry-docs/index.html^]. 

=== 连接到Orchsym Studio注册表 
要将Orchsym Studio连接到注册表，请从全局菜单中选择控制器设置. 

image::controller-settings-selection.png["Global Menu - Controller Settings"] 

这将显示"Orchsym Studio设置”窗口. 选择"注册表客户端”选项卡，然后单击右上角的"+”按钮以注册新的注册表客户端. 

image::registry-clients-tab.png["Registry Clients Tab"] 

在"添加注册表客户端”窗口中，提供名称和URL. 

image::add-registry-client.png["Add Registry Client Dialog"] 

单击"添加”以完成注册. 

image::registry-client-added.png["Registry Client Added"] 

NOTE: 版本化流程在注册表桶中存储和组织. 注册管理员配置的存储桶策略和特殊权限确定用户可以从哪些存储桶导入版本化流，以及用户可以将版本化流传输到哪些存储桶. 有关存储桶策略和特权的信息可在Orchsym Studio注册表用户指南中找到(link:https://Orchsym Studio.apache.org/docs/Orchsym Studio-registry-docs/html/user-guide.html[https://Orchsym Studio.apache.org/docs/Orchsym Studio-registry-docs/html/user-guide.html^]). 

[[version_states]] 
=== 版本状态 
版本化的进程组存在以下状态: 

** image:iconUpToDate.png["Up to date"] 
*最新*:流程版本是最新版本. 

** image:iconLocallyModified.png["Locally Modified"] 
*本地修改*:已进行本地更改. 

** image:iconStale.png["Stale"] 
*陈旧*:可以使用更新版本的流程. 

** image:iconLocallyModifiedStale.png["Locally Modified and Stale"] 
*本地修改和陈旧*:已进行本地更改，并且可以使用更新版本的流程. 

** image:iconSyncFailure.png["Sync Failure"] 
*同步失败*:无法与注册表同步流. 

显示版本状态信息: 

1. 进程组名称旁边的版本化进程组本身. 将鼠标悬停在状态图标上会显示有关版本化流程的其他信息. 
2. 在进程组的底部，用于进程组中包含的版本化流. 
3. 在UI顶部的状态栏中，用于根进程组中包含的版本化流. 

image::version-states-display.png["Version States Displayed"] 

版本状态信息也显示在摘要页面的"过程组”选项卡中. 

image::version-state-summary-page.png["Version State in Summary Page"] 

NOTE: 要查看最新版本的状态，可能需要右键单击Orchsym Studio画布并选择"刷新”' 从上下文菜单中. 

=== 导入版本化流程 
当Orchsym Studio实例连接到注册表时，"导入”链接将出现在"添加进程组”对话框中. 

image::add-process-group-import.png["Import Process Group"] 

选择链接将打开"导入版本”对话框. 

image::import-version-dialog.png["Import Version Dialog"] 

已连接的注册表将在"注册表”下拉菜单中显示为选项.  对于选定的注册表，用户有权访问的存储桶将显示为"存储桶”下拉菜单中的选项.  所选存储桶中的流的名称将显示为"名称”下拉菜单中的选项.  选择要导入的所需流的版本，然后为要放置在画布上的数据流选择"导入”. 

image::versioned-flow-imported.png["Versioned Flow Imported"] 

由于此示例中导入的版本是最新版本(MySQL CDC，版本3)，因此版本化进程组的状态为"最新”(image:iconUpToDate.png["Up To Date Icon"]).  如果导入的版本是旧版本，则状态将为"Stale”(image:iconStale.png["Stale Icon"]). 

=== 启动版本控制 
要将进程组置于版本控制之下，右键单击进程组，然后在上下文菜单中选择"版本 - >启动版本控制”. 

image::start-version-control.png["Start Version Control"] 

在Save Flow Version窗口中，选择Registry and Bucket并输入Flow的名称.  如果需要，请为"描述”和"注释”字段添加内容. 

image::save-flow-version-dialog.png["Save Flow Version Dialog"] 

选择保存并保存流的版本1. 

image::versioned-process-group.png["Versioned Process Group"] 

作为流程的第一个和最新版本，版本化进程组的状态为"最新”(image:iconUpToDate.png["Up To Date Icon"]). 

NOTE: 根进程组不能置于版本控制之下. 

[[managing_local_changes]] 
=== 管理本地更改
对版本化进​​程组进行更改 时，组件的状态将更新为"本地修改”(image:iconLocallyModified.png["Locally Modified Icon"]).  DFM可以显示，还原或提交本地更改. 右键单击进程组时，可以在上下文菜单中选择这些选项: 

image::local-changes-pg-selected.png["Local Changes PG Selected"] 

或者右键单击进程组内的画布: 

image::local-changes-pg-inside.png["Local Changes Inside PG"] 

以下操作不被视为本地更改: 

* 禁用/启用组件和控制器服务 
* 停止/启动组件 
* 修改敏感属性值 
* 修改远程进程组URL 
* 更新引用不存在的控制器服务的组件以引用外部可用的控制器服务 
* 修改变量 

WARNING: 变量不支持敏感值，并且在对流程组进行版本控制时将包含变量. 见<<Variables_in_Versioned_流程>>了解更多信息. 

==== 显示本地更改 
通过从上下文菜单中选择"版本 - >显示本地更改”，可以在"显示本地更改”对话框中查看对版本化过程组所做的本地更改. 

image::show-local-changes-dialog.png["Show Local Changes Dialog"] 

您可以通过选择"转到”图标导航到组件(image:iconGoTo.png["Go To"]在它的行. 

NOTE: 如"管理”所述_local_更改>>部分，有哪些操作可审核本地更改的例外情况.  此外，对同一属性的多次更改将仅显示为列表中的一个更改，因为更改是通过区分进程组的当前状态和"显示本地更改”对话框中记录的进程组的已保存版本来确定的. 

==== 还原本地更改 
通过从上下文菜单中选择"版本 - >还原本地更改”，还原对版本化进​​程组所做的本地更改.  "还原本地更改”对话框显示DFM在启动还原之前要查看和考虑的本地更改列表.  选择"还原”以删除所有更改. 

image::revert-local-changes-dialog.png["Revert Local Changes Dialog"] 

您可以通过选择"转到”图标导航到组件(image:iconGoTo.png["Go To"]在它的行. 

NOTE: 如"管理”所述_local_更改>>部分，有哪些操作可以恢复本地更改的例外情况.  此外，对同一属性的多次更改将仅显示为列表中的一个更改，因为更改是通过区分进程组的当前状态和"还原本地更改”对话框中记录的进程组的已保存版本来确定的. 

==== 提交本地更改 
要提交和保存流版本，请从上下文菜单中选择"版本 - >提交本地更改”.  在"保存流版本”对话框中，根据需要添加注释，然后选择"保存”. 

image::save-flow-version-commit.png["Save Flow Version Commit"] 

如果已修改的版本不是最新版本，则无法提交本地更改.  在这种情况下，版本状态是"本地修改和陈旧”(image:iconLocallyModifiedStale.png["Locally Modified and Stale"]). 

=== 更改版本 
要更改流的版本，请右键单击版本化的流程组，然后选择"版本 - >更改版本”. 

image::change-version.png["Change Version"] 

在"更改版本”对话框中，选择所需的版本并选择"更改”: 

image::change-version-dialog.png["Change Version Dialog"] 

流的版本已更改: 

image::flow-version-changed.png["Flow Version Changed"] 

在所示示例中，版本化流程从较旧版本升级到较新版本.  但是，版本化流程也可以回滚到旧版本. 

NOTE: 要使"更改版本”成为可用选择，需要还原对进程组的本地更改. 

=== 停止版本控制 
要停止对流的版本控制，请右键单击版本化的进程组，然后选择"版本 - >停止版本控制”: 

image:stop-version-control.png["Stop Version Control"] 

在"停止版本控制”对话框中，选择"断开连接”. 

image::stop-version-control-dialog.png["Stop Version Control Dialog"] 

确认从版本控制中删除进程组. 

image:disconnect-dialog.png["Disconnect Confirmation Dialog"] 

image::process-group-version-control-stopped.png["Version Control Stopped on Process Group"] 

=== 嵌套版本 
化流程版本化过程组可以包含其他版本化过程组.  但是，如果父进程组包含也具有本地更改的子进程组，则无法还原或保存对父进程组的本地更改.  必须首先还原子进程组，或者为要在父进程组上执行的操作提交其更改. 

[[Variables_in_Versioned_Flows]] 
=== 版本化流程中的 
变量当流程组置于版本控制之下时，会包含变量.  如果导入的版本化流引用了未在版本化进程组中定义的变量，则在变量存在时保留引用.  如果引用的变量不存在，则将在进程组中定义变量的副本.  为了说明，假设变量"RPG_Var”在根进程组中定义: 

image::rpg-variable.png["Root Process Group Defined Variable"] 

创建进程组PG1: 

image::PG1_process_group.png["PG1 Process Group"] 

PG1中的GetFile组件引用变量"RPG_Var”: 

image::PG1_variable_reference.png["PG1 References RPG Variable"] 

PG1保存为版本化流程: 

image::PG1_versioned_flow.png["PG1 Versioned Flow"] 

如果PG1版本化流程导入到同一个Orchsym Studio实例中: 

image::PG1_imported_same.png["PG1 Imported to Same Orchsym Studio"] 

添加的GetFile组件还将引用根进程组中存在的"RPG_Var”变量: 

image::PG1_variable_ref_2.png["Both PG1 Reference RPG Variable"] 

如果PG1版本化流程导入到不存在"RPG_Var”的不同Orchsym Studio实例中: 

image::PG1_imported_diff.png["PG1 Imported to Different Orchsym Studio"] 

在PG1进程组中创建"RPG_Var”变量: 

image::PG1_variable_ref_PG.png["PG1 References PG Variable Copy"] 

[[Restricted_Components_in_Versioned_Flows]] 
=== 版本
化流程中受限制的组件 要导入版本化流程或还原版本化流程中的本地更改，用户必须能够访问版本化流程中的所有组件. 因此，如果要在版本化流程中使用受限制的组件，则建议在根进程组级别创建受限组件. 让我们通过一些示例来说明此配置的好处. 假设如下: 

* 有两个用户，"sys_admin" and "test_用户"有权访问查看和修改根进程组的用户. 

* "sys_admin”可以访问所有受限制的组件. 
+ 
image::sys_admin-restricted-component-access-policy.png["Sys_admin Restricted Component Access Policy"] 

* "test_user”可以访问需要"读取文件系统”的受限组件' 和'写文件系统'. 
+ 
image::test_user-restricted-component-read-filesystem.png["Test_user Restricted Component Read Filesystem"] 
+ 
image::test_user-restricted-component-write-filesystem.png["Test_user Restricted Component Write Filesystem"] 

==== 在根进程组中创建的受限制的控制器服务 
在第一个示例中，sys_admin在根进程组级别创建KeytabCredentialsService控制器服务. 

image:keytabCredentialsService-rpg.png["KeytabCredentialsService Controller Service RPG Level"] 

KeytabCredentialService控制器服务是一个受限制的组件，需要"访问密钥表”' 权限: 

image:keytabcredentialsservice-permissions.png["KeytabCredentialService Required Permissions"] 

Sys_admin使用GetFile和PutHDFS组件创建一个包含流的进程组ABC: 

image:abc-restricted-component-flow.png["Restricted Component Flow"] 

GetFile组件是一个受限制的组件，需要"写入文件系统”' 并'读取文件系统' 权限: 

image:getfile-permissions.png["GetFile Required Permissions"] 

PutHDFS是一个需要'写文件系统'的受限组件' 权限: 

image:puthdfs-permissions.png["PutHDFS Required Permissions"] 

PutHDFS组件配置为使用根进程组级别KeytabCredentialsService控制器服务: 

image:puthdfs-properties.png["PutHDFS Properties"] 

Sys_admin将进程组保存为版本化流: 

image:abc-versioned-flow.png["ABC Versioned Flow"] 

Test_user通过删除KeytabCredentialsService控制器服务来更改流程: 

image:puthdfs-no-kerberosCS.png["PutHDFS No Kerberos CS"] 

如果test_user选择还原此更改: 

image:test_user-revert-local-changes.png["Test_user Revert Local Changes] 

恢复成功: 

image:revert-success.png["Revert Local Changes Successful"] 

另外，如果test_user选择导入ABC版本化流程: 

image:test_user-import-abc-flow.png["Test_user Import Flow"] 

导入成功: 

image:test_user-import-success.png["Test_user Import Successful"] 

==== 在流程组中创建受限制的控制器服务 
现在，考虑在流程组级别创建控制器服务的第二种方案. 

Sys_admin创建一个进程组XYZ: 

image:xyz-process-group.png["XYZ Process Group"] 

Sys_admin在进程组级别创建KeytabCredentialsService控制器服务: 

image:keytabCredentialsService-pg.png["KeytabCredentialsService Controller Service PG Level"] 

在进程组中创建相同的GetFile和PutHDFS流: 

image:xyz-flow.png["XYZ Versioned Flow"] 

但是，PutHDFS现在引用了进程组级控制器服务: 

image:puthdfs-properties_2.png["PutHDFS Properties"] 

Sys_admin将进程组保存为版本化流. 

测试_user changes the flow by removing the KeytabCredentialsService controller service. However, with this configuration, if test_用户尝试还原此更改: 

image:test_user-revert-local-changes-2.png["Test_user Revert Local Changes"] 

恢复不成功，因为test_user没有'access keytab' KeytabCredentialService控制器服务所需的权限: 

image:revert-failure.png["Revert Local Changes Fails"] 

同样，如果test_user尝试导入XYZ版本化流程: 

image:test_user-import-xyz-flow.png["Test_user Import Flow"] 

导入失败: 

image:import-xyz-flow-fails.png["XYZ Import Fails"] 


[[templates]] 
== 模板 
DFM能够使用Orchsym Studio构建非常大且复杂的DataFlow.这是
通过使用基本组件实现 的:组件，漏斗，输入/输出端口，进程组和远程进程组.这些 
可以被认为是构建DataFlow的最基本构建块.但是，有时候，
如果需要重复多次相同的逻辑，使用这些 小的构建块会变得乏味. 

为了解决这个问题，Orchsym Studio提供了模板的概念.模板是将这些基本构建
块组合成更大的构建块的一种方式 . 创建DataFlow后，可以将其中的一部分组成模板. 
然后可以将此模板拖到画布上，也可以将其导出为XML文件并与其他人共享.
然后可以将从其他人处接收的模板 导入Orchsym Studio实例并拖动到画布上. 

[[Create_Template]] 
=== 创建模板 
要创建模板，请选择要作为模板一部分的组件，然后单击 
"创建模板”( 
image:iconNewTemplate.png["Create Template"] 
操作选项板中的按钮(有关操作选项板的更多信息，请参阅<<User_Interface>>). 

单击此按钮而不选择任何内容将创建一个包含
当前进程组的所有内容的模板 .这意味着在根进程组上
创建没有选择任何内容的模板 将创建一个包含整个流的模板. 

单击此按钮后，将提示用户提供模板的名称和可选说明. 
每个模板都必须具有唯一的名称.输入名称和可选说明后，单击"创建”按钮 
将生成模板并通知用户模板已成功创建，或者
如果由于某种原因无法创建模板，则提供相应的 错误消息. 

NOTE: 重要的是要注意，如果任何Templated组件具有敏感属性(例如密码)，则该 
敏感属性的值不包含在模板中.因此，将模板拖动到画布上时，
如果缺少敏感属性的值，则新 创建的组件可能无效。.此外，如果
连接的源或
目标未包含在模板中，则在制作模板时选择的任何 连接 都不包含在模板中. 

[[Import_Template]] 
=== 导入模板
收到从另一个Orchsym Studio导出的模板 后，使用该模板所需的第一步是 
将模板导入到此Orchsym Studio实例中.您可以将模板导入到具有相应
授权的任何Process Group . 

从操作面板中，单击"上传模板”( 
image:iconUploadTemplate.png["Upload Template"] 
)按钮(有关Operate Palette的更多信息，请参阅<<User_Interface>>).  这将显示"上载模板” 
对话框.  单击查找图标并使用"文件选择”对话框选择要上载的模板文件. 
选择文件，然后单击"打开”. 
单击"上传”按钮将尝试将模板导入此Orchsym Studio实例. 
如果导入模板时出现问题，"上载模板”对话框将更新为显示"成功”或错误消息. 


=== 

创建模板后实例化模板 (请参阅<<创建_Template>>) or imported (see <<Import_模板>>)，它已准备好 
实例化，或添加到画布. 这是通过拖动模板图标来完成的( 
image:iconTemplate.png["Template"] 
)从组件工具栏(请参阅<<User_Interface>>)到画布上. 

这将显示一个对话框，用于选择要添加到画布的模板.选择要添加的模板后，只需 
单击"添加”按钮即可.模板将添加到画布中，模板的左上角 
放置在用户放置模板图标的任何位置. 

这使得新实例化的模板的内容被选中.如果出现错误，并且
不再需要此模板 ，则可能会将其删除. 


[[Manage_Templates]] 
=== 管理模板 

Orchsym Studio模板最强大的功能之一是能够轻松地将模板导出到XML文件 
并导入已导出的模板.这提供了一种非常简单的机制，
用于与其他人共享部分 DataFlow.您可以从全局菜单中选择模板(请参阅<<User_Interface>>)以打开一个对话框 
，其中显示当前可用的所有模板， 
过滤模板以仅查看感兴趣的模板，导出和删除模板. 


[[Export_Template]] 
==== 导出模板 
创建模板后，可以在"模板管理”页面中与其他人共享模板. 
要导出模板，请在表中找到模板.
如果有几个可用，右上角的过滤器 可用于帮助查找相应的模板. 然后单击"导出”或"下载”按钮( 
image:iconExport.png["Export"] 
). 这会将模板作为XML文件下载到您的计算机.然后可以将此XML文件发送给其他人并导入 
到其他Orchsym Studio实例中(请参阅<<Import_Template>>). 


==== 删除模板 

一旦确定不再需要模板，就可以从模板管理页面轻松删除它.要删除模板，请在表格中找到它(
如果有几个可用，可以使用右上角的过滤器 查找相应的模板)，然后单击"删除”按钮( 
image:iconDelete.png["Delete"] 
). 这将提示确认.确认删除后，模板将从此表中删除， 
不再可用于添加到画布. 

[[data_provenance]] 
== 数据源 
在监控数据流时，用户通常需要一种方法来确定特定数据对象的发生情况(FlowFile). 
Orchsym Studio的Data Provenance页面提供了该信息.由于Orchsym Studio 
在对象流经系统时记录和索引数据来源详细信息 ，因此用户可以执行搜索，进行故障排除并
实时评估 数据流合规性和优化等内容.默认情况下，Orchsym Studio每五分钟更新一次此信息，但这是 
可配置的. 


要访问Data Provenance页面，请从Global Menu中选择Data Provenance.单击此按钮将打开一个对话窗口， 
允许用户查看可用的最新数据源文件信息， 
搜索特定项目的信息，并过滤搜索结果.还可以打开其他对话框窗口以查看事件详细信息， 
在数据流中的任何位置重放数据，以及查看数据的沿袭或流程路径的图形表示. 
(这些功能将在下面详细介绍.) 

image:provenance-annotated.png["Provenance Table"] 

[[provenance_events]] 
=== 源事件事件 

以某种方式处理FlowFile的数据流中的每个点都被视为"源头事件”.
根据数据流设计，会发生各种类型的起源 事件.例如，当数据进入流程时，会发生RECEIVE事件，并且当 
数据从流程中发出时，会发生SEND事件. 可能会发生其他类型的处理事件，例如克隆数据(CLONE事件)，路由(ROUTE事件)，修改(CONTENT)_MODIFIED or ATTRIBUTES_MODIFIED事件)， 
split(FORK事件)，与其他数据对象(JOIN事件)结合，最终从流中删除(DROP事件). 

起源事件类型是: 

[options="header"] 
|====================== 
|Provenance Event        |描述 
|ADDINFO                 |当添加其他信息(例如新链接到新URI或UUID)时，表示源项事件 
|ATTRIBUTES_MODIFIED     |表示以某种方式修改了FlowFile的属性 
|CLONE                   |表示FlowFile与其父FlowFile完全相同 
|CONTENT_MODIFIED        |表示以某种方式修改了FlowFile的内容 
|CREATE                  |表示FlowFile是从未从远程系统或外部进程接收的数据生成的 
|DOWNLOAD                |表示用户或外部实体下载了FlowFile的内容 
|DROP                    |表示由于对象到期之外的某些原因导致对象生命结束的起源事件 
|EXPIRE                  |表示由于未及时处理对象而导致对象生命结束的起源事件 
|FETCH                   |指示使用某些外部资源的内容覆盖FlowFile的内容 
|FORK                    |表示一个或多个FlowFiles是从父FlowFile派生的 
|JOIN                    |表示单个FlowFile是通过将多个父FlowFiles连接在一起而派生的 
|RECEIVE                 |表示从外部进程接收数据的来源事件 
|REPLAY                  |表示重放FlowFile的originance事件 
|ROUTE                   |表示FlowFile已路由到指定的关系，并提供有关FlowFile路由到此关系的原因的信息 
|SEND                    |表示将数据发送到外部进程的originance事件 
|UNKNOWN                 |表示原产地事件的类型未知，因为尝试访问该事件的用户无权知道该类型 
|====================== 

=== 搜索事件 
在Data Provenance页面中执行的最常见任务之一是搜索给定的FlowFile以确定它发生了什么.为此， 
请单击 `Search` Data Provenance页面右上角的按钮.这将打开一个对话框窗口，其中包含用户可以
为搜索定义的参数 . 参数包括感兴趣的处理事件，区分FlowFile或产生事件的组件的特征，搜索的时间范围以及FlowFile的大小. 

image:search-events.png["Search Events"] 

例如，要确定是否收到特定的FlowFile，请搜索"RECEIVE”事件类型并包含
FlowFile 的 标识符，例如其uuid或文件名. 星号(*)可以用作任意数量字符的通配符. 
因此，要确定在1月份的任何时间是否收到了文件名中任何地方带有"ABC”的FlowFile.2015年6月6日，
可以执行以下图像中显示的搜索 : 

image:search-receive-event-abc.png["Search for RECEIVE Event"] 

[[event_details]] 
=== 事件详细信息 
在"数据源”页面的最左侧列中，每个事件都有一个"查看详细信息”图标(image:iconDetails.png["Details"]). 
单击此按钮将打开一个对话框窗口，其中包含三个选项卡:详细信息，属性和内容. 

image:event-details.png["Event Details", width=700] 

"详细信息”选项卡显示有关事件的各种详细信息，例如事件发生的时间，事件的类型以及生成事件的组件. 
显示的信息将根据事件类型而有所不同. 此选项卡还显示有关已处理的FlowFile的信息.在 
除了FlowFile的UUID，其中显示详细信息标签的左侧，这是相关的任何父母或子女FlowFiles的UUID 
到FlowFile显示详细信息标签的右侧. 

"属性”选项卡显示流程中该点上FlowFile中存在的属性.为了仅查看
由于处理事件而修改的属性， 用户可以选择"属性”选项卡右上角"仅显示已修改”旁边的复选框. 

image:event-attributes.png["Event Attributes", width=700] 

=== 重播FlowFile 

DFM可能需要在数据流中的某个点检查FlowFile的内容，以确保按预期处理它.如果 
没有正确处理，DFM可能需要调整数据流并再次重放FlowFile. "查看详细信息”对话框窗口的"内容”选项卡是DFM可以执行这些操作的位置."内容”选项卡显示有关FlowFile内容的信息，例如其在内容存储库中的位置 
及其大小. 此外，用户可以点击此处 `Download` 按钮，用于下载
流程中此时存在的FlowFile内容的副本 . 用户也可以点击 `Submit` 按钮在流程中的此时重放FlowFile. 点击后 `Submit`， 
FlowFile被发送到为生成此处理事件的组件提供的连接. 

image:event-content.png["Event Content", width=700] 

=== 查看FlowFile Lineage查看FlowFile 

在数据流中占用的沿袭或路径的图形表示通常很有用.要查看FlowFile的血统， 
请单击"显示血统”图标(image:iconLineage.png["Show Lineage", width=28])在
Data Provenance表的最右侧列 中. 这将打开一个显示FlowFile的图表( image:lineage-flowfile.png["FlowFile", width=32])以及
已经发生的 各种处理事件. 所选事件将以红色突出显示.可以右键单击或双击任何 
事件以查看该事件的详细信息(请参阅<<event_details>>). 
要了解谱系如何随时间演变，请单击窗口左下角的滑块并将其向左移动以查看数据流中较早阶段的谱系状态. 

image:lineage-graph-annotated.png["Lineage Graph", width=900] 

==== 查找父级 
有时，用户可能需要跟踪从中生成另一个FlowFile的原始FlowFile.例如，当发生FORK或CLONE事件时，Orchsym Studio会 
跟踪生成其他FlowFiles的父FlowFile，并且可以在Lineage中找到父FlowFile.右键单击
沿袭图中的事件， 然后从上下文菜单中选择"查找父项”. 

image:find-parents.png["Find Parents"] 

选择"查找父项”后，将重新绘制图形以显示父FlowFile及其谱系以及子项及其谱系. 

image:parent-found.png["Parent Found"] 


==== 扩展事件 
与查找父FlowFile有用的方式相同，用户可能还想确定从给定的FlowFile生成的子项. 要执行此操作，请右键单击沿袭图中的事件，然后从上下文菜单中选择"展开”. 

image:expand-event.png["Expand Event"] 

选择"展开”后，将重新绘制图形以显示子项及其谱系. 

image:expanded-events.png["Expanded Events"] 

[[writeahead-provenance]] 
=== 
预先写入源代码库 默认情况下，Provenance Repository以持久源代码配置实现. 在Orchsym Studio 1中.2.0，引入了Write Ahead配置以提供与Persistent Provenance相同的功能，但具有更好的性能. 迁移到Write Ahead配置很容易实现. 只需更改设置即可 `Orchsym Studio.provenance.repository.implementation` 系统属性 `Orchsym Studio.properties` 文件的默认值为 `org.apache.Orchsym Studio.provenance.PersistentProvenanceRepository` 至 `org.apache.Orchsym Studio.provenance.WriteAheadProvenanceRepository` 并重新启动Orchsym Studio. 

但是，为了增加迁移成功的可能性，请考虑以下因素和建议的操作. 

==== 向后兼容性 

的 `WriteAheadProvenanceRepository` 可以使用由...存储的Provenance数据 `PersistentProvenanceRepository`. 但是，那 `PersistentProvenanceRepository` 可能无法读取由...写的数据 `WriteAheadProvenanceRepository`. 因此，一旦将Provenance Repository更改为使用 `WriteAheadProvenanceRepository`，它无法改变回来 `PersistentProvenanceRepository` 无需先删除Provenance存储库中的数据. 因此，建议在将实施更改为Write Ahead之前，确保您的Orchsym Studio版本稳定，以防出现问题，需要回滚到以前版本的Orchsym Studio，而不支持 `WriteAheadProvenanceRepository`. 

==== 较旧的现有Orchsym Studio版本 
如果您从较旧版本的Orchsym Studio升级到1.2.0或更高版本，建议您在1确认流量和环境稳定之前不要将原产地配置更改为"预先写入”.2.0首先.  这样可以减少升级中的变量数量，并在出现任何问题时简化调试过程. 

==== 引导.CONF 
虽然更好的性能与G1垃圾收集器实现的Java 8的错误可能会在预写的配置更频繁地浮出水面.  建议在下面注释掉以下行 `bootstrap.conf` 文件中 `conf` 目录: 


.... 
java.arg.13=-XX:+UseG1GC 
.... 


==== 系统属性 
Persistent和Write Ahead配置都支持许多相同的系统属性，但是为Persistent Provenance配置选择了默认值. 更改为Write Ahead配置时，应注意以下例外和建议: 

* `Orchsym Studio.provenance.repository.journal.count` 与Write Ahead配置无关 
* `Orchsym Studio.provenance.repository.concurrent.merge.threads` 和 `Orchsym Studio.provenance.repository.warm.cache.frequency` 是新的属性.  默认值为 `2` 对于线程和空白的频率(i.Ë. 对于大多数安装，应保留. 
* 更改设置 `Orchsym Studio.provenance.repository.max.storage.time` (默认值为 `24 hours`)和 `Orchsym Studio.provenance.repository.max.storage.size` (默认值为 `1 GB`)更适合您的生产环境的价值观 
* 更改 `Orchsym Studio.provenance.repository.index.shard.size` 来自默认值 `500 MB` 至 `4 GB` 
* 更改 `Orchsym Studio.provenance.repository.index.threads` 来自默认值 `2` 要么 `4` 要么 `8` 因为Write Ahead存储库可以使其更好地扩展 
* 如果处理大量事件，请更改 `Orchsym Studio.provenance.repository.rollover.time` 从默认值 `30 secs` 至 `1 min` 和 `Orchsym Studio.provenance.repository.rollover.size` 从默认值 `100 MB` 至 `1 GB` 

完成这些属性更改后，重新启动Orchsym Studio. 

**注意:** 有关这些属性的详细说明，请参阅<<administration-guide.adoc＃system_properties，系统属性>>. 

==== 加密的源代码注意事项 
上面的迁移建议 `WriteAheadProvenanceRepository` 也适用于配置的加密版本， `EncryptedWriteAheadProvenanceRepository`. 

下一节提供了有关实现Encrypted Provenance Repository的更多信息. 

[[encrypted-provenance]] 
=== 加密的源代码存储库 
虽然操作系统级别的访问控制可以提供对存储库中写入磁盘的源头数据的一些安全性，但是有些情况下数据可能是敏感的，合规性和法规要求存在，或者Orchsym Studio在不在其下的硬件上运行直接控制组织(云等).). 在这种情况下，originance存储库允许在将所有数据持久保存到磁盘之前对其进行加密. 

[WARNING] 
.性能 
============ 
加密的起源库的当前实现拦截了记录编写者和读者 `WriteAheadProvenanceRepository`，与传统相比，它提供了显着的性能改进 `PersistentProvenanceRepository` 并使用 `AES/GCM` 算法，在商品硬件上表现相当. 在大多数情况下，增加的成本将不会很大(在每秒数百个来源事件的流量上不明显，在数千个流量上有适度的显着性 - 每秒成千上万的事件). 但是，管理员应该执行自己的风险评估和性能分析，并决定如何继续前进. 目前不建议在加密/未加密的实现之间来回切换. 
============ 

==== 它是什么？ 

该 `EncryptedWriteAheadProvenanceRepository` 原始存储库的一个新实现，它在将所有事件记录信息写入存储库之前对其进行加密. 这允许在OS级访问控制不足以保护数据的系统上进行存储，同时仍允许通过Orchsym Studio UI / API查询和访问数据. 

==== 它是如何工作的？ 

该 `WriteAheadProvenanceRepository` 在Orchsym Studio 1中引入.2.0并提供了比以前更好的重构和更快的源文件库实现 `PersistentProvenanceRepository`. 加密版本使用记录编写器和读取器包装该实现，该记录编写器和读取器分别加密和解密序列化字节. 

完全合格的班级 `org.apache.Orchsym Studio.provenance.EncryptedWriteAheadProvenanceRepository` 被指定为原产地存储库实现 `Orchsym Studio.properties` 作为的价值 `Orchsym Studio.provenance.repository.implementation`. 另外，"行政指南”.必须填充adoc＃encrypted-write-ahead-provenance-repository-properties，new properties>>以允许成功初始化. 

===== StaticKeyProvider 
的 `StaticKeyProvider` 实现直接定义键 `Orchsym Studio.properties`. 各个密钥以十六进制编码提供. 密钥也可以像其他任何敏感属性一样加密 `Orchsym Studio.properties` 使用<<管理指南.ADOC＃加密，config_tool，`./encrypt-config.sh`>> Orchsym Studio工具包中的工具. 

以下配置部分将导致密钥提供程序具有两个可用密钥，"Key1”(活动)和"AnotherKey”. 

.... 
Orchsym Studio.provenance.repository.encryption.key.provider.implementation=org.apache.Orchsym Studio.security.kms.StaticKeyProvider 
Orchsym Studio.provenance.repository.encryption.key.id=Key1 
Orchsym Studio.provenance.repository.encryption.key=0123456789ABCDEFFEDCBA98765432100123456789ABCDEFFEDCBA9876543210 
Orchsym Studio.provenance.repository.encryption.key.id.AnotherKey=0101010101010101010101010101010101010101010101010101010101010101 
.... 


===== FileBasedKeyProvider 
的 `FileBasedKeyProvider` 实现从格式的加密定义文件中读取: 


.... 
key1=NGCpDpxBZNN0DBodz0p1SDbTjC2FG5kp1pCmdUKJlxxtcMSo6GC4fMlTyy1mPeKOxzLut3DRX+51j6PCO5SznA== 
key2=GYxPbMMDbnraXs09eGJudAM5jTvVYp05XtImkAg4JY4rIbmHOiVUUI6OeOf7ZW+hH42jtPgNW9pSkkQ9HWY/vQ== 
key3=SFe11xuz7J89Y/IQ7YbJPOL0/YKZRFL/VUxJgEHxxlXpd/8ELA7wwN59K1KTr3BURCcFP5YGmwrSKfr4OE4Vlg== 
key4=kZprfcTSTH69UuOU3jMkZfrtiVR/eqWmmbdku3bQcUJ/+UToecNB5lzOVEMBChyEXppyXXC35Wa6GEXFK6PMKw== 
key5=c6FzfnKm7UR7xqI2NFpZ+fEKBfSU7+1NvRw+XWQ9U39MONWqk5gvoyOCdFR1kUgeg46jrN5dGXk13sRqE0GETQ== 
.... 


每行定义一个密钥ID，然后定义16字节IV和包装的AES-128，AES-192或AES-256密钥的Base64编码密文，具体取决于可用的JCE策略. 各个密钥使用AES进行AES / GCM加密 **主密钥** 被定义为 `Orchsym Studio.bootstrap.sensitive.key` 在 `conf/bootstrap.conf`. 

===== 键旋转 
只需更新 `Orchsym Studio.properties` 引用新的密钥ID `Orchsym Studio.provenance.repository.encryption.key.id`. 只要该密钥在密钥定义文件中仍然可用，或者以前加密的事件仍可以解密 `Orchsym Studio.provenance.repository.encryption.key.id.<OldKeyID>` 因为密钥ID与加密记录一起序列化. 

==== 编写和读取事件记录 
初始化存储库后，将根据配置的模式编写器序列化所有源项事件记录写入操作(`EventIdFirstSchemaRecordWriter` 默认为 `WriteAheadProvenanceRepository`)到 `byte[]`. 然后使用的实现加密那些字节 `ProvenanceEventEncryptor` (目前唯一的实施是 `AES/GCM/NoPadding`)和加密元数据(`keyId`， `algorithm`， `version`， `IV`)序列化并预先添加. 完整的 `byte[]` 然后正常写入磁盘上的存储库. 

image:encrypted-wapr-hex.png["Encrypted provenance repository file on disk"] 

在记录读取时，该过程是相反的. 解密加密元数据并用于解密序列化字节，然后将其反序列化为 `ProvenanceEventRecord` 目的. 对正常模式记录编写器/读取器的委托允许"随机访问”(i.Ë. 立即寻求而不解密不必要的记录). 

在Orchsym Studio UI / API中，加密和未加密的起源存储库之间没有可检测到的差异. Provenance Query操作按预期工作，不会更改过程. 

==== 潜在问题 

[WARNING] 
.切换实现
============ 
在实现"家庭”之间切换 时(i.Ë. `VolatileProvenanceRepository` 要么 `PersistentProvenanceRepository` 至 `EncryptedWriteAheadProvenanceRepository`)，在启动Orchsym Studio之前，必须从文件系统中清除现有存储库. 像终端命令一样 `localhost:$Orchsym Studio_HOME $ rm -rf provenance_repository/` 足够了. 
============ 

* 在未加密和加密的存储库之间切换 
** 如果用户具有现有存储库(`WriteAheadProvenanceRepository` 只要 -- **不** `PersistentProvenanceRepository`)未加密并将其配置切换为使用加密存储库，应用程序将错误写入日志但启动. 但是，以前的事件无法通过起源查询界面访问，新事件将覆盖现有事件. 如果用户从加密存储库切换到未加密的存储库，则会发生相同的行为. 自动翻车是未来的努力(link:https://issues.apache.org/jira/browse/Orchsym Studio-3722[Orchsym Studio-3722^])但Orchsym Studio不是用于长期存放物源事件，因此影响应该是最小的. 翻转有两种情况: 
*** 加密 ->未加密 -- 如果先前的存储库实现已加密，则只要可用的密钥提供程序仍具有用于加密事件的密钥，就应无缝地处理这些事件(请参阅 **钥匙轮换**) 
*** 未加密 ->加密 -- 如果以前的存储库实现未加密，则应无缝处理这些事件，因为先前记录的事件只需要使用明文架构记录读取器读取，然后使用加密记录编写器写回 
** 今后还有一项工作是在Orchsym Studio Toolkit中提供一个独立工具来加密/解密现有的出处存储库，以简化过渡. 转换过程可能需要很长时间，具体取决于现有存储库的大小，并且能够在应用程序启动之外执行此任务将是有价值的(link:https://issues.apache.org/jira/browse/Orchsym Studio-3723[Orchsym Studio-3723^]). 
* 多个存储库 -- 目前尚未对多个存储库应用额外的工作或测试. 可能/可能在不同物理设备上的存储库中会出现问题. 没有选择提供异质环境(i.Ë. 一个加密的，一个明文存储库). 
* 腐败 -- 当磁盘已填满或损坏时，已报告存储库损坏并且需要恢复步骤的问题. 这可能会继续成为加密存储库的问题，尽管其范围仍然限于单个记录(i.Ë. 由于加密，整个存储库文件将无法恢复. 

[[other_management_features]] 
== 其他管理功能 

除摘要页面，数据源页面，模板管理页面和公告板页面外，
全局菜单中还有 其他工具(请参阅<<User_Interface>>)，这些工具对DFM很有用.选择"流配置历史记录”以查看 
对数据流所做的所有更改.历史记录可以帮助进行故障排除，例如 
最近数据流的更改是否已导致问题并需要修复.DFM可以查看已进行的更改并 
根据需要调整流量以解决问题.虽然Orchsym Studio没有"撤消”功能，但DFM可以对
数据流进行新的更改以 解决问题. 

全局菜单中的另外两个工具是控制器设置和用户."控制器设置”页面提供更改 
Orchsym Studio实例名称，添加描述Orchsym Studio实例的注释以及设置
应用程序可用的最大线程数的功能 . 它还提供了DFM可以添加和配置<<Controller的选项卡_Services>> and <<Reporting_任务>>.的用户页面是用于管理用户访问，这是在所描述 
的link:administration-guide.html[System Administrator's Guide]. 
